%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{\emph{Abjad}: a model of notation}
\label{chap:a-model-of-notation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Abjad\cite{baca2011xi, trevino2013compositional} is an open-source
Python\cite{vanrossum2003ys} package which extends the Python programming
language with a computational model of music notation. Abjad allows its users
to construct scores in an object-oriented fashion and visualize their work as
publication-quality notation at any point in the composition process.
Additionally, Abjad can be installed and imported into a Python interpreter
session just like any other Python package. Importantly, Abjad is not a
stand-alone application and has no GUI -- no graphic user interface -- unlike
many other related projects such as PWGL\cite{laurson2009qf,
kuuskankare2004recent}, OpenMusic\cite{assayag1999sw},
BACH\cite{agostini2013real} and many others. All work is done in the
command-line, either directly in an interactive Python console session, or by
writing modules of code to be imported into one another and executed by
Python's interpreter. Nearly all of the code examples in the body of this
document are presented as part of a single interactive Python console session
simply because Python's interactive console clearly distinguishes input from
output. Lines preceded by \texttt{>>>} will be passed to Python for
interpretation. Those preceded by \texttt{...} indicate the continuation of a
incomplete language construct. All other lines are necessarily returned as
output from Python's interpreter.

We can import Abjad into Python with the following incantation:

\begin{comment}
<abjad>
import abjad
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> import abjad
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Abjad is implemented as a collection of over 900 public classes and
functions spread across nearly 40 subpackages, totally almost 200,000 lines of
source code. Many of these classes and functions are available immediately
within Abjad's root \emph{namespace}. We can enumerate these
\enquote{top-level} names by calling Python's built-in \texttt{dir()} function
on the imported \texttt{abjad} module object. After stripping out all
\enquote{private} names -- those starting with underscores -- Abjad's top-level
names can be printed to Python's interactive console:

\begin{comment}
<abjad>[text_width=105]
abjad_names = dir(abjad)
abjad_names = [x for x in abjad_names if not x.startswith('_')]
print(abjad_names)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> abjad_names = dir(abjad)
>>> abjad_names = [x for x in abjad_names if not x.startswith('_')]
>>> print(abjad_names)
['Accelerando', 'Articulation', 'Beam', 'Chord', 'Clef', 'Container', 'Context', 'Crescendo',
'Decrescendo', 'Duration', 'Dynamic', 'Fermata', 'Fraction', 'Glissando', 'Hairpin', 'KeySignature',
'Markup', 'Measure', 'MultimeasureRest', 'Multiplier', 'NamedPitch', 'Note', 'Offset', 'Rest',
'Ritardando', 'Score', 'Sequence', 'Skip', 'Slur', 'Staff', 'StaffGroup', 'Tempo', 'Tie',
'TimeSignature', 'Timespan', 'Tuplet', 'Voice', 'abctools', 'abjad_configuration', 'abjadbooktools',
'agenttools', 'attach', 'datastructuretools', 'detach', 'developerscripttools', 'documentationtools',
'durationtools', 'exceptiontools', 'f', 'graph', 'handlertools', 'indicatortools', 'inspect_',
'instrumenttools', 'ipythontools', 'iterate', 'labeltools', 'layouttools', 'lilypondfiletools',
'lilypondnametools', 'lilypondparsertools', 'markuptools', 'mathtools', 'metertools', 'mutate', 'new',
'override', 'parse', 'persist', 'pitchtools', 'play', 'quantizationtools', 'rhythmmakertools',
'rhythmtreetools', 'schemetools', 'scoretools', 'select', 'selectiontools', 'selectortools',
'sequencetools', 'set_', 'show', 'sievetools', 'spannertools', 'stringtools', 'systemtools',
'templatetools', 'timespantools', 'tonalanalysistools', 'topleveltools']
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Names beginning with uppercase letters represent classes. These
include many of the musical objects composers would likely create by hand. Most
of these classes have direct notational analogs on the page -- e.g.
\texttt{Note}, \texttt{Rest} and \texttt{Chord} --, or map to common structural
or typographic concepts in Abjad's primary typesetting engine, LilyPond, such
as \texttt{Voice}, \texttt{Markup} and \texttt{Skip}. Lowercase names ending in
the string \enquote{tools} represent additional libraries or \emph{subpackages}
within Abjad. These subpackages group together related functionality within a
common namespace. For example, Abjad's \texttt{pitchtools} subpackage contains
dozens of classes and functions solely for modeling pitch objects, collections
of those objects, and their transformations:

\begin{comment}
<abjad>[text_width=105]
pitchtools_names = dir(abjad.pitchtools)
pitchtools_names = [x for x in pitchtools_names if not x.startswith('_')]
print(pitchtools_names)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> pitchtools_names = dir(abjad.pitchtools)
>>> pitchtools_names = [x for x in pitchtools_names if not x.startswith('_')]
>>> print(pitchtools_names)
['Accidental', 'Interval', 'IntervalClass', 'IntervalClassSegment', 'IntervalClassSet',
'IntervalClassVector', 'IntervalSegment', 'IntervalSet', 'IntervalVector', 'Inversion', 'Multiplication',
'NamedInterval', 'NamedIntervalClass', 'NamedInversionEquivalentIntervalClass', 'NamedPitch',
'NamedPitchClass', 'NumberedInterval', 'NumberedIntervalClass',
'NumberedInversionEquivalentIntervalClass', 'NumberedPitch', 'NumberedPitchClass',
'NumberedPitchClassColorMap', 'Octave', 'Pitch', 'PitchArray', 'PitchArrayCell', 'PitchArrayColumn',
'PitchArrayInventory', 'PitchArrayRow', 'PitchClass', 'PitchClassSegment', 'PitchClassSet',
'PitchClassTree', 'PitchClassVector', 'PitchOperation', 'PitchRange', 'PitchRangeInventory',
'PitchSegment', 'PitchSet', 'PitchVector', 'Registration', 'RegistrationComponent',
'RegistrationInventory', 'Retrogression', 'Rotation', 'Segment', 'Set', 'StaffPosition', 'Transposition',
'TwelveToneRow', 'Vector', 'instantiate_pitch_and_interval_test_collection',
'inventory_inversion_equivalent_named_interval_classes',
'inventory_named_inversion_equivalent_interval_classes', 'iterate_named_pitch_pairs_in_expr',
'list_named_pitches_in_expr', 'list_numbered_interval_numbers_pairwise',
'list_numbered_inversion_equivalent_interval_classes_pairwise',
'list_ordered_named_pitch_pairs_from_expr_1_to_expr_2', 'list_pitch_numbers_in_expr',
'list_unordered_named_pitch_pairs_in_expr', 'set_written_pitch_of_pitched_components_in_expr',
'sort_named_pitch_carriers_in_expr', 'transpose_named_pitch_by_numbered_interval_and_respell',
'transpose_pitch_carrier_by_interval', 'transpose_pitch_class_number_to_pitch_number_neighbor',
'transpose_pitch_expr_into_pitch_range', 'transpose_pitch_number_by_octave_transposition_mapping',
'yield_all_pitch_class_sets']
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Many of these subpackages implement opinionated collections of
compositional devices, certainly useful for some composers but by no means
considered core to Abjad's notational model. For example, Abjad's
\texttt{quantizationtools} provides a rhythmic quantizer inspired by Paul
Nauert's concept of \enquote{Q-grids}\cite{nauert1997timespan},
\texttt{rhythmtreetools} parses a Lisp-like \enquote{RTM-syntax} -- which
should be familiar to anyone working with OpenMusic\cite{assayag1999sw},
PWGL\cite{laurson2009qf, kuuskankare2004recent} or Bach\cite{agostini2013real},
-- into object-oriented rhythm-tree data structures, and the
\texttt{sievetools} subpackage models Iannis Xenakis' pitch
sieves\cite{xenakis1992formalized}. Still other subpackages implement more
\enquote{objective} functionality, such as \texttt{mathtools} or
\texttt{durationtools}. Many of the remaining subpackages collect together
related musical and typographic classes and functions, e.g.
\texttt{scoretools}, \texttt{spannertools}, \texttt{markuptools}, and
\texttt{indicatortools}. Others simply exist for \enquote{internal} use by
Abjad's developers, assisting in the development and maintenance of the system,
such as \texttt{abctools}, \texttt{developerscripttools},
\texttt{documentationtools} and \texttt{systemtools}.

The remaining names in Abjad's namespace represent its \enquote{top-level}
functions, including \texttt{attach()}, \texttt{detach()},
\texttt{inspect\_()}, \texttt{iterate()}, \texttt{mutate()}, \texttt{new()},
\texttt{override()}, \texttt{parse()}, \texttt{persist()}, \texttt{play()},
\texttt{select()}, \texttt{set\_()}, and -- most importantly --
\texttt{show()}. These functions provide a powerful set of tools for
interacting with Abjad's notational objects and factories, and will be
explained in detail as we encounter each of them.

For the sake of brevity, this document -- across each chapter -- will behave as
though the contents of Abjad's namespace has been imported into Python's global
namespace:

\begin{comment}
<abjad>
from abjad import *
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> from abjad import *
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\section{Representing objects}

In Python, everything is an object, even integers, boolean values and
functions. Because Python is also interpreted and can be used interactively,
those objects must be representable in an interpreter session, which is
necessarily textual. Objects' text, or \emph{string}, representations can take
a variety of forms, and those same objects may specify explicitly how they
should be represented textually, just as they may specify how they should
behave in relation to operations such as addition, multiplication, or
iteration.

Python classes often specify their behavior in terms of \emph{protocols}.
Protocols are established by convention rather than enforced at the system
level. This explanation takes place via \enquote{dunder} methods --
double-underscore methods -- such as \texttt{\_\_repr\_\_()} which provides an
object's \emph{interpreter representation} in cooperation with Python's
\texttt{repr()} function and \texttt{\_\_str\_\_()} which provides an object's
string representation in cooperation with Python's \texttt{str()}
function. By overriding these dunder methods, a class may specify its own
version of string or interpreter representation behavior.

For example, a simple \texttt{Foo} class, which overrides neither
\texttt{\_\_str\_\_()} nor \texttt{\_\_repr\_\_()} may be defined and
instantiated:

\begin{comment}
<abjad>
class Foo(object):
    pass

foo = Foo()
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> class Foo(object):
...     pass
...
>>> foo = Foo()
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent When printed to the terminal, cast as a string, and represented,
Python's default object representation is used, giving the module and name of
the class as well as its memory location. Note that when calling Python's
\texttt{print()} function on an object, that object is converted to a string
and then printed to the console, resulting in text without quotation marks:

\begin{comment}
<abjad>
print(foo)
repr(foo)
str(foo)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> print(foo)
<__main__.Foo object at 0x103a2d110>
\end{lstlisting}
\begin{lstlisting}
>>> repr(foo)
'<__main__.Foo object at 0x103a2d110>'
\end{lstlisting}
\begin{lstlisting}
>>> str(foo)
'<__main__.Foo object at 0x103a2d110>'
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Defining a new class, \texttt{Foo2}, which overrides both string and
interpreter representation provides customized output. Note that printing the
\texttt{Foo2} instance relies on its string representation, rather than its
interpreter representation, while simply referencing the instantiated
\texttt{Foo2} object uses its interpreter representation -- its \enquote{repr}:

\begin{comment}
<abjad>
class Foo2(object):
    def __repr__(self):
        return '<I am Foo2>'
    def __str__(self):
        return 'foofoo'

foo2 = Foo2()
foo2
print(foo2)
repr(foo2)
str(foo2)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> class Foo2(object):
...     def __repr__(self):
...         return '<I am Foo2>'
...     def __str__(self):
...         return 'foofoo'
...
>>> foo2 = Foo2()
>>> foo2
<I am Foo2>
\end{lstlisting}
\begin{lstlisting}
>>> print(foo2)
foofoo
\end{lstlisting}
\begin{lstlisting}
>>> repr(foo2)
'<I am Foo2>'
\end{lstlisting}
\begin{lstlisting}
>>> str(foo2)
'foofoo'
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Defining a third version of \texttt{Foo} with an overridden
\texttt{\_\_format\_\_()} method allows for creating alternate string
representations. By calling Python's built-in \texttt{format()} function on a
\texttt{Foo3} instance, either the normal string representation or a
\enquote{special} representation can be created. This formatting behavior can
also be extended to support an arbitrary number of format specifications:

\begin{comment}
<abjad>
class Foo3(object):
    def __format__(self, format_specification=''):
        if format_specification == 'special':
            return '~~~ special foo format ~~~~'
        return str(self)
    def __repr__(self):
        return '<I am Foo3>'
    def __str__(self):
        return 'foofoofoo'

foo3 = Foo3()
foo3
print(foo3)
repr(foo3)
str(foo3)
format(foo3)
format(foo3, 'special')
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> class Foo3(object):
...     def __format__(self, format_specification=''):
...         if format_specification == 'special':
...             return '~~~ special foo format ~~~~'
...         return str(self)
...     def __repr__(self):
...         return '<I am Foo3>'
...     def __str__(self):
...         return 'foofoofoo'
...
>>> foo3 = Foo3()
>>> foo3
<I am Foo3>
\end{lstlisting}
\begin{lstlisting}
>>> print(foo3)
foofoofoo
\end{lstlisting}
\begin{lstlisting}
>>> repr(foo3)
'<I am Foo3>'
\end{lstlisting}
\begin{lstlisting}
>>> str(foo3)
'foofoofoo'
\end{lstlisting}
\begin{lstlisting}
>>> format(foo3)
'foofoofoo'
\end{lstlisting}
\begin{lstlisting}
>>> format(foo3, 'special')
'~~~ special foo format ~~~~'
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Many Abjad objects have multiple possible string representations. For
example, a \texttt{Note} object can be represented by its normal interpreter
representation, as a LilyPond string, or by its \emph{storage format} -- a more
verbose, potentially multi-line string representation generally used when
persisting complex objects to disk.

\begin{comment}
<abjad>
note = Note(NamedPitch("g'"), Duration(3, 4))
note
print(repr(note))
print(note)
print(str(note))
print(format(note))
print(format(note, 'lilypond'))
print(format(note, 'storage'))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> note = Note(NamedPitch("g'"), Duration(3, 4))
>>> note
Note("g'2.")
\end{lstlisting}
\begin{lstlisting}
>>> print(repr(note))
Note("g'2.")
\end{lstlisting}
\begin{lstlisting}
>>> print(note)
g'2.
\end{lstlisting}
\begin{lstlisting}
>>> print(str(note))
g'2.
\end{lstlisting}
\begin{lstlisting}
>>> print(format(note))
g'2.
\end{lstlisting}
\begin{lstlisting}
>>> print(format(note, 'lilypond'))
g'2.
\end{lstlisting}
\begin{lstlisting}
>>> print(format(note, 'storage'))
scoretools.Note("g'2.")
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent For some Abjad classes -- especially those representing glyphs in
music notation -- their default string format is their LilyPond string
representation. Other classes -- especially Abjad's various highly-configurable
notation factory classes -- default their string format to their storage
format, allowing for complex but still human-readable interpreter output:

\begin{comment}
<abjad>
rhythm_maker = rhythmmakertools.TaleaRhythmMaker(
    talea=rhythmmakertools.Talea([1, 2, 3], 16),
    extra_counts_per_division=(1, 0, 2, 1, 0),
    output_masks=[
        rhythmmakertools.SustainMask([1], 3, 1, -1),
        rhythmmakertools.SilenceMask([-1]),
        ],
    tie_specifier=rhythmmakertools.TieSpecifier(
        tie_across_divisions=True,
        ),
    )
print(format(rhythm_maker))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> rhythm_maker = rhythmmakertools.TaleaRhythmMaker(
...     talea=rhythmmakertools.Talea([1, 2, 3], 16),
...     extra_counts_per_division=(1, 0, 2, 1, 0),
...     output_masks=[
...         rhythmmakertools.SustainMask([1], 3, 1, -1),
...         rhythmmakertools.SilenceMask([-1]),
...         ],
...     tie_specifier=rhythmmakertools.TieSpecifier(
...         tie_across_divisions=True,
...         ),
...     )
>>> print(format(rhythm_maker))
rhythmmakertools.TaleaRhythmMaker(
    talea=rhythmmakertools.Talea(
        counts=(1, 2, 3),
        denominator=16,
        ),
    extra_counts_per_division=(1, 0, 2, 1, 0),
    output_masks=rhythmmakertools.BooleanPatternInventory(
        (
            rhythmmakertools.SustainMask(
                indices=(1,),
                period=3,
                start=1,
                stop=-1,
                ),
            rhythmmakertools.SilenceMask(
                indices=(-1,),
                ),
            )
        ),
    tie_specifier=rhythmmakertools.TieSpecifier(
        tie_across_divisions=True,
        ),
    )
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Finally, in the spirit of Python's protocols and dunder conventions,
Abjad provides its own \emph{illustration protocol} and
\texttt{\_\_illustrate\_\_()} dunder method. This method works with Abjad's
top-level \texttt{show()} function to generate graphic realizations of
illustratable Python objects via LilyPond. Abjad's \texttt{show()} function
will be used throughout this document to create and display notation and
otherwise graphic representations:

\begin{comment}
<abjad>
show(note)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> show(note)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-5cfff2844553f774341de4a66c379061.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\section{The score tree}

Abjad models notated musical scores as a \emph{tree} consisting of
\emph{components}, \emph{indicators} and \emph{spanners}. All objects appearing
in a score fall into one of those three categories.

\subsection{Components}

\begin{comment}
-   Every component may be named.
-   components, leaves, containers (and contexts)
-   components are formattable and illustrable
-   components are mutable, while indicators are generally not
    -   likewise, durations and pitches are immutable

-   count-time components
    -   note, chord, rest, skip, container, tuplet, measure
-   non-count-time (contexts)
    -   voice, staff, staff group, score

-   leaves do not contain anything else
    -   chord do *not* contain notes
    -   chords and notes contain note heads
    -   chord and notes share a single stem
    -   this must be disambiguated from note columns

-   all containers derive their duration from their contents (with some
    exceptions, but even there a mismatch is an error)
-   written duration, prolated duration, pre-prolated duration, contents
    duration

-   One, and only one, parent per component. They *cannot* be in more than one
    container. This is both confusing, and liable to cause reference problems.
-   score hierarchy is not fixed: any node is the root, if it has no parent

-   contexts are assumed to last from the beginning to the end of the total
    timespan of the score, but in practice they may be intermittent
-   contexts may be named, allowing concatenation

-   Leaves reside at the "bottom" of the score hierarchy.

Work aspects of this into appropriate sections

-   inspect_()
-   not *inspect()*, as that would cause a name conflict with Python's inspect
    module
-   inspect(...).get_parentage()
-   inspect_(...).get_duration()
    -   in_seconds=True
-   inspect_(...).get_timespan()
    -   in_seconds=True
\end{comment}

Components make up the \emph{nodes} of the score tree, treating the score as an
acyclic directed rooted graph, or \emph{arborescence}, rooted on a single
component. All components inherit from Abjad's \texttt{Component} class, which
encapsulates logic crucial to maintaining the correctness of the score tree,
and affords behaviors common to all component subclasses including
illustration, formatting and naming. Abjad divides score components into
\emph{containers} -- those components which may contain other other components,
such as staves, voices, tuplets, measures and so forth -- and \emph{leaves} --
those components which may contain no other components, such as notes, chords
and rests, as well as LilyPond's multi-measure rests and non-printing
typographic \emph{skips}. Additionally, components can each be instantiated
from a variety of input, from parsable LilyPond syntax strings to parametric
arguments -- both numeric and explicitly object-modeled via pitch and duration
objects. For example, we can instantiate and illustrate a middle-C quarter
note:

\begin{comment}
<abjad>
note = Note("c'4")
show(note)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> note = Note("c'4")
>>> show(note)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-c018a545d264ff34225e9a3a5babb6c1.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent a half-note rest:

\begin{comment}
<abjad>
rest = Rest((1, 2))
show(rest)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> rest = Rest((1, 2))
>>> show(rest)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-8144dc38435e18921a5d584ad635d2e3.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent and a D-minor chord:

\begin{comment}
<abjad>
chord = Chord(
    [NamedPitch("d'"), NamedPitch("f'"), NamedPitch("a'")],
    Duration(1, 4),
    )
show(chord)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> chord = Chord(
...     [NamedPitch("d'"), NamedPitch("f'"), NamedPitch("a'")],
...     Duration(1, 4),
...     )
>>> show(chord)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-fef850f162448b1e8d3c6be53e362436.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Each of the above three leaf instantiations demonstrates a different
means of creating score objects, none of which is unique to the particular
class they have been demonstrated with here. The \texttt{Note} instantiation
demonstrates creating a score object via LilyPond syntax, the rest
instantiation demonstrates creating a score object from
sequences of integers -- in this case the pair (1, 2), representing the
duration of a half-note -- and the chord instantiation demonstrates using
explicit \texttt{NamedPitch} and \texttt{Duration} objects. The latter two
instantiation techniques afford parametric approaches, while the LilyPond
syntax allows for a great degree of expressivity as score components can be
created with articulations, dynamics and other indicators already attached:

\begin{comment}
<abjad>
fancy_chord = Chord(r"<g' bf'? d''>4. -\accent -\staccato ^\markup{ \italic gently }")
show(fancy_chord)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> fancy_chord = Chord(r"<g' bf'? d''>4. -\accent -\staccato ^\markup{ \italic gently }")
>>> show(fancy_chord)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-ffbf3288650db529c52c1e9ac804f9f0.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\subsection{Containers}
\label{ssec:containers}

Abjad's container classes -- measures, tuplets, voice, staves, staff groups,
scores and so forth -- implement Python's \emph{mutable sequence protocol},
allowing them to be used transparently as though they were lists.

Components can be appended, extended, or inserted into a container, and
container can be instantiated with lists of components to be contained as one
of their arguments. Note above that the LilyPond output shows a \sfrac{4}{4}
time signature even though none of the created leaves takes up an whole note's
duration. LilyPond simply treats all music as \sfrac{4}{4} unless explicitly
instructed otherwise. We can make the \sfrac{4}{4} time signature explicit by
instantiating a \sfrac{4}{4} measure to contain the previously-created three
leaf instances:

\begin{comment}
<abjad>
measure = Measure((4, 4), [note, rest, chord])
show(measure)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> measure = Measure((4, 4), [note, rest, chord])
>>> show(measure)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-cad7b59ce37e423c6cdc4729377818c7.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Containers can also be indexed into, measured for length and iterated
over. For example, the second component contained by the measure can be
retrieved by subscripting the measure with the index 1:

\begin{comment}
<abjad>
measure[1]
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> measure[1]
Rest('r2')
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent That second component -- the half-note rest -- can be replaced by
another container, a triplet:

\begin{comment}
<abjad>
outer_tuplet = Tuplet((2, 3), "a'4 b4 cs'4")
measure[1] = outer_tuplet
show(measure)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> outer_tuplet = Tuplet((2, 3), "a'4 b4 cs'4")
>>> measure[1] = outer_tuplet
>>> show(measure)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-f9a8a92bd9dbe5f480a4003ade9c81aa.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Furthermore, the last two leaves in the triplet can be replaced by a
quintuplet using Python's \emph{slice assignment} syntax. In the following
code, the text \texttt{outer\_tuplet[1:]} references the selection of
components in the original triplet starting from the second component and going
\enquote{to the end} -- effectively the second and third item, as there are
only three. That selection is then replaced by a list containing a quintuplet,
substituting the contents of one sequence of components for the contents of
another.

\begin{comment}
<abjad>
inner_tuplet = Tuplet((4, 5), "b'8 a'8. g'16 f'8.. e'32")
outer_tuplet[1:] = [inner_tuplet]
show(measure)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> inner_tuplet = Tuplet((4, 5), "b'8 a'8. g'16 f'8.. e'32")
>>> outer_tuplet[1:] = [inner_tuplet]
>>> show(measure)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-958463d38eb75b71ce0e7aaa2b9ae94e.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent The measure can be inspected for its length by using Python's
built-in \texttt{len()} function. Note that this returns the number of
components \emph{immediately} contained by the measure -- 3 --, but not the
total number of components, total number of leaves or total duration. The
latter queries can be satisfied by other means.

\begin{comment}
<abjad>
len(measure)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> len(measure)
3
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Iterating over the contents of the \sfrac{4}{4} measure yields only
the top-most components in that container -- its immediate children:

\begin{comment}
<abjad>
for component in measure:
    component

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> for component in measure:
...     component
...
Note("c'4")
Tuplet(Multiplier(2, 3), "a'4 { 4/5 b'8 a'8. g'16 f'8.. e'32 }")
Chord("<d' f' a'>4")
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent To retrieve all of the leaves of a container, recursion must be used,
as any container may contain other containers, and those in turn still more
containers. To mitigate this complexity, every container provides a
\texttt{select\_leaves()} method, which returns a selection of the bottom-most
leaf instances in the subtree rooted at that container:

\begin{comment}
<abjad>
for leaf in measure.select_leaves():
    leaf

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> for leaf in measure.select_leaves():
...     leaf
...
Note("c'4")
Note("a'4")
Note("b'8")
Note("a'8.")
Note("g'16")
Note("f'8..")
Note("e'32")
Chord("<d' f' a'>4")
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Note that Abjad's \texttt{Chord} class aggregates multiple \emph{note
heads} rather than notes. Likewise Abjad's \texttt{Note} class aggregates a
single note head. While chords implement containment in terms of note heads --
delegating to a dedicated note head inventory -- they are not themselves
"containers" in the same sense that a voice, measure or tuplet are containers.
It is important here to differentiate between the concept of a \enquote{chord}
as a single duration paired with a collection of pitches and a \enquote{chord}
as the sounding sonority at some given point in a piece spread over some number
of voices. Abjad always makes use of the former rather than the latter.

\begin{comment}
<abjad>
note_head_inventory = chord.note_heads
for note_head in note_head_inventory:
    note_head

chord.note_heads.append(NamedPitch("c''"))
show(chord)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> note_head_inventory = chord.note_heads
>>> for note_head in note_head_inventory:
...     note_head
...
NoteHead("d'")
NoteHead("f'")
NoteHead("a'")
\end{lstlisting}
\begin{lstlisting}
>>> chord.note_heads.append(NamedPitch("c''"))
>>> show(chord)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-0419b405f12cba5bff2e20c17c72e860.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\subsection{Parentage}
\label{ssec:parentage}

The container that contains a given component is called its \emph{parent}, and
the components contained in a container are known as that container's
\emph{children}. Every component may have one and only one parent container,
although a component may also have no parent -- a null parent reference. Any
component whose parent is null is necessarily the root of its own score tree.
Furthermore, no component may appear in its own \emph{proper parentage} -- the
sequence of components comprising the unique path from a given component to the
root of its tree, excepting the component itself -- as this would induce
reference cycles within the score tree.\footnote{Disambiguate proper and
improper parentage in terms of set-theory.}

Abjad object-models the concept of parentage explicitly as a \texttt{Parentage}
\emph{selection} class, accessible via the \emph{inspector} which exposes a
given component's \emph{inspection interface}: a collection of methods for
accessing information about that component, many of which depend on that
component's position within the score hierarchy, including the component's
parentage or duration. An inspector can be instantiated by calling Abjad's
top-level \texttt{inspect\_()} function on a component.\footnote{Abjad uses
\texttt{inspect\_()} rather than \texttt{inspect()} as Python already provides
an \texttt{inspect} module for object introspection, and it is considered bad
practice to overwrite names of functions, classes or modules found in the
standard library such as \texttt{set} or \texttt{object}. When a name conflict
would occur, projects traditionally append an underscore to the name they wish
to use.} Consider the parentage for the first eighth note of the inner tuplet.
Its parentage -- \emph{improper} by default -- includes itself, its immediate
quintuplet parent, its triplet grandparent and the \sfrac{4}{4} measure as its
great-grandparent:\footnote{The component summary strings in the interpreter
representations of the components in the parentage are \emph{note} valid
LilyPond syntax, but simply a concise LilyPond-like syntax.}

\begin{comment}
<abjad>
inner_b_eighth = measure[1][1][0]
inspector = inspect_(inner_b_eighth)
parentage = inspector.get_parentage()
parentage.parent
for component in parentage:
    component

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> inner_b_eighth = measure[1][1][0]
>>> inspector = inspect_(inner_b_eighth)
>>> parentage = inspector.get_parentage()
>>> parentage.parent
Tuplet(Multiplier(4, 5), "b'8 a'8. g'16 f'8.. e'32")
\end{lstlisting}
\begin{lstlisting}
>>> for component in parentage:
...     component
...
Note("b'8")
Tuplet(Multiplier(4, 5), "b'8 a'8. g'16 f'8.. e'32")
Tuplet(Multiplier(2, 3), "a'4 { 4/5 b'8 a'8. g'16 f'8.. e'32 }")
Measure((4, 4), "c'4 { 2/3 a'4 { 4/5 b'8 a'8. g'16 f'8.. e'32 } } <d' f' a' c''>4")
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent By default, every component's parent is null, represented in Python
by Python's \texttt{None} object:

\begin{comment}
<abjad>
whole_note = Note("c'1")
inspector = inspect_(whole_note)
inspector.get_parentage().parent is None
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> whole_note = Note("c'1")
>>> inspector = inspect_(whole_note)
>>> inspector.get_parentage().parent is None
True
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Inserting the above whole note into a container sets the whole note's
parent to that container. Additionally, the container is now aware that it
contains the whole note, demonstrating the bi-directional references inherent
to Abjad's score tree model:

\begin{comment}
<abjad>
container_one = Container()
container_one.append(whole_note)
inspector.get_parentage().parent is container_one
whole_note in container_one
print(format(container_one))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> container_one = Container()
>>> container_one.append(whole_note)
>>> inspector.get_parentage().parent is container_one
True
\end{lstlisting}
\begin{lstlisting}
>>> whole_note in container_one
True
\end{lstlisting}
\begin{lstlisting}
>>> print(format(container_one))
{
    c'1
}
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Inserting the same whole note into a different container removes it
from the first, demonstrating that components can only exist in one container
at a time:

\begin{comment}
<abjad>
container_two = Container()
container_two.append(whole_note)
inspector.get_parentage().parent is container_two
whole_note in container_two
whole_note in container_one
print(format(container_two))
print(format(container_one))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> container_two = Container()
>>> container_two.append(whole_note)
>>> inspector.get_parentage().parent is container_two
True
\end{lstlisting}
\begin{lstlisting}
>>> whole_note in container_two
True
\end{lstlisting}
\begin{lstlisting}
>>> whole_note in container_one
False
\end{lstlisting}
\begin{lstlisting}
>>> print(format(container_two))
{
    c'1
}
\end{lstlisting}
\begin{lstlisting}
>>> print(format(container_one))
{
}
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Likewise, while the first container can be inserted into the second,
the second container cannot be inserted back into the first. Such an
arrangement would cause the second container to become its own grandparent, and
therefore generates an error:

\begin{comment}
<abjad>[allow_exceptions]
container_two.append(container_one)
container_one.append(container_two)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> container_two.append(container_one)
>>> container_one.append(container_two)
Traceback (most recent call last):
  File "<abjadbook>", line 1, in <module>
  File "/Users/josiah/Documents/Development/abjad/abjad/tools/scoretools/Container.py", line 902, in append
    self.__setitem__(slice(len(self), len(self)), [component])
  File "/Users/josiah/Documents/Development/abjad/abjad/tools/scoretools/Container.py", line 130, in __setitem__
    return self._set_item(i, expr)
  File "/Users/josiah/Documents/Development/abjad/abjad/tools/scoretools/Container.py", line 421, in _set_item
    raise ParentageError('Attempted to induce cycles.')
ParentageError: Attempted to induce cycles.
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Why should we be concerned with reference cycles? When we create
score by hand, notes -- no matter how we may have arrived at them or conceived
of them creatively -- are ultimately simply black marks on a page. When working
with computer, we can choose how to model musical objects. Again, a
\enquote{note} could simply exist as an amalgam of dots and lines in a
vector-graphics program, in which case it may not be possible to know where or
even what that note or any other note \emph{is} except in terms of dots and
lines -- the affordances provided by that vector-graphics editor. In that case,
there is no semantic model of music, only a typographic model devoid of
explicit musical relationships. Alternatively, we can model explicitly, in
which case notes exist as "objects" in a rich network of references. In this
latter case, certain conditions must be maintained to protect the integrity of
the reference network. Depending on the implementation, a note likely cannot
be in two places at once. That is the certainly the case in Abjad's model of
musical notation: notes can only have one parent, and cannot exist in more than
one parent. Note that these restrictions mainly derive from the fact that
notes, like other scores components, are both \emph{mutable} -- that is,
changeable after they have been instantiated, and therefore \emph{stateful} --
and possess many references to objects \enquote{outside} of themselves. In
contrast, Abjad's pitch and duration classes have no state -- they are
\emph{immutable} -- and reference no other objects. They can therefore appear
in many places within the same score. Arbitrarily many score components can
reference the same duration in memory, much as arbitrarily many objects can
reference the same integer. Such an arrangement is often referred to as a
\emph{flyweight}\cite{gamma1994design}.

\subsection{Durations}

Every Abjad score component may be expressed in terms of its duration, as
well as its start offset relative to the score origin and, by extension,
its timespan -- the span of time bounded by their start offset and their stop
offset. Abjad models all such duration objects as \emph{rationals}: ratios of
real numbers, e.g. \sfrac{1}{2}, \sfrac{7}{23} or {16}{1}. This concern arises
from the realization that all durations and offsets expressible in Western
common practice notation are rational, rather than floating-point or any other
representation. Necessarily, Abjad's \texttt{Duration}, \texttt{Offset} and
\texttt{Multiplier} classes all derive from Python's
\texttt{fractions.Fraction} class. Both \texttt{Offset} and \texttt{Multiplier}
are little more than aliases to Abjad's \texttt{Duration} class. However, their
use throughout Abjad's code-base, and those projects heavily dependent upon
Abjad, such as Consort, greatly clarify compositional intent and increase the
source's legibility.

Abjad's \texttt{Duration} class extends Python's \texttt{Fraction} class with a
number of new initialization patterns and a variety of notation-specific
properties. For example, a \sfrac{7}{16} duration can be instantiated from a
numerator/denominator pair, or from a LilyPond syntax duration string:

\begin{comment}
<abjad>
Duration(7, 16)
Duration.from_lilypond_duration_string('4..')
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> Duration(7, 16)
Duration(7, 16)
\end{lstlisting}
\begin{lstlisting}
>>> Duration.from_lilypond_duration_string('4..')
Duration(7, 16)
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Duration objects can provide information about how they should be
interpreted notationally, including how many dots or flags they would have if
used to instantiate a leaf. A \sfrac{7}{16} duration, without resorting to
tuplets or ties, might be represented in notation by a double-dotted quarter
note, thus giving a dot count of 2 and a flag count of 0:

\begin{comment}
<abjad>
Duration(7, 16).dot_count
Duration(7, 16).flag_count
Duration(7, 16).lilypond_duration_string
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> Duration(7, 16).dot_count
2
\end{lstlisting}
\begin{lstlisting}
>>> Duration(7, 16).flag_count
0
\end{lstlisting}
\begin{lstlisting}
>>> Duration(7, 16).lilypond_duration_string
'4..'
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent As mentioned in \autoref{ssec:parentage}, duration are immutable.
Like other immutable objects in Python -- e.g. integers and string --, they
raise errors when anything attempts to alter them in anyway:

\begin{comment}
<abjad>[allow_exceptions]
string = 'abcdefghi'
string[1:-1] = 'xyz'
Duration(3, 4).numerator = 7
Duration(1, 2).nonexistant_property = 'This will never work'
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> string = 'abcdefghi'
>>> string[1:-1] = 'xyz'
Traceback (most recent call last):
  File "<abjadbook>", line 1, in <module>
TypeError: 'str' object does not support item assignment
\end{lstlisting}
\begin{lstlisting}
>>> Duration(3, 4).numerator = 7
Traceback (most recent call last):
  File "<abjadbook>", line 1, in <module>
AttributeError: can't set attribute
\end{lstlisting}
\begin{lstlisting}
>>> Duration(1, 2).nonexistant_property = 'This will never work'
Traceback (most recent call last):
  File "<abjadbook>", line 1, in <module>
AttributeError: 'Duration' object has no attribute 'nonexistant_property'
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Additionally, some mathematical operations between offsets and
durations provide results typed in a musically-sensible fashion. For example,
the difference between two offsets returns a duration, while a duration added
to an offset returns another offset:

\begin{comment}
<abjad>
offset_one = Offset(1, 2)
offset_two = Offset(7, 4)
offset_two - offset_one
offset_two + Duration(3, 8)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> offset_one = Offset(1, 2)
>>> offset_two = Offset(7, 4)
>>> offset_two - offset_one
Duration(5, 4)
\end{lstlisting}
\begin{lstlisting}
>>> offset_two + Duration(3, 8)
Offset(17, 8)
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent The duration of each leaf derives from the product of its
\emph{written duration} -- a duration representing the actual glyphs used in
the score as represented by some combination of note heads, stems, beams and
dots -- and their \emph{prolation} -- the cumulative product of all of the
duration multipliers of the containers in a component's proper parentage.

Consider again the measure created earlier in \autoref{ssec:containers}:

\begin{comment}
<abjad>
show(measure)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> show(measure)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-90dec32270a651cac6d00667c9c50fd2.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent The B eighth-note starting the quintuplet is nested within two
different tuplets with different multipliers. While the note's parentage object
can calculate its prolation, we can also calculate the prolation by hand in
order to demonstrate the technique:

\begin{comment}
<abjad>
parentage = inspect_(inner_b_eighth).get_parentage()
parentage.prolation
by_hand_prolation = 1
for parent in parentage[1:]:
    if isinstance(parent, Tuplet):
        by_hand_prolation = by_hand_prolation * parent.multiplier

by_hand_prolation
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> parentage = inspect_(inner_b_eighth).get_parentage()
>>> parentage.prolation
Multiplier(8, 15)
\end{lstlisting}
\begin{lstlisting}
>>> by_hand_prolation = 1
>>> for parent in parentage[1:]:
...     if isinstance(parent, Tuplet):
...         by_hand_prolation = by_hand_prolation * parent.multiplier
...
>>> by_hand_prolation
Multiplier(8, 15)
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent By multiplying each leaf's written duration by its prolation, we can
determine that leaf's actual, or prolated, duration. Note too that this
conforms to the results of the inspector's \texttt{get\_duration()} method:

\begin{comment}
<abjad>
for leaf in measure.select_leaves():
    inspector = inspect_(leaf)
    written_duration = leaf.written_duration
    prolation = inspector.get_parentage().prolation
    actual_duration = inspector.get_duration()
    string = '{!r}: {!s} * {!s} = {!s}'
    string = string.format(leaf, written_duration, prolation, actual_duration)
    print(string)

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> for leaf in measure.select_leaves():
...     inspector = inspect_(leaf)
...     written_duration = leaf.written_duration
...     prolation = inspector.get_parentage().prolation
...     actual_duration = inspector.get_duration()
...     string = '{!r}: {!s} * {!s} = {!s}'
...     string = string.format(leaf, written_duration, prolation, actual_duration)
...     print(string)
...
Note("c'4"): 1/4 * 1 = 1/4
Note("a'4"): 1/4 * 2/3 = 1/6
Note("b'8"): 1/8 * 8/15 = 1/15
Note("a'8."): 3/16 * 8/15 = 1/10
Note("g'16"): 1/16 * 8/15 = 1/30
Note("f'8.."): 7/32 * 8/15 = 7/60
Note("e'32"): 1/32 * 8/15 = 1/60
Chord("<d' f' a' c''>4"): 1/4 * 1 = 1/4
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Written durations must be \emph{assignable}. Assignability describes
the set of durations describable in Western common practice notation solely
through combining a single note head, its flags and dots, without recourse to
ties or tuplets. Any rational duration $\sfrac{n}{d}$ is considered assignable
when and only when it adheres to the form

\begin{equation}
{ 2^k * (2^u - j) \over 2^v }
\end{equation}

\noindent where $u$, $v$ and $k$ are nonnegative integers, $j \leq u$ and $j$
is either 1 or 0. Assignability guarantees that a duration's denominator is
always a positive power-of-two integer, such as 1, 2, 4, 8, 16 and so forth,
and therefore precludes durations such as $\sfrac{1}{3}$ or $\sfrac{2}{5}$.
Likewise, assignability permits numerators such as 1, 2, 3, 4, 6, 7, 8, 12, 14
and 15 but forbids 5, 9, 10, 13 and 17, as they imply ties. More elegantly, any
integer can be considered if its binary representation does not contain the
substring \enquote{01}:

\begin{comment}
<abjad>
for i in range(17):
    binary_string = mathtools.integer_to_binary_string(i)
    is_assignable = mathtools.is_assignable_integer(i)
    string = '{}: {} [{}]'.format(i, binary_string, is_assignable)
    print(string)

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> for i in range(17):
...     binary_string = mathtools.integer_to_binary_string(i)
...     is_assignable = mathtools.is_assignable_integer(i)
...     string = '{}: {} [{}]'.format(i, binary_string, is_assignable)
...     print(string)
...
0: 0 [False]
1: 1 [True]
2: 10 [True]
3: 11 [True]
4: 100 [True]
5: 101 [False]
6: 110 [True]
7: 111 [True]
8: 1000 [True]
9: 1001 [False]
10: 1010 [False]
11: 1011 [False]
12: 1100 [True]
13: 1101 [False]
14: 1110 [True]
15: 1111 [True]
16: 10000 [True]
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent The duration of each container then derives from the product of its
prolation and its *contents duration* -- the sum of the durations of its
children. Ultimately, all scores derive their durations from the durations of
their leaves, prolated as necessary by any tuplets. As components enter and
leave a container, the duration of that container and the offsets of components
following the inserted or deleted component adjust dynamically to reflect the
altered structure:

\begin{comment}
<abjad>
staff = Staff("c'4 d'4 e'4 f'4")
show(staff)
inspect_(staff).get_duration()
for leaf in staff:
    offset = inspect_(leaf).get_timespan().start_offset
    print(offset, leaf)

staff[2:2] = "f''4 e''4 d''4 c''4"
show(staff)
inspect_(staff).get_duration()
for leaf in staff:
    offset = inspect_(leaf).get_timespan().start_offset
    print(offset, leaf)

staff[3:5] = []
show(staff)
inspect_(staff).get_duration()
for leaf in staff:
    offset = inspect_(leaf).get_timespan().start_offset
    print(offset, leaf)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> staff = Staff("c'4 d'4 e'4 f'4")
>>> show(staff)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-3947a1689e36c26dfc1db5d199985257.pdf}
\begin{lstlisting}
>>> inspect_(staff).get_duration()
Duration(1, 1)
\end{lstlisting}
\begin{lstlisting}
>>> for leaf in staff:
...     offset = inspect_(leaf).get_timespan().start_offset
...     print(offset, leaf)
...
(Offset(0, 1), Note("c'4"))
(Offset(1, 4), Note("d'4"))
(Offset(1, 2), Note("e'4"))
(Offset(3, 4), Note("f'4"))
\end{lstlisting}
\begin{lstlisting}
>>> staff[2:2] = "f''4 e''4 d''4 c''4"
>>> show(staff)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-378ec9dd2a14b504935cd7108d9b08b9.pdf}
\begin{lstlisting}
>>> inspect_(staff).get_duration()
Duration(2, 1)
\end{lstlisting}
\begin{lstlisting}
>>> for leaf in staff:
...     offset = inspect_(leaf).get_timespan().start_offset
...     print(offset, leaf)
...
(Offset(0, 1), Note("c'4"))
(Offset(1, 4), Note("d'4"))
(Offset(1, 2), Note("f''4"))
(Offset(3, 4), Note("e''4"))
(Offset(1, 1), Note("d''4"))
(Offset(5, 4), Note("c''4"))
(Offset(3, 2), Note("e'4"))
(Offset(7, 4), Note("f'4"))
\end{lstlisting}
\begin{lstlisting}
>>> staff[3:5] = []
>>> show(staff)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-64d327db461ddb041d653c1bd1d31ee6.pdf}
\begin{lstlisting}
>>> inspect_(staff).get_duration()
Duration(3, 2)
\end{lstlisting}
\begin{lstlisting}
>>> for leaf in staff:
...     offset = inspect_(leaf).get_timespan().start_offset
...     print(offset, leaf)
(Offset(0, 1), Note("c'4"))
(Offset(1, 4), Note("d'4"))
(Offset(1, 2), Note("f''4"))
(Offset(3, 4), Note("c''4"))
(Offset(1, 1), Note("e'4"))
(Offset(5, 4), Note("f'4"))
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Finally, multiplier objects may be attached to leaves to multiply
their duration. When attached to multi-measure rests, not only does the overall
duration of the leaf change, but LilyPond is able to generate typography
representing multiple bars of tacet music compressed together:

\begin{comment}
<abjad>
multimeasure_rest = scoretools.MultimeasureRest(1)
inspect_(multimeasure_rest).get_duration()
show(multimeasure_rest)
attach(Multiplier(4), multimeasure_rest)
inspect_(multimeasure_rest).get_duration()
show(multimeasure_rest)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> multimeasure_rest = scoretools.MultimeasureRest(1)
>>> inspect_(multimeasure_rest).get_duration()
Duration(1, 1)
\end{lstlisting}
\begin{lstlisting}
>>> show(multimeasure_rest)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-099f7141431afa5ae3a046415764f35b.pdf}
\begin{lstlisting}
>>> attach(Multiplier(4), multimeasure_rest)
>>> inspect_(multimeasure_rest).get_duration()
Duration(4, 1)
\end{lstlisting}
\begin{lstlisting}
>>> show(multimeasure_rest)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-a8fdc5cae1a0a9fb72680a5d18862c4e.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\subsection{Named components}

Components may be named.

Any named component found in the subtree of a given container may be accessed,
regardless of its depth in that container, by subscripting the container with
its name.

-   Demonstrate setting up a small score with named contexts and retrieving
    them.

-   Explain contexts as distinct from containers. What is a context? Count-time
    and non-count-time containers. LilyPond context concatenation.

\begin{comment}
<abjad>
voice_1 = Voice(name='Voice 1')
upper_staff = Staff(
    [voice_1],
    name='Upper Staff',
    )
voice_2 = Voice(name='Voice 2')
voice_3 = Voice(name='Voice 3')
lower_staff = Staff(
    [voice_2, voice_3],
    is_simultaneous=True,
    name='Lower Staff',
    )
staff_group = StaffGroup(
    [upper_staff, lower_staff],
    context_name='PianoStaff',
    name='Staff Group',
    )
score = Score([staff_group])
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> voice_1 = Voice(name='Voice 1')
>>> upper_staff = Staff(
...     [voice_1],
...     name='Upper Staff',
...     )
>>> voice_2 = Voice(name='Voice 2')
>>> voice_3 = Voice(name='Voice 3')
>>> lower_staff = Staff(
...     [voice_2, voice_3],
...     is_simultaneous=True,
...     name='Lower Staff',
...     )
>>> staff_group = StaffGroup(
...     [upper_staff, lower_staff],
...     context_name='PianoStaff',
...     name='Staff Group',
...     )
>>> score = Score([staff_group])
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\begin{comment}
<abjad>
print(format(score))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> print(format(score))
\new Score <<
    \context PianoStaff = "Staff Group" <<
        \context Staff = "Upper Staff" {
            \context Voice = "Voice 1" {
            }
        }
        \context Staff = "Lower Staff" <<
            \context Voice = "Voice 2" {
            }
            \context Voice = "Voice 3" {
            }
        >>
    >>
>>
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\begin{comment}
<abjad>
score['Voice 1']
score['Voice 1'] is voice_1
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> score['Voice 1']
Voice()
\end{lstlisting}
\begin{lstlisting}
>>> score['Voice 1'] is voice_1
True
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\subsection{Indicators}

\begin{comment}
Indicators attach to individual components
-   some have notational reality
-   some have context scope
-   but they can be totally arbitrary
-   attach(x, y, scope=..., is_annotation=..., name=...)
-   Articulation
-   BarLine
-   Clef
-   Dynamic
-   KeySignature
-   Markup
-   Tempo
-   TimeSignature
-   What is scope?
-   Default scope
-   Explicit scope
-   Idiomatic indicators, used by other processes:
    -   BowContactPoint
    -   IsAtSoundingPitch
    -   IsUnpitched
    -   StringContactPoint
    -   StringTuning
    -   etc.
-   Annotation
-   attach(x, y, is_annotation=True)
-   inspect_(...).get_indicator()
-   inspect_(...).has_indicator()
-   inspect_(...).get_effective()
-   inspect_(...).has_effective_indicator()
\end{comment}

\subsection{Attachment}

\subsection{Scope}

\begin{comment}
<abjad>
attach(Clef('treble'), upper_staff)
attach(Clef('bass'), lower_staff)
voice_one_command = indicatortools.LilyPondCommand(
    'voiceOne',
    format_slot='opening',
    )
voice_two_command = indicatortools.LilyPondCommand(
    'voiceTwo',
    format_slot='opening',
    )
attach(voice_one_command, voice_1)
attach(voice_two_command, voice_2)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> attach(Clef('treble'), upper_staff)
>>> attach(Clef('bass'), lower_staff)
>>> voice_one_command = indicatortools.LilyPondCommand(
...     'voiceOne',
...     format_slot='opening',
...     )
>>> voice_two_command = indicatortools.LilyPondCommand(
...     'voiceTwo',
...     format_slot='opening',
...     )
>>> attach(voice_one_command, voice_1)
>>> attach(voice_two_command, voice_2)
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

-   One clef per staff (staff scope)
-   Separate dynamics per voice (voice scope)
-   One tempo (score scope)
-   Arbitrary scoped object (score scope?)

\subsection{Annotation}

\subsection{Spanners}

\begin{comment}
Spanners *span* across different levels of hierarchy.
-   logical voices
-   attach to
-   graph cyclicity
-   Beam
-   Glissando
-   Hairpin
-   Slur
-   Trill
-   Tie
-   typographic overrides
# Typographic overrides
-   On components
    - \\override & \\revert
-   On spanners
# Modeling time
-   Duration
-   Offset
-   Multiplier
-   Timespan
-   Prolation
-   Pre-prolated durations
-   Contents duration
\end{comment}

\section{Selecting components}

-   Selections

\subsection{Indexing}

-   By name

-   By index

-   By slice

\subsection{Selection}

-   select()

-   Selection class

-   Container.select\_leaves()

    -   allow\_discontiguous\_leaves=True

-   inspect\_(...).get\_logical\_tie()

-   LogicalTie

    -   head

    -   tail

    -   timespan

    -   trivial logical ties

\subsection{Iteration}

-   By \_\_iter\_\_()

-   By iterate(...)by\_...()

    -   by\_class()

    -   by\_logical\_tie()

    -   by\_run()

    -   by\_timeline()

    -   by\_vertical\_moment()

    -   depth\_first()

\subsection{Selectors}

-   Demonstrate a gallery of selectors.

    -   by duration

    -   by leaves

    -   by length

    -   by logical tie

    -   by counts (with negative counts too)

\section{Mutating components}

-   replace()

-   split()

-   transpose()

\section{Representing pitches}

-   The most important distinction is between named and numbered pitch
    objects.

-   All pitched score components (notes and chords) rely on named
    representations of pitch, not numbered

-   Named pitch objects are enharmonically explicit

-   Numbered pitch objects require some interpretation

-   Abjad has provided one interpretation, but that is for sufficiency

-   Abjad does not make smart guesses about converting numbered to named
    pitches

\subsection{Named and numbered pitch objects}

-   Pitches and pitch-classes

-   Intervals and interval-classes

-   NamedPitch
    -   NamedPitchClass
    -   Accidental
    -   Octave
    -   StaffPosition

-   NamedInterval
    -   Quality

-   NumberedPitch is more equivalent

\subsection{Collections}

-   Set, Segment, Vector

-   PitchSegment

-   PitchClassSegment

-   PitchRange

\subsection{Pitch operations}

-   PitchOperation

-   Transposition

-   Inversion

-   Retrogression

-   Multiplication

-   Rotation

\subsection{Inspecting leaf pitches}

-   Note("c'4").written\_pitch

-   Note("c'4").note\_head.written\_pitch

-   Chord("<c' e' g'>4").written\_pitches

-   inspect\_(note).get\_sounding\_pitch()

-   inspect\_(note).get\_sounding\_pitches()

\section{Notation factories}

-   rhythm-makers

-   score templates

-   parsers

    -   LilyPond parser

    -   PLY

    -   SchemeParser

    -   RhythmTreeParser

    -   ReducedLyParser

- Templating

\section{Examples}

\begin{comment}
<abjad>
upper_voice = Voice(name='Upper Voice')
upper_staff = Staff([upper_voice], name='Upper Staff')
lower_voice_a = Voice(name='Lower Voice A')
lower_voice_b = Voice(name='Lower Voice B')
lower_staff = Staff([lower_voice_a, lower_voice_b], name='Lower Staff')
piano_staff = StaffGroup([upper_staff, lower_staff], context_name='PianoStaff')
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> upper_voice = Voice(name='Upper Voice')
>>> upper_staff = Staff([upper_voice], name='Upper Staff')
>>> lower_voice_a = Voice(name='Lower Voice A')
>>> lower_voice_b = Voice(name='Lower Voice B')
>>> lower_staff = Staff([lower_voice_a, lower_voice_b], name='Lower Staff')
>>> piano_staff = StaffGroup([upper_staff, lower_staff], context_name='PianoStaff')
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\begin{comment}
<abjad>
note = Note("fs'4.")
show(note)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> note = Note("fs'4.")
>>> show(note)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-3899aee7438e42c8270d14ffdc03cb30.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\begin{comment}
<abjad>
note = Note(6, (3, 8))
show(note)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> note = Note(6, (3, 8))
>>> show(note)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-3899aee7438e42c8270d14ffdc03cb30.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\begin{comment}
<abjad>
chord = Chord("<c'' ef'' g''>2")
show(chord)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> chord = Chord("<c'' ef'' g''>2")
>>> show(chord)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-82ef35ebb9d559540a877d9291a02ca8.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\begin{comment}
<abjad>
chord = Chord((12, 15, 19), (1, 2))
show(chord)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> chord = Chord((12, 15, 19), (1, 2))
>>> show(chord)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-82ef35ebb9d559540a877d9291a02ca8.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\begin{comment}
<abjad>
rest = Rest("r4")
show(rest)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> rest = Rest("r4")
>>> show(rest)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-78f6872e9c498f4e522a51716ff458dd.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\begin{comment}
<abjad>
rest = Rest((1, 4))
show(rest)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> rest = Rest((1, 4))
>>> show(rest)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-78f6872e9c498f4e522a51716ff458dd.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\begin{comment}
<abjad>
skip = scoretools.Skip(1)
show(skip)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> skip = scoretools.Skip(1)
>>> show(skip)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-23f5992f0758dbf9cdee4ac0a923bc09.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\begin{comment}
<abjad>
note.note_head
note.note_head.is_cautionary = True
show(note)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> note.note_head
NoteHead("fs'")
\end{lstlisting}
\begin{lstlisting}
>>> note.note_head.is_cautionary = True
>>> show(note)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-cb1badca7eef4417a7ce0afba8009a29.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\begin{comment}
<abjad>
for note_head in chord.note_heads:
    note_head

chord.note_heads.append("a'")
show(chord)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> for note_head in chord.note_heads:
...     note_head
...
NoteHead("c''")
NoteHead("ef''")
NoteHead("g''")
\end{lstlisting}
\begin{lstlisting}
>>> chord.note_heads.append("a'")
>>> show(chord)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-f6ffc8242c578f619b7b053e9eab2333.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\begin{comment}
<abjad>
pitch_segment = pitchtools.PitchSegment("c' ef' b' bf' f' e' b a")
show(pitch_segment)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> pitch_segment = pitchtools.PitchSegment("c' ef' b' bf' f' e' b a")
>>> show(pitch_segment)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-98c254b3bf3525db1108455a9eb836a7.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\begin{comment}
<abjad>
transposition = pitchtools.Transposition(1)
show(transposition(pitch_segment))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> transposition = pitchtools.Transposition(1)
>>> show(transposition(pitch_segment))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-749c176dfaf42985bd3b0d224300b46a.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\begin{comment}
<abjad>
inversion = pitchtools.Inversion()
show(inversion(pitch_segment))
inversion_with_axis = pitchtools.Inversion(axis=NamedPitch("d'"))
show(inversion_with_axis(pitch_segment))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> inversion = pitchtools.Inversion()
>>> show(inversion(pitch_segment))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-f5dccecbacdc176c5636cb8662091fbd.pdf}
\begin{lstlisting}
>>> inversion_with_axis = pitchtools.Inversion(axis=NamedPitch("d'"))
>>> show(inversion_with_axis(pitch_segment))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-3788337f7ed0f9f5205ea317fef25ba7.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\begin{comment}
<abjad>
retrogression = pitchtools.Retrogression()
show(retrogression(pitch_segment))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> retrogression = pitchtools.Retrogression()
>>> show(retrogression(pitch_segment))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-deb23384afe7501bded563186defeabd.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\begin{comment}
<abjad>
untransposing_rotation = pitchtools.Rotation(-1, transpose=False)
show(untransposing_rotation(pitch_segment))
transposing_rotation = pitchtools.Rotation(-1, transpose=True)
show(transposing_rotation(pitch_segment))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> untransposing_rotation = pitchtools.Rotation(-1, transpose=False)
>>> show(untransposing_rotation(pitch_segment))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-a64fe671be8f551e1d653f00a83a2e07.pdf}
\begin{lstlisting}
>>> transposing_rotation = pitchtools.Rotation(-1, transpose=True)
>>> show(transposing_rotation(pitch_segment))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-7bd7aa6d7685f24919cad726cee57c04.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\begin{comment}
<abjad>
multiplication = pitchtools.Multiplication(3)
show(multiplication(pitch_segment))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> multiplication = pitchtools.Multiplication(3)
>>> show(multiplication(pitch_segment))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-ea43de43da8ed2236bf38e48fab7ca25.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\begin{comment}
<abjad>
pitch_operation = pitchtools.PitchOperation(
    operators=(
        pitchtools.Rotation(1),
        pitchtools.Transposition(2),
        ),
    )
show(pitch_operation(pitch_segment))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> pitch_operation = pitchtools.PitchOperation(
...     operators=(
...         pitchtools.Rotation(1),
...         pitchtools.Transposition(2),
...         ),
...     )
>>> show(pitch_operation(pitch_segment))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-0adc9e231ee227673c0a09c603241ec2.pdf}
\end{singlespacing}
\end{abjadbookoutput}