%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{\emph{Abjad}: a model of notation}
\label{chap:a-model-of-notation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Abjad\cite{baca2011xi, trevino2013compositional} is an open-source
Python\cite{vanrossum2003ys} package which extends the Python programming
language with a computational model of music notation. Abjad allows its users
to construct scores in an object-oriented fashion and visualize their work as
publication-quality notation at any point in the composition process.
Additionally, Abjad can be installed and imported into a Python interpreter
session just like any other Python package. Importantly, Abjad is not a
stand-alone application and has no GUI -- no graphic user interface -- unlike
many other related projects such as PWGL\cite{laurson2009qf,
kuuskankare2004recent}, OpenMusic\cite{assayag1999sw},
BACH\cite{agostini2013real} and many others. All work is done in the
command-line, either directly in an interactive Python console session, or by
writing modules of code to be imported into one another and executed by
Python's interpreter. Nearly all of the code examples in the body of this
document are presented as part of a single interactive Python console session
simply because Python's interactive console clearly distinguishes input from
output. Lines preceded by \texttt{>>>} will be passed to Python for
interpretation. Those preceded by \texttt{...} indicate the continuation of a
incomplete language construct. All other lines are necessarily returned as
output from Python's interpreter.

We can import Abjad into Python with the following incantation:

\begin{comment}
<abjad>
import abjad
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> import abjad
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Abjad is implemented as a collection of over 900 public classes and
functions spread across nearly 40 subpackages, totally almost 200,000 lines of
source code. Many of these classes and functions are available immediately
within Abjad's root \emph{namespace}. We can enumerate these
\enquote{top-level} names by calling Python's built-in \texttt{dir()} function
on the imported \texttt{abjad} module object. After stripping out all
\enquote{private} names -- those starting with underscores -- Abjad's top-level
names can be printed to Python's interactive console:

\begin{comment}
<abjad>[text_width=105]
abjad_names = dir(abjad)
abjad_names = [x for x in abjad_names if not x.startswith('_')]
print(abjad_names)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> abjad_names = dir(abjad)
>>> abjad_names = [x for x in abjad_names if not x.startswith('_')]
>>> print(abjad_names)
['Accelerando', 'Articulation', 'Beam', 'Chord', 'Clef', 'Container', 'Context', 'Crescendo',
'Decrescendo', 'Duration', 'Dynamic', 'Fermata', 'Fraction', 'Glissando', 'Hairpin', 'KeySignature',
'Markup', 'Measure', 'MultimeasureRest', 'Multiplier', 'NamedPitch', 'Note', 'Offset', 'Rest',
'Ritardando', 'Score', 'Sequence', 'Skip', 'Slur', 'Staff', 'StaffGroup', 'Tempo', 'Tie',
'TimeSignature', 'Timespan', 'Tuplet', 'Voice', 'abctools', 'abjad_configuration', 'abjadbooktools',
'agenttools', 'attach', 'datastructuretools', 'detach', 'developerscripttools', 'documentationtools',
'durationtools', 'exceptiontools', 'f', 'graph', 'handlertools', 'indicatortools', 'inspect_',
'instrumenttools', 'ipythontools', 'iterate', 'labeltools', 'layouttools', 'lilypondfiletools',
'lilypondnametools', 'lilypondparsertools', 'ly', 'markuptools', 'mathtools', 'metertools', 'mutate',
'new', 'override', 'parse', 'persist', 'pitchtools', 'play', 'quantizationtools', 'rhythmmakertools',
'rhythmtreetools', 'schemetools', 'scoretools', 'select', 'selectiontools', 'selectortools',
'sequencetools', 'set_', 'show', 'sievetools', 'spannertools', 'stringtools', 'systemtools',
'templatetools', 'timespantools', 'tonalanalysistools', 'topleveltools']
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Names beginning with uppercase letters represent classes. These
include many of the musical objects composers would likely create by hand. Most
of these classes have direct notational analogs on the page -- e.g.
\texttt{Note}, \texttt{Rest} and \texttt{Chord} --, or map to common structural
or typographic concepts in Abjad's primary typesetting engine, LilyPond, such
as \texttt{Voice}, \texttt{Markup} and \texttt{Skip}. Lowercase names ending in
the string \enquote{tools} represent additional libraries or \emph{subpackages}
within Abjad. These subpackages group together related functionality within a
common namespace. For example, Abjad's \texttt{pitchtools} subpackage contains
dozens of classes and functions solely for modeling pitch objects, collections
of those objects, and their transformations:

\begin{comment}
<abjad>[text_width=105]
pitchtools_names = dir(abjad.pitchtools)
pitchtools_names = [x for x in pitchtools_names if not x.startswith('_')]
print(pitchtools_names)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> pitchtools_names = dir(abjad.pitchtools)
>>> pitchtools_names = [x for x in pitchtools_names if not x.startswith('_')]
>>> print(pitchtools_names)
['Accidental', 'Interval', 'IntervalClass', 'IntervalClassSegment', 'IntervalClassSet',
'IntervalClassVector', 'IntervalSegment', 'IntervalSet', 'IntervalVector', 'Inversion', 'Multiplication',
'NamedInterval', 'NamedIntervalClass', 'NamedInversionEquivalentIntervalClass', 'NamedPitch',
'NamedPitchClass', 'NumberedInterval', 'NumberedIntervalClass',
'NumberedInversionEquivalentIntervalClass', 'NumberedPitch', 'NumberedPitchClass',
'NumberedPitchClassColorMap', 'Octave', 'Pitch', 'PitchArray', 'PitchArrayCell', 'PitchArrayColumn',
'PitchArrayInventory', 'PitchArrayRow', 'PitchClass', 'PitchClassSegment', 'PitchClassSet',
'PitchClassTree', 'PitchClassVector', 'PitchOperation', 'PitchRange', 'PitchRangeInventory',
'PitchSegment', 'PitchSet', 'PitchVector', 'Registration', 'RegistrationComponent',
'RegistrationInventory', 'Retrogression', 'Rotation', 'Segment', 'Set', 'StaffPosition', 'Transposition',
'TwelveToneRow', 'Vector', 'instantiate_pitch_and_interval_test_collection',
'inventory_inversion_equivalent_named_interval_classes',
'inventory_named_inversion_equivalent_interval_classes', 'iterate_named_pitch_pairs_in_expr',
'list_named_pitches_in_expr', 'list_numbered_interval_numbers_pairwise',
'list_numbered_inversion_equivalent_interval_classes_pairwise',
'list_ordered_named_pitch_pairs_from_expr_1_to_expr_2', 'list_pitch_numbers_in_expr',
'list_unordered_named_pitch_pairs_in_expr', 'set_written_pitch_of_pitched_components_in_expr',
'sort_named_pitch_carriers_in_expr', 'transpose_named_pitch_by_numbered_interval_and_respell',
'transpose_pitch_carrier_by_interval', 'transpose_pitch_class_number_to_pitch_number_neighbor',
'transpose_pitch_expr_into_pitch_range', 'transpose_pitch_number_by_octave_transposition_mapping',
'yield_all_pitch_class_sets']
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Many of these subpackages implement opinionated collections of
compositional devices, certainly useful for some composers but by no means
considered core to Abjad's notational model. For example, Abjad's
\texttt{quantizationtools} provides a rhythmic quantizer inspired by Paul
Nauert's concept of \enquote{Q-grids}\cite{nauert1997timespan},
\texttt{rhythmtreetools} parses a Lisp-like \enquote{RTM-syntax} -- which
should be familiar to anyone working with OpenMusic\cite{assayag1999sw},
PWGL\cite{laurson2009qf, kuuskankare2004recent} or Bach\cite{agostini2013real},
-- into object-oriented rhythm-tree data structures, and the
\texttt{sievetools} subpackage models Iannis Xenakis' pitch
sieves\cite{xenakis1992formalized}. Still other subpackages implement more
\enquote{objective} functionality, such as \texttt{mathtools} or
\texttt{durationtools}. Many of the remaining subpackages collect together
related musical and typographic classes and functions, e.g.
\texttt{scoretools}, \texttt{spannertools}, \texttt{markuptools}, and
\texttt{indicatortools}. Others simply exist for \enquote{internal} use by
Abjad's developers, assisting in the development and maintenance of the system,
such as \texttt{abctools}, \texttt{developerscripttools},
\texttt{documentationtools} and \texttt{systemtools}.

The remaining names in Abjad's namespace represent its \enquote{top-level}
functions, including \texttt{attach()}, \texttt{detach()},
\texttt{inspect\_()}, \texttt{iterate()}, \texttt{mutate()}, \texttt{new()},
\texttt{override()}, \texttt{parse()}, \texttt{persist()}, \texttt{play()},
\texttt{select()}, \texttt{set\_()}, and -- most importantly --
\texttt{show()}. These functions provide a powerful set of tools for
interacting with Abjad's notational objects and factories, and will be
explained in detail as we encounter each of them.

For the sake of brevity, this document -- across each chapter -- will behave as
though the contents of Abjad's namespace has been imported into Python's global
namespace:

\begin{comment}
<abjad>
from abjad import *
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> from abjad import *
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\section{Representing objects}

In Python, everything is an object, even integers, boolean values and
functions. Because Python is also interpreted and can be used interactively,
those objects must be representable in an interpreter session, which is
necessarily textual. Objects' text, or \emph{string}, representations can take
a variety of forms, and those same objects may specify explicitly how they
should be represented textually, just as they may specify how they should
behave in relation to operations such as addition, multiplication, or
iteration.

Python classes often specify their behavior in terms of \emph{protocols}.
Protocols are established by convention rather than enforced at the system
level. This explanation takes place via \enquote{dunder} methods --
double-underscore methods -- such as \texttt{\_\_repr\_\_()} which provides an
object's \emph{interpreter representation} in cooperation with Python's
\texttt{repr()} function and \texttt{\_\_str\_\_()} which provides an object's
string representation in cooperation with Python's \texttt{str()}
function. By overriding these dunder methods, a class may specify its own
version of string or interpreter representation behavior.

For example, a simple \texttt{Foo} class, which overrides neither
\texttt{\_\_str\_\_()} nor \texttt{\_\_repr\_\_()} may be defined and
instantiated:

\begin{comment}
<abjad>
class Foo(object):
    pass

foo = Foo()
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> class Foo(object):
...     pass
...
>>> foo = Foo()
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent When printed to the terminal, cast as a string, and represented,
Python's default object representation is used, giving the module and name of
the class as well as its memory location. Note that when calling Python's
\texttt{print()} function on an object, that object is converted to a string
and then printed to the console, resulting in text without quotation marks:

\begin{comment}
<abjad>
print(foo)
repr(foo)
str(foo)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> print(foo)
<__main__.Foo object at 0x1046c0290>
\end{lstlisting}
\begin{lstlisting}
>>> repr(foo)
'<__main__.Foo object at 0x1046c0290>'
\end{lstlisting}
\begin{lstlisting}
>>> str(foo)
'<__main__.Foo object at 0x1046c0290>'
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Defining a new class, \texttt{Foo2}, which overrides both string and
interpreter representation provides customized output. Note that printing the
\texttt{Foo2} instance relies on its string representation, rather than its
interpreter representation, while simply referencing the instantiated
\texttt{Foo2} object uses its interpreter representation -- its \enquote{repr}:

\begin{comment}
<abjad>
class Foo2(object):
    def __repr__(self):
        return '<I am Foo2>'
    def __str__(self):
        return 'foofoo'

foo2 = Foo2()
foo2
print(foo2)
repr(foo2)
str(foo2)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> class Foo2(object):
...     def __repr__(self):
...         return '<I am Foo2>'
...     def __str__(self):
...         return 'foofoo'
...
>>> foo2 = Foo2()
>>> foo2
<I am Foo2>
\end{lstlisting}
\begin{lstlisting}
>>> print(foo2)
foofoo
\end{lstlisting}
\begin{lstlisting}
>>> repr(foo2)
'<I am Foo2>'
\end{lstlisting}
\begin{lstlisting}
>>> str(foo2)
'foofoo'
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Defining a third version of \texttt{Foo} with an overridden
\texttt{\_\_format\_\_()} method allows for creating alternate string
representations. By calling Python's built-in \texttt{format()} function on a
\texttt{Foo3} instance, either the normal string representation or a
\enquote{special} representation can be created. This formatting behavior can
also be extended to support an arbitrary number of format specifications:

\begin{comment}
<abjad>
class Foo3(object):
    def __format__(self, format_specification=''):
        if format_specification == 'special':
            return '~~~ special foo format ~~~~'
        return str(self)
    def __repr__(self):
        return '<I am Foo3>'
    def __str__(self):
        return 'foofoofoo'

foo3 = Foo3()
foo3
print(foo3)
repr(foo3)
str(foo3)
format(foo3)
format(foo3, 'special')
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> class Foo3(object):
...     def __format__(self, format_specification=''):
...         if format_specification == 'special':
...             return '~~~ special foo format ~~~~'
...         return str(self)
...     def __repr__(self):
...         return '<I am Foo3>'
...     def __str__(self):
...         return 'foofoofoo'
...
>>> foo3 = Foo3()
>>> foo3
<I am Foo3>
\end{lstlisting}
\begin{lstlisting}
>>> print(foo3)
foofoofoo
\end{lstlisting}
\begin{lstlisting}
>>> repr(foo3)
'<I am Foo3>'
\end{lstlisting}
\begin{lstlisting}
>>> str(foo3)
'foofoofoo'
\end{lstlisting}
\begin{lstlisting}
>>> format(foo3)
'foofoofoo'
\end{lstlisting}
\begin{lstlisting}
>>> format(foo3, 'special')
'~~~ special foo format ~~~~'
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Many Abjad objects have multiple possible string representations. For
example, a \texttt{Note} object can be represented by its normal interpreter
representation, as a LilyPond string, or by its \emph{storage format} -- a more
verbose, potentially multi-line string representation generally used when
persisting complex objects to disk.

\begin{comment}
<abjad>
note = Note(NamedPitch("g'"), Duration(3, 4))
note
print(repr(note))
print(note)
print(str(note))
print(format(note))
print(format(note, 'lilypond'))
print(format(note, 'storage'))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> note = Note(NamedPitch("g'"), Duration(3, 4))
>>> note
Note("g'2.")
\end{lstlisting}
\begin{lstlisting}
>>> print(repr(note))
Note("g'2.")
\end{lstlisting}
\begin{lstlisting}
>>> print(note)
g'2.
\end{lstlisting}
\begin{lstlisting}
>>> print(str(note))
g'2.
\end{lstlisting}
\begin{lstlisting}
>>> print(format(note))
g'2.
\end{lstlisting}
\begin{lstlisting}
>>> print(format(note, 'lilypond'))
g'2.
\end{lstlisting}
\begin{lstlisting}
>>> print(format(note, 'storage'))
scoretools.Note("g'2.")
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent For some Abjad classes -- especially those representing glyphs in
music notation -- their default string format is their LilyPond string
representation. Other classes -- especially Abjad's various highly-configurable
notation factory classes -- default their string format to their storage
format, allowing for complex but still human-readable interpreter output:

\begin{comment}
<abjad>
rhythm_maker = rhythmmakertools.TaleaRhythmMaker(
    talea=rhythmmakertools.Talea([1, 2, 3], 16),
    extra_counts_per_division=(1, 0, 2, 1, 0),
    output_masks=[
        rhythmmakertools.SustainMask([1], 3, 1, -1),
        rhythmmakertools.SilenceMask([-1]),
        ],
    tie_specifier=rhythmmakertools.TieSpecifier(
        tie_across_divisions=True,
        ),
    )
print(format(rhythm_maker))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> rhythm_maker = rhythmmakertools.TaleaRhythmMaker(
...     talea=rhythmmakertools.Talea([1, 2, 3], 16),
...     extra_counts_per_division=(1, 0, 2, 1, 0),
...     output_masks=[
...         rhythmmakertools.SustainMask([1], 3, 1, -1),
...         rhythmmakertools.SilenceMask([-1]),
...         ],
...     tie_specifier=rhythmmakertools.TieSpecifier(
...         tie_across_divisions=True,
...         ),
...     )
>>> print(format(rhythm_maker))
rhythmmakertools.TaleaRhythmMaker(
    talea=rhythmmakertools.Talea(
        counts=(1, 2, 3),
        denominator=16,
        ),
    extra_counts_per_division=(1, 0, 2, 1, 0),
    output_masks=rhythmmakertools.BooleanPatternInventory(
        (
            rhythmmakertools.SustainMask(
                indices=(1,),
                period=3,
                start=1,
                stop=-1,
                ),
            rhythmmakertools.SilenceMask(
                indices=(-1,),
                ),
            )
        ),
    tie_specifier=rhythmmakertools.TieSpecifier(
        tie_across_divisions=True,
        ),
    )
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Finally, in the spirit of Python's protocols and dunder conventions,
Abjad provides its own \emph{illustration protocol} and
\texttt{\_\_illustrate\_\_()} dunder method. This method works with Abjad's
top-level \texttt{show()} function to generate graphic realizations of
illustratable Python objects via LilyPond. Abjad's \texttt{show()} function
will be used throughout this document to create and display notation and
otherwise graphic representations:

\begin{comment}
<abjad>
show(note)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> show(note)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-5cfff2844553f774341de4a66c379061.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\section{Components}

\begin{comment}
-   Every component may be named.
-   components, leaves, containers (and contexts)
-   components are formattable and illustrable
-   components are mutable, while indicators are generally not
    -   likewise, durations and pitches are immutable

-   count-time components
    -   note, chord, rest, skip, container, tuplet, measure
-   non-count-time (contexts)
    -   voice, staff, staff group, score

-   leaves do not contain anything else
    -   chord do *not* contain notes
    -   chords and notes contain note heads
    -   chord and notes share a single stem
    -   this must be disambiguated from note columns

-   all containers derive their duration from their contents (with some
    exceptions, but even there a mismatch is an error)
-   written duration, prolated duration, pre-prolated duration, contents
    duration

-   One, and only one, parent per component. They *cannot* be in more than one
    container. This is both confusing, and liable to cause reference problems.
-   score hierarchy is not fixed: any node is the root, if it has no parent

-   contexts are assumed to last from the beginning to the end of the total
    timespan of the score, but in practice they may be intermittent
-   contexts may be named, allowing concatenation

-   Leaves reside at the "bottom" of the score hierarchy.

Work aspects of this into appropriate sections

-   inspect_()
-   not *inspect()*, as that would cause a name conflict with Python's inspect
    module
-   inspect(...).get_parentage()
-   inspect_(...).get_duration()
    -   in_seconds=True
-   inspect_(...).get_timespan()
    -   in_seconds=True
\end{comment}

Abjad models notated musical scores as a \emph{tree} consisting of
\emph{components}, \emph{indicators} and \emph{spanners}. All objects appearing
in a score fall into one of those three categories. The most important and most
complex of the three groups, components, make up the \emph{nodes} of the score
tree, treating the score as an acyclic directed rooted graph, or
\emph{arborescence}, rooted on a single component. All components inherit from
Abjad's \texttt{Component} class, which encapsulates logic crucial to
maintaining the correctness of the score tree, and affords behaviors common to
all component subclasses including illustration, formatting and naming. Abjad
divides score components into \emph{containers} -- those components which may
contain other other components, such as staves, voices, tuplets, measures and
so forth -- and \emph{leaves} -- those components which may contain no other
components, such as notes, chords and rests, as well as LilyPond's
multi-measure rests and non-printing typographic \emph{skips}. Additionally,
components can each be instantiated from a variety of input, from parsable
LilyPond syntax strings to parametric arguments -- both numeric and explicitly
object-modeled via pitch and duration objects. For example, we can instantiate
and illustrate a middle-C quarter note:

\begin{comment}
<abjad>
note = Note("c'4")
show(note)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> note = Note("c'4")
>>> show(note)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-c018a545d264ff34225e9a3a5babb6c1.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent a half-note rest:

\begin{comment}
<abjad>
rest = Rest((1, 2))
show(rest)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> rest = Rest((1, 2))
>>> show(rest)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-8144dc38435e18921a5d584ad635d2e3.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent and a D-minor chord:

\begin{comment}
<abjad>
chord = Chord(
    [NamedPitch("d'"), NamedPitch("f'"), NamedPitch("a'")],
    Duration(1, 4),
    )
show(chord)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> chord = Chord(
...     [NamedPitch("d'"), NamedPitch("f'"), NamedPitch("a'")],
...     Duration(1, 4),
...     )
>>> show(chord)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-fef850f162448b1e8d3c6be53e362436.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Each of the above three leaf instantiations demonstrates a different
means of creating score objects, none of which is unique to the particular
class they have been demonstrated with here. The \texttt{Note} instantiation
demonstrates creating a score object via LilyPond syntax, the rest
instantiation demonstrates creating a score object from
sequences of integers -- in this case the pair (1, 2), representing the
duration of a half-note -- and the chord instantiation demonstrates using
explicit \texttt{NamedPitch} and \texttt{Duration} objects. The latter two
instantiation techniques afford parametric approaches, while the LilyPond
syntax allows for a great degree of expressivity as score components can be
created with articulations, dynamics and other indicators already attached:

\begin{comment}
<abjad>
fancy_chord = Chord(r"<g' bf'? d''>4. -\accent -\staccato ^\markup{ \italic gently }")
show(fancy_chord)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> fancy_chord = Chord(r"<g' bf'? d''>4. -\accent -\staccato ^\markup{ \italic gently }")
>>> show(fancy_chord)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-ffbf3288650db529c52c1e9ac804f9f0.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\subsection{Containers}
\label{ssec:containers}

Abjad's container classes -- measures, tuplets, voice, staves, staff groups,
scores and so forth -- implement Python's \emph{mutable sequence protocol},
allowing them to be used transparently as though they were lists.

Components can be appended, extended, or inserted into a container, and
container can be instantiated with lists of components to be contained as one
of their arguments. Note above that the LilyPond output shows a \sfrac{4}{4}
time signature even though none of the created leaves takes up an whole note's
duration. LilyPond simply treats all music as \sfrac{4}{4} unless explicitly
instructed otherwise. We can make the \sfrac{4}{4} time signature explicit by
instantiating a \sfrac{4}{4} measure to contain the previously-created three
leaf instances:

\begin{comment}
<abjad>
measure = Measure((4, 4), [note, rest, chord])
show(measure)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> measure = Measure((4, 4), [note, rest, chord])
>>> show(measure)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-cad7b59ce37e423c6cdc4729377818c7.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Containers can also be indexed into, measured for length and iterated
over. For example, the second component contained by the measure can be
retrieved by subscripting the measure with the index 1:

\begin{comment}
<abjad>
measure[1]
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> measure[1]
Rest('r2')
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent That second component -- the half-note rest -- can be replaced by
another container, a triplet:

\begin{comment}
<abjad>
outer_tuplet = Tuplet((2, 3), "a'4 b4 cs'4")
measure[1] = outer_tuplet
show(measure)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> outer_tuplet = Tuplet((2, 3), "a'4 b4 cs'4")
>>> measure[1] = outer_tuplet
>>> show(measure)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-f9a8a92bd9dbe5f480a4003ade9c81aa.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Furthermore, the last two leaves in the triplet can be replaced by a
quintuplet using Python's \emph{slice assignment} syntax. In the following
code, the text \texttt{outer\_tuplet[1:]} references the selection of
components in the original triplet starting from the second component and going
\enquote{to the end} -- effectively the second and third item, as there are
only three. That selection is then replaced by a list containing a quintuplet,
substituting the contents of one sequence of components for the contents of
another.

\begin{comment}
<abjad>
inner_tuplet = Tuplet((4, 5), "b'8 a'8. g'16 f'32 e'8..")
outer_tuplet[1:] = [inner_tuplet]
show(measure)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> inner_tuplet = Tuplet((4, 5), "b'8 a'8. g'16 f'32 e'8..")
>>> outer_tuplet[1:] = [inner_tuplet]
>>> show(measure)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-b783a8dad0c3003152ef1b148bc60ca8.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent The measure can be inspected for its length by using Python's
built-in \texttt{len()} function. Note that this returns the number of
components \emph{immediately} contained by the measure -- 3 --, but not the
total number of components, total number of leaves or total duration. The
latter queries can be satisfied by other means.

\begin{comment}
<abjad>
len(measure)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> len(measure)
3
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Iterating over the contents of the \sfrac{4}{4} measure yields only
the top-most components in that container -- its immediate children:

\begin{comment}
<abjad>
for component in measure:
    component

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> for component in measure:
...     component
...
Note("c'4")
Tuplet(Multiplier(2, 3), "a'4 { 4/5 b'8 a'8. g'16 f'32 e'8.. }")
Chord("<d' f' a'>4")
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent To retrieve all of the leaves of a container, recursion must be used,
as any container may contain other containers, and those in turn still more
containers. To mitigate this complexity, every container provides a
\texttt{select\_leaves()} method, which returns a selection of the bottom-most
leaf instances in the subtree rooted at that container:

\begin{comment}
<abjad>
for leaf in measure.select_leaves():
    leaf

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> for leaf in measure.select_leaves():
...     leaf
...
Note("c'4")
Note("a'4")
Note("b'8")
Note("a'8.")
Note("g'16")
Note("f'32")
Note("e'8..")
Chord("<d' f' a'>4")
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Note that Abjad's \texttt{Chord} class aggregates multiple \emph{note
heads} rather than notes. Likewise Abjad's \texttt{Note} class aggregates a
single note head. While chords implement containment in terms of note heads --
delegating to a dedicated note head inventory -- they are not themselves
"containers" in the same sense that a voice, measure or tuplet are containers.
It is important here to differentiate between the concept of a \enquote{chord}
as a single duration paired with a collection of pitches and a \enquote{chord}
as the sounding sonority at some given point in a piece spread over some number
of voices. Abjad always makes use of the former rather than the latter.

\begin{comment}
<abjad>
note_head_inventory = chord.note_heads
for note_head in note_head_inventory:
    note_head

chord.note_heads.append(NamedPitch("c''"))
show(chord)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> note_head_inventory = chord.note_heads
>>> for note_head in note_head_inventory:
...     note_head
...
NoteHead("d'")
NoteHead("f'")
NoteHead("a'")
\end{lstlisting}
\begin{lstlisting}
>>> chord.note_heads.append(NamedPitch("c''"))
>>> show(chord)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-0419b405f12cba5bff2e20c17c72e860.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\subsection{Parentage}
\label{ssec:parentage}

The container that contains a given component is called its \emph{parent}, and
the components contained in a container are known as that container's
\emph{children}. Every component may have one and only one parent container,
although a component may also have no parent -- a null parent reference. Any
component whose parent is null is necessarily the root of its own score tree.
Furthermore, no component may appear in its own \emph{proper parentage} -- the
sequence of components comprising the unique path from a given component to the
root of its tree, excepting the component itself -- as this would induce
reference cycles within the score tree.\footnote{Disambiguate proper and
improper parentage in terms of set-theory.}

Abjad object-models the concept of parentage explicitly as a \texttt{Parentage}
\emph{selection} class, accessible via the \emph{inspector} which exposes a
given component's \emph{inspection interface}: a collection of methods for
accessing information about that component, many of which depend on that
component's position within the score hierarchy, including the component's
parentage or duration. An inspector can be instantiated by calling Abjad's
top-level \texttt{inspect\_()} function on a component.\footnote{Abjad uses
\texttt{inspect\_()} rather than \texttt{inspect()} as Python already provides
an \texttt{inspect} module for object introspection, and it is considered bad
practice to overwrite names of functions, classes or modules found in the
standard library such as \texttt{set} or \texttt{object}. When a name conflict
would occur, projects traditionally append an underscore to the name they wish
to use.} Consider the parentage for the first eighth note of the inner tuplet.
Its parentage -- \emph{improper} by default -- includes itself, its immediate
quintuplet parent, its triplet grandparent and the \sfrac{4}{4} measure as its
great-grandparent:\footnote{The component summary strings in the interpreter
representations of the components in the parentage are \emph{note} valid
LilyPond syntax, but simply a concise LilyPond-like syntax.}

\begin{comment}
<abjad>
inner_b_eighth = measure[1][1][0]
inspector = inspect_(inner_b_eighth)
parentage = inspector.get_parentage()
parentage.parent
for component in parentage:
    component

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> inner_b_eighth = measure[1][1][0]
>>> inspector = inspect_(inner_b_eighth)
>>> parentage = inspector.get_parentage()
>>> parentage.parent
Tuplet(Multiplier(4, 5), "b'8 a'8. g'16 f'32 e'8..")
\end{lstlisting}
\begin{lstlisting}
>>> for component in parentage:
...     component
...
Note("b'8")
Tuplet(Multiplier(4, 5), "b'8 a'8. g'16 f'32 e'8..")
Tuplet(Multiplier(2, 3), "a'4 { 4/5 b'8 a'8. g'16 f'32 e'8.. }")
Measure((4, 4), "c'4 { 2/3 a'4 { 4/5 b'8 a'8. g'16 f'32 e'8.. } } <d' f' a' c''>4")
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent By default, every component's parent is null, represented in Python
by Python's \texttt{None} object:

\begin{comment}
<abjad>
whole_note = Note("c'1")
inspector = inspect_(whole_note)
inspector.get_parentage().parent is None
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> whole_note = Note("c'1")
>>> inspector = inspect_(whole_note)
>>> inspector.get_parentage().parent is None
True
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Inserting the above whole note into a container sets the whole note's
parent to that container. Additionally, the container is now aware that it
contains the whole note, demonstrating the bi-directional references inherent
to Abjad's score tree model:

\begin{comment}
<abjad>
container_one = Container()
container_one.append(whole_note)
inspector.get_parentage().parent is container_one
whole_note in container_one
print(format(container_one))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> container_one = Container()
>>> container_one.append(whole_note)
>>> inspector.get_parentage().parent is container_one
True
\end{lstlisting}
\begin{lstlisting}
>>> whole_note in container_one
True
\end{lstlisting}
\begin{lstlisting}
>>> print(format(container_one))
{
    c'1
}
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Inserting the same whole note into a different container removes it
from the first, demonstrating that components can only exist in one container
at a time:

\begin{comment}
<abjad>
container_two = Container()
container_two.append(whole_note)
inspector.get_parentage().parent is container_two
whole_note in container_two
whole_note in container_one
print(format(container_two))
print(format(container_one))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> container_two = Container()
>>> container_two.append(whole_note)
>>> inspector.get_parentage().parent is container_two
True
\end{lstlisting}
\begin{lstlisting}
>>> whole_note in container_two
True
\end{lstlisting}
\begin{lstlisting}
>>> whole_note in container_one
False
\end{lstlisting}
\begin{lstlisting}
>>> print(format(container_two))
{
    c'1
}
\end{lstlisting}
\begin{lstlisting}
>>> print(format(container_one))
{
}
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Likewise, while the first container can be inserted into the second,
the second container cannot be inserted back into the first. Such an
arrangement would cause the second container to become its own grandparent, and
therefore generates an error:

\begin{comment}
<abjad>[allow_exceptions]
container_two.append(container_one)
container_one.append(container_two)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> container_two.append(container_one)
>>> container_one.append(container_two)
Traceback (most recent call last):
  File "<abjadbook>", line 1, in <module>
  File "/Users/josiah/Documents/Development/abjad/abjad/tools/scoretools/Container.py", line 902, in append
    self.__setitem__(slice(len(self), len(self)), [component])
  File "/Users/josiah/Documents/Development/abjad/abjad/tools/scoretools/Container.py", line 130, in __setitem__
    return self._set_item(i, expr)
  File "/Users/josiah/Documents/Development/abjad/abjad/tools/scoretools/Container.py", line 421, in _set_item
    raise ParentageError('Attempted to induce cycles.')
ParentageError: Attempted to induce cycles.
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Why should we be concerned with reference cycles? When we create
score by hand, notes -- no matter how we may have arrived at them or conceived
of them creatively -- are ultimately simply black marks on a page. When working
with computer, we can choose how to model musical objects. Again, a
\enquote{note} could simply exist as an amalgam of dots and lines in a
vector-graphics program, in which case it may not be possible to know where or
even what that note or any other note \emph{is} except in terms of dots and
lines -- the affordances provided by that vector-graphics editor. In that case,
there is no semantic model of music, only a typographic model devoid of
explicit musical relationships. Alternatively, we can model explicitly, in
which case notes exist as "objects" in a rich network of references. In this
latter case, certain conditions must be maintained to protect the integrity of
the reference network. Depending on the implementation, a note likely cannot
be in two places at once. That is the certainly the case in Abjad's model of
musical notation: notes can only have one parent, and cannot exist in more than
one parent. Note that these restrictions mainly derive from the fact that
notes, like other scores components, are both \emph{mutable} -- that is,
changeable after they have been instantiated, and therefore \emph{stateful} --
and possess many references to objects \enquote{outside} of themselves. In
contrast, Abjad's pitch and duration classes have no state -- they are
\emph{immutable} -- and reference no other objects. They can therefore appear
in many places within the same score. Arbitrarily many score components can
reference the same duration in memory, much as arbitrarily many objects can
reference the same integer. Such an arrangement is often referred to as a
\emph{flyweight}\cite{gamma1994design}.

\subsection{Durations}

Every Abjad score component may be expressed in terms of its duration, as well
as its start offset relative to the score origin and, by extension, its
timespan -- the span of time bounded by their start offset and their stop
offset. Abjad models all such duration objects as \emph{rationals}: ratios of
real numbers, e.g. \sfrac{1}{2}, \sfrac{7}{23} or \sfrac{16}{1}. This concern
arises from the realization that all durations and offsets expressible in
Western common practice notation are rational, rather than floating-point or
any other representation. Necessarily, Abjad's \texttt{Duration},
\texttt{Offset} and \texttt{Multiplier} classes all derive from Python's
\texttt{fractions.Fraction} class. Both \texttt{Offset} and \texttt{Multiplier}
are little more than aliases to Abjad's \texttt{Duration} class. However, their
use throughout Abjad's code-base, and those projects heavily dependent upon
Abjad, such as Consort, greatly clarify compositional intent and increase the
source's legibility.

Abjad's \texttt{Duration} class extends Python's \texttt{Fraction} class with a
number of new initialization patterns and a variety of notation-specific
properties. For example, a \sfrac{7}{16} duration can be instantiated from a
numerator/denominator pair, or from a LilyPond syntax duration string:

\begin{comment}
<abjad>
Duration(7, 16)
Duration.from_lilypond_duration_string('4..')
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> Duration(7, 16)
Duration(7, 16)
\end{lstlisting}
\begin{lstlisting}
>>> Duration.from_lilypond_duration_string('4..')
Duration(7, 16)
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Duration objects can provide information about how they should be
interpreted notationally, including how many dots or flags they would have if
used to instantiate a leaf. A \sfrac{7}{16} duration, without resorting to
tuplets or ties, might be represented in notation by a double-dotted quarter
note, thus giving a dot count of 2 and a flag count of 0:

\begin{comment}
<abjad>
Duration(7, 16).dot_count
Duration(7, 16).flag_count
Duration(7, 16).lilypond_duration_string
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> Duration(7, 16).dot_count
2
\end{lstlisting}
\begin{lstlisting}
>>> Duration(7, 16).flag_count
0
\end{lstlisting}
\begin{lstlisting}
>>> Duration(7, 16).lilypond_duration_string
'4..'
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent As mentioned in \autoref{ssec:parentage}, duration are immutable.
Like other immutable objects in Python -- e.g. integers and string --, they
raise errors when anything attempts to alter them in anyway:

\begin{comment}
<abjad>[allow_exceptions]
string = 'abcdefghi'
string[1:-1] = 'xyz'
Duration(3, 4).numerator = 7
Duration(1, 2).nonexistant_property = 'This will never work'
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> string = 'abcdefghi'
>>> string[1:-1] = 'xyz'
Traceback (most recent call last):
  File "<abjadbook>", line 1, in <module>
TypeError: 'str' object does not support item assignment
\end{lstlisting}
\begin{lstlisting}
>>> Duration(3, 4).numerator = 7
Traceback (most recent call last):
  File "<abjadbook>", line 1, in <module>
AttributeError: can't set attribute
\end{lstlisting}
\begin{lstlisting}
>>> Duration(1, 2).nonexistant_property = 'This will never work'
Traceback (most recent call last):
  File "<abjadbook>", line 1, in <module>
AttributeError: 'Duration' object has no attribute 'nonexistant_property'
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Additionally, some mathematical operations between offsets and
durations provide results typed in a musically-sensible fashion. For example,
the difference between two offsets returns a duration, while a duration added
to an offset returns another offset:

\begin{comment}
<abjad>
offset_one = Offset(1, 2)
offset_two = Offset(7, 4)
offset_two - offset_one
offset_two + Duration(3, 8)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> offset_one = Offset(1, 2)
>>> offset_two = Offset(7, 4)
>>> offset_two - offset_one
Duration(5, 4)
\end{lstlisting}
\begin{lstlisting}
>>> offset_two + Duration(3, 8)
Offset(17, 8)
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent The duration of each leaf derives from the product of its
\emph{written duration} -- a duration representing the actual glyphs used in
the score as represented by some combination of note heads, stems, beams and
dots -- and their \emph{prolation} -- the cumulative product of all of the
duration multipliers of the containers in a component's proper parentage.

Consider again the measure created earlier in \autoref{ssec:containers}:

\begin{comment}
<abjad>
show(measure)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> show(measure)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-12ab406580e016c3647c6966e70bbc2f.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent The B eighth-note starting the quintuplet is nested within two
different tuplets with different multipliers. While the note's parentage object
can calculate its prolation, we can also calculate the prolation by hand in
order to demonstrate the technique:

\begin{comment}
<abjad>
parentage = inspect_(inner_b_eighth).get_parentage()
parentage.prolation
by_hand_prolation = 1
for parent in parentage[1:]:
    if isinstance(parent, Tuplet):
        by_hand_prolation = by_hand_prolation * parent.multiplier

by_hand_prolation
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> parentage = inspect_(inner_b_eighth).get_parentage()
>>> parentage.prolation
Multiplier(8, 15)
\end{lstlisting}
\begin{lstlisting}
>>> by_hand_prolation = 1
>>> for parent in parentage[1:]:
...     if isinstance(parent, Tuplet):
...         by_hand_prolation = by_hand_prolation * parent.multiplier
...
>>> by_hand_prolation
Multiplier(8, 15)
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent By multiplying each leaf's written duration by its prolation, we can
determine that leaf's actual, or prolated, duration. Note too that this
conforms to the results of the inspector's \texttt{get\_duration()} method:

\begin{comment}
<abjad>
for leaf in measure.select_leaves():
    inspector = inspect_(leaf)
    written_duration = leaf.written_duration
    prolation = inspector.get_parentage().prolation
    actual_duration = inspector.get_duration()
    string = '{!r}: {!s} * {!s} = {!s}'
    string = string.format(leaf, written_duration, prolation, actual_duration)
    print(string)

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> for leaf in measure.select_leaves():
...     inspector = inspect_(leaf)
...     written_duration = leaf.written_duration
...     prolation = inspector.get_parentage().prolation
...     actual_duration = inspector.get_duration()
...     string = '{!r}: {!s} * {!s} = {!s}'
...     string = string.format(leaf, written_duration, prolation, actual_duration)
...     print(string)
...
Note("c'4"): 1/4 * 1 = 1/4
Note("a'4"): 1/4 * 2/3 = 1/6
Note("b'8"): 1/8 * 8/15 = 1/15
Note("a'8."): 3/16 * 8/15 = 1/10
Note("g'16"): 1/16 * 8/15 = 1/30
Note("f'32"): 1/32 * 8/15 = 1/60
Note("e'8.."): 7/32 * 8/15 = 7/60
Chord("<d' f' a' c''>4"): 1/4 * 1 = 1/4
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Written durations must be \emph{assignable}. Assignability describes
the set of durations describable in Western common practice notation solely
through combining a single note head, its flags and dots, without recourse to
ties or tuplets. Any rational duration $\sfrac{n}{d}$ is considered assignable
when and only when it adheres to the form

\begin{equation}
{ 2^k * (2^u - j) \over 2^v }
\end{equation}

\noindent where $u$, $v$ and $k$ are nonnegative integers, $j \leq u$ and $j$
is either 1 or 0. Assignability guarantees that a duration's denominator is
always a positive power-of-two integer, such as 1, 2, 4, 8, 16 and so forth,
and therefore precludes durations such as $\sfrac{1}{3}$ or $\sfrac{2}{5}$.
Likewise, assignability permits numerators such as 1, 2, 3, 4, 6, 7, 8, 12, 14
and 15 but forbids 5, 9, 10, 13 and 17, as they imply ties. More elegantly, any
integer can be considered if its binary representation does not contain the
substring \enquote{01}:

\begin{comment}
<abjad>
for i in range(17):
    binary_string = mathtools.integer_to_binary_string(i)
    is_assignable = mathtools.is_assignable_integer(i)
    string = '{}: {} [{}]'.format(i, binary_string, is_assignable)
    print(string)

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> for i in range(17):
...     binary_string = mathtools.integer_to_binary_string(i)
...     is_assignable = mathtools.is_assignable_integer(i)
...     string = '{}: {} [{}]'.format(i, binary_string, is_assignable)
...     print(string)
...
0: 0 [False]
1: 1 [True]
2: 10 [True]
3: 11 [True]
4: 100 [True]
5: 101 [False]
6: 110 [True]
7: 111 [True]
8: 1000 [True]
9: 1001 [False]
10: 1010 [False]
11: 1011 [False]
12: 1100 [True]
13: 1101 [False]
14: 1110 [True]
15: 1111 [True]
16: 10000 [True]
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent The duration of each container then derives from the product of its
prolation and its *contents duration* -- the sum of the durations of its
children. Ultimately, all scores derive their durations from the durations of
their leaves, prolated as necessary by any tuplets. As components enter and
leave a container, the duration of that container and the offsets of components
following the inserted or deleted component adjust dynamically to reflect the
altered structure:

\begin{comment}
<abjad>
staff = Staff("c'4 d'4 e'4 f'4")
show(staff)
inspect_(staff).get_duration()
for leaf in staff:
    offset = inspect_(leaf).get_timespan().start_offset
    print(offset, leaf)

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> staff = Staff("c'4 d'4 e'4 f'4")
>>> show(staff)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-3947a1689e36c26dfc1db5d199985257.pdf}
\begin{lstlisting}
>>> inspect_(staff).get_duration()
Duration(1, 1)
\end{lstlisting}
\begin{lstlisting}
>>> for leaf in staff:
...     offset = inspect_(leaf).get_timespan().start_offset
...     print(offset, leaf)
...
(Offset(0, 1), Note("c'4"))
(Offset(1, 4), Note("d'4"))
(Offset(1, 2), Note("e'4"))
(Offset(3, 4), Note("f'4"))
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent After inserting an additional four quarter-notes into the staff, the
staff reports its duration as doubled, and all of the leaves -- both new and
old -- report their expected start offsets:

\begin{comment}
<abjad>
staff[2:2] = "f''4 e''4 d''4 c''4"
show(staff)
inspect_(staff).get_duration()
for leaf in staff:
    offset = inspect_(leaf).get_timespan().start_offset
    print(offset, leaf)

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> staff[2:2] = "f''4 e''4 d''4 c''4"
>>> show(staff)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-378ec9dd2a14b504935cd7108d9b08b9.pdf}
\begin{lstlisting}
>>> inspect_(staff).get_duration()
Duration(2, 1)
\end{lstlisting}
\begin{lstlisting}
>>> for leaf in staff:
...     offset = inspect_(leaf).get_timespan().start_offset
...     print(offset, leaf)
...
(Offset(0, 1), Note("c'4"))
(Offset(1, 4), Note("d'4"))
(Offset(1, 2), Note("f''4"))
(Offset(3, 4), Note("e''4"))
(Offset(1, 1), Note("d''4"))
(Offset(5, 4), Note("c''4"))
(Offset(3, 2), Note("e'4"))
(Offset(7, 4), Note("f'4"))
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Likewise, removing the middle two of the previously inserted leaves
results in the staff reporting a decreased duration, and all leaves updating
their offsets to reflect the deletion:

\begin{comment}
<abjad>
staff[3:5] = []
show(staff)
inspect_(staff).get_duration()
for leaf in staff:
    offset = inspect_(leaf).get_timespan().start_offset
    print(offset, leaf)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> staff[3:5] = []
>>> show(staff)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-64d327db461ddb041d653c1bd1d31ee6.pdf}
\begin{lstlisting}
>>> inspect_(staff).get_duration()
Duration(3, 2)
\end{lstlisting}
\begin{lstlisting}
>>> for leaf in staff:
...     offset = inspect_(leaf).get_timespan().start_offset
...     print(offset, leaf)
(Offset(0, 1), Note("c'4"))
(Offset(1, 4), Note("d'4"))
(Offset(1, 2), Note("f''4"))
(Offset(3, 4), Note("c''4"))
(Offset(1, 1), Note("e'4"))
(Offset(5, 4), Note("f'4"))
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Finally, multiplier objects may be attached to leaves to multiply
their duration. When attached to multi-measure rests, not only does the overall
duration of the leaf change, but LilyPond is able to generate typography
representing multiple bars of tacet music compressed together:

\begin{comment}
<abjad>
multimeasure_rest = scoretools.MultimeasureRest(1)
inspect_(multimeasure_rest).get_duration()
show(multimeasure_rest)
attach(Multiplier(4), multimeasure_rest)
inspect_(multimeasure_rest).get_duration()
show(multimeasure_rest)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> multimeasure_rest = scoretools.MultimeasureRest(1)
>>> inspect_(multimeasure_rest).get_duration()
Duration(1, 1)
\end{lstlisting}
\begin{lstlisting}
>>> show(multimeasure_rest)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-099f7141431afa5ae3a046415764f35b.pdf}
\begin{lstlisting}
>>> attach(Multiplier(4), multimeasure_rest)
>>> inspect_(multimeasure_rest).get_duration()
Duration(4, 1)
\end{lstlisting}
\begin{lstlisting}
>>> show(multimeasure_rest)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-a8fdc5cae1a0a9fb72680a5d18862c4e.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\subsection{Named components}

Abjad's scores components may be given unique names via their \texttt{name}
property. Any named component found in the subtree of a given container may be
accessed by subscripting the container with its name, regardless of its depth
in that container.

Consider the following score, containing a piano staff grouping two staves,
each with one voice:

\begin{comment}
<abjad>
voice_1 = Voice(name='Voice 1')
voice_1.append(Measure((3, 4), "d'4.. b'16 af'4"))
voice_1.append(Measure((5, 4), "af'4. g'8 c''8 b'4. b'8. d''16"))
upper_staff = Staff(
    [voice_1],
    name='Upper Staff',
    )
voice_2 = Voice(name='Voice 2')
voice_2.append(Measure((3, 4), "r8 c'8 r8 d8 r8 e8"))
voice_2.append(Measure((5, 4), r"r4 \times 2/3 { g4 fs4 e8 cs8 } r4. fs8"))
lower_staff = Staff(
    [voice_2],
    name='Lower Staff',
    )
staff_group = StaffGroup(
    [upper_staff, lower_staff],
    context_name='PianoStaff',
    name='Both Staves',
    )
score = Score([staff_group])
show(score)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> voice_1 = Voice(name='Voice 1')
>>> voice_1.append(Measure((3, 4), "d'4.. b'16 af'4"))
>>> voice_1.append(Measure((5, 4), "af'4. g'8 c''8 b'4. b'8. d''16"))
>>> upper_staff = Staff(
...     [voice_1],
...     name='Upper Staff',
...     )
>>> voice_2 = Voice(name='Voice 2')
>>> voice_2.append(Measure((3, 4), "r8 c'8 r8 d8 r8 e8"))
>>> voice_2.append(Measure((5, 4), r"r4 \times 2/3 { g4 fs4 e8 cs8 } r4. fs8"))
>>> lower_staff = Staff(
...     [voice_2],
...     name='Lower Staff',
...     )
>>> staff_group = StaffGroup(
...     [upper_staff, lower_staff],
...     context_name='PianoStaff',
...     name='Both Staves',
...     )
>>> score = Score([staff_group])
>>> show(score)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-d40e0782ac1fdd6bf41bff264524b22b.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Printing the score as a LilyPond syntax string clearly shows the
nested quality of the score hierarchy. Additionally, the previously provided
names of some of the containers -- e.g. \enquote{Voice 1} and \enquote{Lower
Staff} -- also appear in the LilyPond output:

\begin{comment}
<abjad>
print(format(score))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> print(format(score))
\new Score <<
    \context PianoStaff = "Both Staves" <<
        \context Staff = "Upper Staff" {
            \context Voice = "Voice 1" {
                {
                    \time 3/4
                    d'4..
                    b'16
                    af'4
                }
                {
                    \time 5/4
                    af'4.
                    g'8
                    c''8
                    b'4.
                    b'8.
                    d''16
                }
            }
        }
        \context Staff = "Lower Staff" {
            \context Voice = "Voice 2" {
                {
                    \time 3/4
                    r8
                    c'8
                    r8
                    d8
                    r8
                    e8
                }
                {
                    \time 5/4
                    r4
                    \times 2/3 {
                        g4
                        fs4
                        e8
                        cs8
                    }
                    r4.
                    fs8
                }
            }
        }
    >>
>>
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Any of the named components within the score hierarchy can be
retrieved by subscripting any container in their proper parentage with their
name. For example, the voice container named \enquote{Voice 1} can be retrieved
by subscripting the score object with its name, even though it is not
immediately contained by the score but is in fact a \enquote{great-grandchild}
of the score:

\begin{comment}
<abjad>
score['Voice 1']
score['Voice 1'] is voice_1
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> score['Voice 1']
<Voice-"Voice 1"{2}>
\end{lstlisting}
\begin{lstlisting}
>>> score['Voice 1'] is voice_1
True
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Note that the staff group definition above received both a
\texttt{name} and a \texttt{context\_name} keyword argument. While the various
voices and staves in the above score all appear in the LilyPond syntax output
as \texttt{\textbackslash{}context Staff = "Upper Staff"} or
\texttt{\textbackslash{}context Voice = "Voice 2"}, the staff group appears
instead as \texttt{\textbackslash{}context PianoStaff = "Both Staves"}. Its
\enquote{context name} has been substituted for where \texttt{StaffGroup} would
normally appear, allowing Abjad to specify a different LilyPond \emph{context}
for the music it contains.

Some Abjad container classes correspond to LilyPond's notion of
\emph{contexts}. These include voices, staves, staff groups and scores, but not
measures, tuplets or \enquote{bare} containers. LilyPond uses contexts during
typesetting to maintain various kinds of musical information hierarchically.
For example, LilyPond's \texttt{Staff} context maintains information about the
accidentals that have appeared so far in any voice contained by that staff and
the staff's current clef -- which are necessarily local to a single staff --,
while the \texttt{Score} context maintains more global information, such as the
current tempo and measure number. LilyPond also allows for the definition of
new contexts, and provides a number of specially-defined contexts, e.g.
\texttt{ChoirStaff}, \texttt{TabVoice} and \texttt{FiguredBass}. While
LilyPond's contexts may be either named or anonymous, named contexts allow
LilyPond to stitch together different sections of music into a single
continuous score, allowing different segments of a work to be defined in
different files and then concatenated together.

\section{Indicators}

Abjad's indicators include any object attached to a single score component,
such as articulations, textual markup, clefs, tempo or time signature
indications. Unlike score components and spanners, indicators do not share a
common base class. Instead, they are unified by the means by which they have
been attached to components: Abjad's top-level \texttt{attach()} function.
Indicators are generally immutable, like integers and durations. Regardless, in
being attached to a score component they do not receive a reference to that
component, allowing the same indicator to be attached to many components. Abjad
binds the indicator to the component via an \texttt{IndicatorExpression}
object, which holds the necessary references to both the indicator and the
component along with other important information about the behavior of the
attachment.

Consider a simple four note staff. A single accent articulation can be attached
to each note in the staff via \texttt{attach()}:

\begin{comment}
<abjad>
staff = Staff("c'4 d'4 e'4 f'4")
accent = Articulation('accent')
for note in staff:
    attach(accent, note)

show(staff)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> staff = Staff("c'4 d'4 e'4 f'4")
>>> accent = Articulation('accent')
>>> for note in staff:
...     attach(accent, note)
...
>>> show(staff)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-28933ab8c116701be372aeadc38a025e.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Once attached, indicators can be removed via the top-level
\texttt{detach()} function. For example, the attached accents can be detached
from the last three leaves of the above staff via the \texttt{detach()}
function:

\begin{comment}
<abjad>
for note in staff[1:]:
    detach(accent, note)

show(staff)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> for note in staff[1:]:
...     detach(accent, note)
...
(Articulation('accent'),)
(Articulation('accent'),)
(Articulation('accent'),)
\end{lstlisting}
\begin{lstlisting}
>>> show(staff)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-712238b1f24829bf1654cbf459e3fb22.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent At this point, only the first note in the staff has anything
attached. As with durations and parentage, we can use the component inspector
to verify that this is true by testing each note for the existence of an
indicator of the class \texttt{Articulation}:

\begin{comment}
<abjad>
for note in staff:
    has_articulation = inspect_(note).has_indicator(Articulation)
    print(note, has_articulation)

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> for note in staff:
...     has_articulation = inspect_(note).has_indicator(Articulation)
...     print(note, has_articulation)
...
(Note("c'4"), True)
(Note("d'4"), False)
(Note("e'4"), False)
(Note("f'4"), False)
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Likewise, we can use the component inspector to retrieve the attached
articulation. The inspector provides two methods for retrieving indicators
attached to a single component: \texttt{get\_indicator()} and
\texttt{get\_indicators()}. The latter returns a tuple of zero or more
indicators matching any supplied class prototype, while the former returns only
one and raises an error if more or less than one indicator matching the
supplied class prototype is attached. In the case of retrieving any attached
articulations, both methods work perfectly.

\begin{comment}
<abjad>[allow_exceptions]
inspect_(staff[0]).get_indicators(Articulation)
inspect_(staff[0]).get_indicator(Articulation)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> inspect_(staff[0]).get_indicators(Articulation)
(Articulation('accent'),)
\end{lstlisting}
\begin{lstlisting}
>>> inspect_(staff[0]).get_indicator(Articulation)
Articulation('accent')
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Consider again the two-staff score created earlier:

\begin{comment}
<abjad>
show(score)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> show(score)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-d40e0782ac1fdd6bf41bff264524b22b.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent A variety of indicators can be attached to the leaves in this score
to present a more convincing musical result, including clefs, dynamics, tempi
and articulations. Note that indicators can be attached to both leaf and
container components:

\begin{comment}
<abjad>
attach(Clef('treble'), score['Upper Staff'])
attach(Clef('bass'), score['Lower Staff'])
lower_leaves = score['Lower Staff'].select_leaves()
for i in [1, 3, 5, 12]:
    attach(Articulation('staccato'), lower_leaves[i])

attach(Tempo((1, 4), 88), score['Voice 1'][0][0])
attach(Dynamic('p'), score['Voice 1'][0][0])
attach(Dynamic('f'), score['Voice 1'][1][0])
attach(Dynamic('ppp'), score['Voice 1'][1][-1])
show(score)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> attach(Clef('treble'), score['Upper Staff'])
>>> attach(Clef('bass'), score['Lower Staff'])
>>> lower_leaves = score['Lower Staff'].select_leaves()
>>> for i in [1, 3, 5, 12]:
...     attach(Articulation('staccato'), lower_leaves[i])
...
>>> attach(Tempo((1, 4), 88), score['Voice 1'][0][0])
>>> attach(Dynamic('p'), score['Voice 1'][0][0])
>>> attach(Dynamic('f'), score['Voice 1'][1][0])
>>> attach(Dynamic('ppp'), score['Voice 1'][1][-1])
>>> show(score)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-c21a86acc7f03aba66f02ef8ad6b14a5.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\subsection{Scope}

Abjad models how the influence of certain types of indicators persists across
components subsequent to the component they attach to via the concept of
\emph{scope}. Indicator scoping describes how, for example, all components in a
score are governed by one tempo from the moment that tempo appears until the
moment a different appears. Likewise, scoping describes how all leaves in a
staff are understood to be governed by the staff's clef up until the point that
that clef changes. Different indicators govern different scopes by default. As
just described, tempo indications govern the score context, while clef, key
signature and dynamics govern the staff context. An indicator governing some
component is known as that component's \emph{effective} indicator. As with
non-scoped indicators, the component inspector can be used to examine if and
what indicator of a given type is effective for a given component.

Consider the score above, to which a variety of indicators have just been
attached. By inspecting the leaves in both staves, we can determine what
indicators are effective for each leaf. For example, all of the leaves in the
upper staff will report that their clef is a treble clef, while all of the
leaves in the lower staff will report that theirs is a bass clef:

\begin{comment}
<abjad>
for leaf in score['Upper Staff'].select_leaves():
    clef = inspect_(leaf).get_effective(Clef)
    print(leaf, clef)

for leaf in score['Lower Staff'].select_leaves():
    clef = inspect_(leaf).get_effective(Clef)
    print(leaf, clef)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> for leaf in score['Upper Staff'].select_leaves():
...     clef = inspect_(leaf).get_effective(Clef)
...     print(leaf, clef)
...
(Note("d'4.."), Clef(name='treble'))
(Note("b'16"), Clef(name='treble'))
(Note("af'4"), Clef(name='treble'))
(Note("af'4."), Clef(name='treble'))
(Note("g'8"), Clef(name='treble'))
(Note("c''8"), Clef(name='treble'))
(Note("b'4."), Clef(name='treble'))
(Note("b'8."), Clef(name='treble'))
(Note("d''16"), Clef(name='treble'))
\end{lstlisting}
\begin{lstlisting}
>>> for leaf in score['Lower Staff'].select_leaves():
...     clef = inspect_(leaf).get_effective(Clef)
...     print(leaf, clef)
(Rest('r8'), Clef(name='bass'))
(Note("c'8"), Clef(name='bass'))
(Rest('r8'), Clef(name='bass'))
(Note('d8'), Clef(name='bass'))
(Rest('r8'), Clef(name='bass'))
(Note('e8'), Clef(name='bass'))
(Rest('r4'), Clef(name='bass'))
(Note('g4'), Clef(name='bass'))
(Note('fs4'), Clef(name='bass'))
(Note('e8'), Clef(name='bass'))
(Note('cs8'), Clef(name='bass'))
(Rest('r4.'), Clef(name='bass'))
(Note('fs8'), Clef(name='bass'))
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Despite the tempo indication being attached to the first leaf in the
upper staff, all leaves in the entire score report that same tempo as their
effective tempo:

\begin{comment}
<abjad>
for leaf in score['Upper Staff'].select_leaves():
    tempo = inspect_(leaf).get_effective(Tempo)
    print(leaf, tempo)

for leaf in score['Lower Staff'].select_leaves():
    tempo = inspect_(leaf).get_effective(Tempo)
    print(leaf, tempo)

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> for leaf in score['Upper Staff'].select_leaves():
...     tempo = inspect_(leaf).get_effective(Tempo)
...     print(leaf, tempo)
...
(Note("d'4.."), Tempo(duration=Duration(1, 4), units_per_minute=88))
(Note("b'16"), Tempo(duration=Duration(1, 4), units_per_minute=88))
(Note("af'4"), Tempo(duration=Duration(1, 4), units_per_minute=88))
(Note("af'4."), Tempo(duration=Duration(1, 4), units_per_minute=88))
(Note("g'8"), Tempo(duration=Duration(1, 4), units_per_minute=88))
(Note("c''8"), Tempo(duration=Duration(1, 4), units_per_minute=88))
(Note("b'4."), Tempo(duration=Duration(1, 4), units_per_minute=88))
(Note("b'8."), Tempo(duration=Duration(1, 4), units_per_minute=88))
(Note("d''16"), Tempo(duration=Duration(1, 4), units_per_minute=88))
\end{lstlisting}
\begin{lstlisting}
>>> for leaf in score['Lower Staff'].select_leaves():
...     tempo = inspect_(leaf).get_effective(Tempo)
...     print(leaf, tempo)
...
(Rest('r8'), Tempo(duration=Duration(1, 4), units_per_minute=88))
(Note("c'8"), Tempo(duration=Duration(1, 4), units_per_minute=88))
(Rest('r8'), Tempo(duration=Duration(1, 4), units_per_minute=88))
(Note('d8'), Tempo(duration=Duration(1, 4), units_per_minute=88))
(Rest('r8'), Tempo(duration=Duration(1, 4), units_per_minute=88))
(Note('e8'), Tempo(duration=Duration(1, 4), units_per_minute=88))
(Rest('r4'), Tempo(duration=Duration(1, 4), units_per_minute=88))
(Note('g4'), Tempo(duration=Duration(1, 4), units_per_minute=88))
(Note('fs4'), Tempo(duration=Duration(1, 4), units_per_minute=88))
(Note('e8'), Tempo(duration=Duration(1, 4), units_per_minute=88))
(Note('cs8'), Tempo(duration=Duration(1, 4), units_per_minute=88))
(Rest('r4.'), Tempo(duration=Duration(1, 4), units_per_minute=88))
(Note('fs8'), Tempo(duration=Duration(1, 4), units_per_minute=88))
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent However, the dynamic indications attached to the leaves in the upper
staff are effective only for those leaves, and not for the leaves in the lower
staff:

\begin{comment}
<abjad>
for leaf in score['Upper Staff'].select_leaves():
    dynamic = inspect_(leaf).get_effective(Dynamic)
    print(leaf, dynamic)

for leaf in score['Lower Staff'].select_leaves():
    dynamic = inspect_(leaf).get_effective(Dynamic)
    print(leaf, dynamic)

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> for leaf in score['Upper Staff'].select_leaves():
...     dynamic = inspect_(leaf).get_effective(Dynamic)
...     print(leaf, dynamic)
...
(Note("d'4.."), Dynamic(name='p'))
(Note("b'16"), Dynamic(name='p'))
(Note("af'4"), Dynamic(name='p'))
(Note("af'4."), Dynamic(name='f'))
(Note("g'8"), Dynamic(name='f'))
(Note("c''8"), Dynamic(name='f'))
(Note("b'4."), Dynamic(name='f'))
(Note("b'8."), Dynamic(name='f'))
(Note("d''16"), Dynamic(name='ppp'))
\end{lstlisting}
\begin{lstlisting}
>>> for leaf in score['Lower Staff'].select_leaves():
...     dynamic = inspect_(leaf).get_effective(Dynamic)
...     print(leaf, dynamic)
...
(Rest('r8'), None)
(Note("c'8"), None)
(Rest('r8'), None)
(Note('d8'), None)
(Rest('r8'), None)
(Note('e8'), None)
(Rest('r4'), None)
(Note('g4'), None)
(Note('fs4'), None)
(Note('e8'), None)
(Note('cs8'), None)
(Rest('r4.'), None)
(Note('fs8'), None)
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Both the clef, tempo and dynamics inspected above made use of their
\emph{default scope} when being attached, specifying implicitly that they be
effective at either the staff or score context-level. Indicators can also be
attached with an explicitly-specified scope, overriding any default the
indicator class might provide. By detaching the
implicitly-staff-scoped dynamics, those same dynamic indications can be
reattached, explicitly scoped for the \enquote{PianoStaff} context, allowing
all leaves contained by that piano staff to detect their appropriate dynamic
level:

\begin{comment}
<abjad>
piano_dynamic = detach(Dynamic, score['Voice 1'][0][0])[0]
forte_dynamic = detach(Dynamic, score['Voice 1'][1][0])[0]
attach(piano_dynamic, score['Voice 1'][0][0], scope='PianoStaff')
attach(forte_dynamic, score['Voice 1'][1][0], scope='PianoStaff')
for leaf in score['Upper Staff'].select_leaves():
    dynamic = inspect_(leaf).get_effective(Dynamic)
    print(leaf, dynamic)

for leaf in score['Lower Staff'].select_leaves():
    dynamic = inspect_(leaf).get_effective(Dynamic)
    print(leaf, dynamic)

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> piano_dynamic = detach(Dynamic, score['Voice 1'][0][0])[0]
>>> forte_dynamic = detach(Dynamic, score['Voice 1'][1][0])[0]
>>> attach(piano_dynamic, score['Voice 1'][0][0], scope='PianoStaff')
>>> attach(forte_dynamic, score['Voice 1'][1][0], scope='PianoStaff')
>>> for leaf in score['Upper Staff'].select_leaves():
...     dynamic = inspect_(leaf).get_effective(Dynamic)
...     print(leaf, dynamic)
...
(Note("d'4.."), Dynamic(name='p'))
(Note("b'16"), Dynamic(name='p'))
(Note("af'4"), Dynamic(name='p'))
(Note("af'4."), Dynamic(name='f'))
(Note("g'8"), Dynamic(name='f'))
(Note("c''8"), Dynamic(name='f'))
(Note("b'4."), Dynamic(name='f'))
(Note("b'8."), Dynamic(name='f'))
(Note("d''16"), Dynamic(name='ppp'))
\end{lstlisting}
\begin{lstlisting}
>>> for leaf in score['Lower Staff'].select_leaves():
...     dynamic = inspect_(leaf).get_effective(Dynamic)
...     print(leaf, dynamic)
...
(Rest('r8'), Dynamic(name='p'))
(Note("c'8"), Dynamic(name='p'))
(Rest('r8'), Dynamic(name='p'))
(Note('d8'), Dynamic(name='p'))
(Rest('r8'), Dynamic(name='p'))
(Note('e8'), Dynamic(name='p'))
(Rest('r4'), Dynamic(name='f'))
(Note('g4'), Dynamic(name='f'))
(Note('fs4'), Dynamic(name='f'))
(Note('e8'), Dynamic(name='f'))
(Note('cs8'), Dynamic(name='f'))
(Rest('r4.'), Dynamic(name='f'))
(Note('fs8'), Dynamic(name='f'))
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Recall the voices in the score were populated by Abjad
\texttt{Measure} objects. While LilyPond's musical model does not make use of
explicit measures, Abjad provides measure-like containers as a convenience.
When instantiated, Abjad measures attach the appropriate time signature
indication to themselves. These indicators are also scoped by default, allowing
all of the leaves contained in that measure to detect their appropriate time
signature:

\begin{comment}
<abjad>
measure_1 = score['Voice 1'][0]
measure_2 = score['Voice 1'][1]
inspect_(measure_1).get_indicator(TimeSignature)
for leaf in measure_1.select_leaves():
    time_signature = inspect_(leaf).get_effective(TimeSignature)
    print(leaf, time_signature)

inspect_(measure_2).get_indicator(TimeSignature)
for leaf in measure_2.select_leaves():
    time_signature = inspect_(leaf).get_effective(TimeSignature)
    print(leaf, time_signature)

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> measure_1 = score['Voice 1'][0]
>>> measure_2 = score['Voice 1'][1]
>>> inspect_(measure_1).get_indicator(TimeSignature)
TimeSignature((3, 4))
\end{lstlisting}
\begin{lstlisting}
>>> for leaf in measure_1.select_leaves():
...     time_signature = inspect_(leaf).get_effective(TimeSignature)
...     print(leaf, time_signature)
...
(Note("d'4.."), TimeSignature((3, 4)))
(Note("b'16"), TimeSignature((3, 4)))
(Note("af'4"), TimeSignature((3, 4)))
\end{lstlisting}
\begin{lstlisting}
>>> inspect_(measure_2).get_indicator(TimeSignature)
TimeSignature((5, 4))
\end{lstlisting}
\begin{lstlisting}
>>> for leaf in measure_2.select_leaves():
...     time_signature = inspect_(leaf).get_effective(TimeSignature)
...     print(leaf, time_signature)
...
(Note("af'4."), TimeSignature((5, 4)))
(Note("g'8"), TimeSignature((5, 4)))
(Note("c''8"), TimeSignature((5, 4)))
(Note("b'4."), TimeSignature((5, 4)))
(Note("b'8."), TimeSignature((5, 4)))
(Note("d''16"), TimeSignature((5, 4)))
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\subsection{Annotation}

Indicators may be attached to score components as \emph{annotations},
\enquote{visible} to inspection and potentially scoped, but contributing no
formatting to a score hierarchy's LilyPond output. Additionally, any attached
indication which cannot contribute formatting is considered an implicit
annotation. Consider some of the indicators used above, such as clefs, time
signatures, dynamics and tempo indications. All of these objects can be
formatted as LilyPond syntax, and when attached to components in a score will
appear in the output if and when the score itself is formatted as LilyPond
syntax:

\begin{comment}
<abjad>
clef = Clef('bass')
print(format(clef, 'lilypond'))
time_signature = TimeSignature((5, 4))
print(format(time_signature, 'lilypond'))
dynamic = Dynamic('p')
print(format(dynamic, 'lilypond'))
tempo = Tempo((1, 4), 88)
print(format(tempo, 'lilypond'))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> clef = Clef('bass')
>>> print(format(clef, 'lilypond'))
\clef "bass"
\end{lstlisting}
\begin{lstlisting}
>>> time_signature = TimeSignature((5, 4))
>>> print(format(time_signature, 'lilypond'))
\time 5/4
\end{lstlisting}
\begin{lstlisting}
>>> dynamic = Dynamic('p')
>>> print(format(dynamic, 'lilypond'))
\p
\end{lstlisting}
\begin{lstlisting}
>>> tempo = Tempo((1, 4), 88)
>>> print(format(tempo, 'lilypond'))
\tempo 4=88
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent For example, the above four indicators can be attached to the
contents of the following staff which, when formatted, shows the expected
format contributions of each indicator. Note that the staff must be wrapped in
a score container so that its tempo indication can find the appropriate
context:

\begin{comment}
<abjad>
staff = Staff("g f e d c")
attach(clef, staff)
attach(dynamic, staff)
attach(tempo, staff)
attach(time_signature, staff)
Score([staff])
print(format(staff))
show(staff)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> staff = Staff("g f e d c")
>>> attach(clef, staff)
>>> attach(dynamic, staff)
>>> attach(tempo, staff)
>>> attach(time_signature, staff)
>>> Score([staff])
<Score<<1>>>
\end{lstlisting}
\begin{lstlisting}
>>> print(format(staff))
\new Staff {
    \clef "bass"
    \tempo 4=88
    \time 5/4
    g4
    f4
    e4
    d4
    c4
}
\end{lstlisting}
\begin{lstlisting}
>>> show(staff)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-92459f3cc246a32ad77f8f6f2552a053.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent The above staff can be recreated with the indicators attached as
annotations, still effective for each leaf, but providing no format
contributions in the output. This results in rather poor notation, falling back
on LilyPond's default \sfrac{4}{4} time signature and treble clef:

\begin{comment}
<abjad>
staff = Staff("g f e d c")
attach(clef, staff, is_annotation=True)
attach(dynamic, staff, is_annotation=True)
attach(tempo, staff, is_annotation=True)
attach(time_signature, staff, is_annotation=True)
Score([staff])
print(format(staff))
show(staff)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> staff = Staff("g f e d c")
>>> attach(clef, staff, is_annotation=True)
>>> attach(dynamic, staff, is_annotation=True)
>>> attach(tempo, staff, is_annotation=True)
>>> attach(time_signature, staff, is_annotation=True)
>>> Score([staff])
<Score<<1>>>
\end{lstlisting}
\begin{lstlisting}
>>> print(format(staff))
\new Staff {
    g4
    f4
    e4
    d4
    c4
}
\end{lstlisting}
\begin{lstlisting}
>>> show(staff)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-a55f0283cb66b704a30daf80a4471e39.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Still, the leaves in this second staff can be inspected and will all
report that various indicators attached to the staff, although annotative, are
effective for them:

\begin{comment}
<abjad>
for note in staff:
    tempo = inspect_(note).get_effective(Tempo)
    print(note, tempo)

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> for note in staff:
...     tempo = inspect_(note).get_effective(Tempo)
...     print(note, tempo)
...
(Note('g4'), Tempo(duration=Duration(1, 4), units_per_minute=88))
(Note('f4'), Tempo(duration=Duration(1, 4), units_per_minute=88))
(Note('e4'), Tempo(duration=Duration(1, 4), units_per_minute=88))
(Note('d4'), Tempo(duration=Duration(1, 4), units_per_minute=88))
(Note('c4'), Tempo(duration=Duration(1, 4), units_per_minute=88))
\end{lstlisting}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Annotation allows arbitrary objects to be attached to any score
component as a kind of metadata without directly affecting LilyPond's
typesetting, allowing other later compositional processes to inspect or react
to those annotations. Abjad provides a variety of indicator classes for this
purpose, none of which contribute any formatting, but all of which can be
attached and scoped, allowing composers to better model instrumental technique
or compositional intent. Some of these annotative indicators include
\texttt{BowContactPoint}, \texttt{IsAtSoundingPitch}, \texttt{IsUnpitched},
\texttt{StringContactPoint} and \texttt{StringTuning}.

\section{Spanners}

The final collection of classes, \emph{spanners}, attach to not just one but
many components in a score tree, \emph{spanning} across both time and different
levels of hierarchy.

-   Demonstrate spanners attaching to leaves and to containers

-   Discuss cyclic spanner graph, logical voices

-   Important subclasses: Beam, Slur, Hairpin, Glissando, Tie

-   Mention that ties are treated specially in Abjad, and distinctly from many
    other systems. Other systems might treat "tied-ness" as a flag on a note,
    indicating that the next leaf will be tied to the "tied-set" leaf. Abjad
    treats ties as a spanner, spanning over arbitrary numbers of leaves,
    allowing them to reference each other fluidly.

-   Demonstrate inspect\_(...).get\_spanner(), .get\_spanners()

-   Demonstrate spanner.components

\begin{comment}
<abjad>
show(score)
upper_leaves = score['Voice 1'].select_leaves()
attach(Crescendo(), upper_leaves[0:4])
attach(Decrescendo(), upper_leaves[3:])
attach(Tie(), upper_leaves[2:4])
attach(Tie(), upper_leaves[6:8])
attach(indicatortools.LilyPondCommand('slurDotted'), score['Voice 2'])
attach(Slur(direction=Down), score['Voice 2'][0][1:])
attach(Glissando(), score['Voice 2'][1])
show(score)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> show(score)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-c21a86acc7f03aba66f02ef8ad6b14a5.pdf}
\begin{lstlisting}
>>> upper_leaves = score['Voice 1'].select_leaves()
>>> attach(Crescendo(), upper_leaves[0:4])
>>> attach(Decrescendo(), upper_leaves[3:])
>>> attach(Tie(), upper_leaves[2:4])
>>> attach(Tie(), upper_leaves[6:8])
>>> attach(indicatortools.LilyPondCommand('slurDotted'), score['Voice 2'])
>>> attach(Slur(direction=Down), score['Voice 2'][0][1:])
>>> attach(Glissando(), score['Voice 2'][1])
>>> show(score)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-f830a40d3d0e2008877bfc6c5086bee8.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\begin{comment}
<abjad>
staff = Staff(r"c'4 { d' ef' } f'")
attach(Slur(direction=Down), staff[1])
show(staff)
staff[1].extend("f' g' a' bf'")
show(staff)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> staff = Staff(r"c'4 { d' ef' } f'")
>>> attach(Slur(direction=Down), staff[1])
>>> show(staff)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-69ba73d74e052ed1543cb0c38ee00f60.pdf}
\begin{lstlisting}
>>> staff[1].extend("f' g' a' bf'")
>>> show(staff)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-f42fdd2d988c4478791864ed13ab68f7.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\subsection{Typographic overrides}

-   Demonstrate on components, and on components

-   Discuss graphic objects ("Grobs") versus context settings

-   These commands differ between Abjad and LilyPond due to Abjad's attachment
    model and LilyPond's stream event model.

\begin{comment}
<abjad>
staff = Staff()
staff.append(Measure((3, 4), "c'4 d' r"))
staff.append(Measure((5, 4), r"e'4 \times 2/3 { f' g' r4 } a' b"))
staff.append(Measure((2, 4), "c''8 g' c'4"))
articulation = Articulation('staccato')
for leaf in staff.select_leaves():
    if isinstance(leaf, Note):
        attach(articulation, leaf)

show(staff)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> staff = Staff()
>>> staff.append(Measure((3, 4), "c'4 d' r"))
>>> staff.append(Measure((5, 4), r"e'4 \times 2/3 { f' g' r4 } a' b"))
>>> staff.append(Measure((2, 4), "c''8 g' c'4"))
>>> articulation = Articulation('staccato')
>>> for leaf in staff.select_leaves():
...     if isinstance(leaf, Note):
...         attach(articulation, leaf)
...
>>> show(staff)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-335fabac755e9f43c6612175f46e41d0.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\begin{comment}
<abjad>
override(staff[1]).script.font_size = 10
show(staff)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> override(staff[1]).script.font_size = 10
>>> show(staff)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-159a2f0600d4bc7482fa8d8b96f72e41.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\begin{comment}
<abjad>
slur = spannertools.Slur(direction=Down)
attach(slur, staff.select_leaves()[1:-1])
override(slur).note_head.style = 'cross'
show(staff)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> slur = spannertools.Slur(direction=Down)
>>> attach(slur, staff.select_leaves()[1:-1])
>>> override(slur).note_head.style = 'cross'
>>> show(staff)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-ca02eccb3e94b5f77d471649cca62c70.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\begin{comment}
<abjad>
staff[1][1:2] = "f'8 -. g'8 -. fs'8 -. g'8- ."
show(staff)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> staff[1][1:2] = "f'8 -. g'8 -. fs'8 -. g'8- ."
>>> show(staff)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-b9f0b722e88c76a69e3c1f0dd42dfd94.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\begin{comment}
<abjad>
for index in (0, -2, -1):
    override(staff[1][index]).note_head.style = 'slash'

show(staff)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> for index in (0, -2, -1):
...     override(staff[1][index]).note_head.style = 'slash'
...
>>> show(staff)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-2b17b587265cfc4bae3ef8ddc8440459.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\section{Selecting components}

-   Selections

\subsection{Indexing}

-   By name

-   By index

-   By slice

\subsection{Selections}

-   select()

-   Selection class

-   Container.select\_leaves()

    -   allow\_discontiguous\_leaves=True

-   inspect\_(...).get\_logical\_tie()

-   LogicalTie

    -   head

    -   tail

    -   timespan

    -   trivial logical ties

\subsection{Iteration}

-   By \_\_iter\_\_()

-   By iterate(...)by\_...()

    -   by\_class()

    -   by\_logical\_tie()

    -   by\_run()

    -   by\_timeline()

    -   by\_vertical\_moment()

    -   depth\_first()

\subsection{Selectors}

-   Demonstrate a gallery of selectors.

    -   by duration

    -   by leaves

    -   by length

    -   by logical tie

    -   by counts (with negative counts too)

\section{Mutating components}

-   replace()

-   split()

-   transpose()

\section{Representing pitches}

-   The most important distinction is between named and numbered pitch
    objects.

-   All pitched score components (notes and chords) rely on named
    representations of pitch, not numbered

-   Named pitch objects are enharmonically explicit

-   Numbered pitch objects require some interpretation

-   Abjad has provided one interpretation, but that is for sufficiency

-   Abjad does not make smart guesses about converting numbered to named
    pitches

\subsection{Named and numbered pitch objects}

-   Pitches and pitch-classes

-   Intervals and interval-classes

-   NamedPitch
    -   NamedPitchClass
    -   Accidental
    -   Octave
    -   StaffPosition

-   NamedInterval
    -   Quality

-   NumberedPitch is more equivalent

\subsection{Collections}

-   Set, Segment, Vector

-   PitchSegment

-   PitchClassSegment

-   PitchRange

\subsection{Pitch operations}

-   PitchOperation

-   Transposition

-   Inversion

-   Retrogression

-   Multiplication

-   Rotation

\subsection{Inspecting leaf pitches}

-   Note("c'4").written\_pitch

-   Note("c'4").note\_head.written\_pitch

-   Chord("<c' e' g'>4").written\_pitches

-   inspect\_(note).get\_sounding\_pitch()

-   inspect\_(note).get\_sounding\_pitches()

\section{Notation factories}

-   rhythm-makers

-   score templates

-   parsers

    -   LilyPond parser

    -   PLY

    -   SchemeParser

    -   RhythmTreeParser

    -   ReducedLyParser

- Templating