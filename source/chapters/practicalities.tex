%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Practicalities: project management}
\label{chap:practicalities}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Core concepts:

Version control. Always be in control of the changes in your project.
Text-based development strongly supports this manner of working.
Tagging allows you to pinpoint versions of the work which correspond to
premiers or performances. You always know what's different about one version
versus another version. Branching allows you to try out new pathways without
worry of clobbering your work. Version control is also concise - no more
cluttering up your workspace with multiple directories. You can't compare those
- it's a cognitive burden.

Automated typesetting. Separate content from layout. This extends to both
textual document components and musical document components. Affords easy part
extraction. Cascading stylesheets.

Structured code. Make a clear distinction between classes, materials, and
segments. Segments represent in-time composition. Materials represent
out-of-time composition. Makers represent abstract processes or utilities which
afford the creation of materials and segments.

Testing. Automate proofreading. Guarantee computationally-afforded score
projects continue to function properly over time, ensuring the longevity of the
code-base.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Score directory layout}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

A structured approach to arranging one's compositional workspace clarifies both
the way one thinks about the act of composing, as well as the more menial
workflows of document preparation which are inseparable from score-based
composition. Each of the \emph{Invisible Cities} scores included in part II of
this dissertation are implemented as Python packages extending Abjad model of
notation and Consort's model of composition. Likewise, each \emph{Invisible
Cities} score package is structured into a nearly identical arrange of eight
top-level directories, each with a clearly delineated purpose and substructure.

\begin{figure}[h!]
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\noindent%
\dirtree{%
.1  ersilia/.
    .2  \_\_init\_\_.py\DTcomment{
        The score package Python initializer.
        }.
    .2  build/\DTcomment{
        LilyPond and LaTeX files for building document targets.
        }.
    .2  distribution/\DTcomment{
        Finished PDFs for performers and conductors.
        }.
    .2  etc/\DTcomment{
        Notes, to-do lists and plans.
        }.
    .2  makers/\DTcomment{
        Customized segment-makers, score templates and other classes.
        }.
    .2  materials/\DTcomment{
        Materials used to configure segment-makers.
        }.
    .2  segments/\DTcomment{
        Configured segment-makers and their illustrations.
        }.
    .2  stylesheets/\DTcomment{
        LilyPond stylesheets.
        }.
    .2  test/\DTcomment{
        The score package test suite.
        }.
}
\end{singlespacing}
\caption{\emph{Ersilia}'s top-level directory layout.}
\end{figure}

\noindent The top-level directories named above house specific collections of
assets used during composition or document preparation. Note too the presence
of an \texttt{\_\_init\_\_.py} file. This signals to Python that this directory
represents an importable Python package. Assuming Python is aware of the
location of the score, it and any further subpackages within it can be
imported:

\begin{comment}
<abjad>
import ersilia
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> import ersilia
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Consort very broadly groups the objects used during composition into
\emph{makers}, \emph{materials} and \emph{segments}. Makers comprise any
classes used during composition, such as segment-maker, pitch-handler or music
specifier classes, but not their instances. Materials comprise instances of
classes representing \emph{out-of-time} musical constructs, such as pitch
segments or music specifiers which have not yet been deployed along the
timeline of the score. Segments comprise configured instances of a
segment-maker class and maquette together previously-defined materials
\emph{in-time} into a musical chronology. Each of these three categories of
objects has its own directory in the directory structure outlined here:
\texttt{makers/}, \texttt{materials/} and \texttt{segments/}.

Likewise, the document preparation process involves a number of different types
of assets and tasks. Any LilyPond-typeset PDF created during the composition of
a score, such as a material or segment illustration or the final score itself,
likely requires a corresponding score-specific stylesheet containing the
typographic overrides and LilyPond context definitions pertinent to that score.
These stylesheets reside in the top-level \texttt{stylesheets/} directory.
Scores composed with Abjad and Consort and typeset with LilyPond and LaTeX
involve potentially many source files: LilyPond sources for the musical
content, yet more LilyPond sources for concatenating and styling that content,
LaTeX sources for cover pages, prefaces and performance notes, and still more
LaTeX sources for concatenating the PDFs created while typesetting various
other sources. These source files, in their various stages of typesetting,
occupy the \texttt{build/} directory. Finally, the finished documents, ready to
be delivered to ensembles, occupy the \texttt{distribution/} directory.

\subsection{Makers}
\label{ssec:makers}

Each score's \texttt{makers/} directory houses classes specific to that score.
In the case of my three \emph{Invisible Cities} scores, this always comprises a
subclass of Consort's \texttt{SegmentMaker} and \texttt{ScoreTemplate} classes.
The segment-maker subclasses effectively pre-load common information about the
score, such as what time signatures to permit by default or what the
end-of-score markup should look like. They may also define a considerable
amount of additional score post-processing, as in the case of
\emph{Armilla}, where many passes of voice copying were required to create the
typography for the bowing staves. A score's score template necessarily defines
the instrumentation and structure of the score layout itself. As none of the
scores in this dissertation make use of common instrumentations, each required
that a completely new score template be defined.

Any other class definitions required by the score package should also be placed
into the \texttt{makers/} directory. For example, \emph{Plague Water}, whose
directory structure is effectively identical to the \emph{Invisible Cities}
series but whose composition model both predated and heavily informed the
development of Consort, houses nearly thirty separate class definitions in its
\texttt{makers/} directory.

\subsection{Material packages}
\label{ssec:material-packages}

Materials represent \emph{out-of-time} musical objects, such as pitch
collections, rhythm-makers, and even fully-configured music specifiers, which
may appear at some point in the time-line of a piece. They are implemented as
importable Python packages, grouped flatly into the \texttt{materials/}
directory, itself a Python package due to the presence of an initializer file.

\begin{figure}[h!]
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\dirtree{%
.1  materials/.
    .2  \_\_init\_\_.py\DTcomment{
        The subpackage initializer.
        }.
    .2  abbreviations/\DTcomment{
        A material package.
        }.
    .2  dense\_timespan\_maker/\DTcomment{
        Another material package.
        }.
    .2  guitar\_agitato\_music\_specifier/\DTcomment{
        Yet another material package.
        }.
    .2  guitar\_strummed\_music\_specifier/.
    .2  guitar\_tremolo\_music\_specifier/.
    .2  guitar\_undulation\_tremolo\_music\_specifier/.
    .2  percussion\_bamboo\_windchimes\_music\_specifier/.
    .2  percussion\_crotales\_flash\_music\_specifier/.
    .2  percussion\_crotales\_interruption\_music\_specifier/.
    .2  ....
    .2  ...\DTcomment{
        Many more material packages.
        }.
}
\end{singlespacing}
\caption{Overview of \emph{Ersilia}'s \texttt{materials/} directory.}
\end{figure}

Each material package contains at the least its own initializer as well as
\texttt{definition.py} file containing Python code which defines or configures
that material. Crucially, the actual code object expressed in that
definition.py should be named after the material package itself. This
simplifies the Python import process as simple importing utilities can be
written to iterate over every directory within the \texttt{materials/}
directory and produce corresponding Python import statements of the form
\mintinline{python}{from my_material.definition import my_material}.

\begin{figure}[h!]
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\dirtree{%
.1  guitar\_tremolo\_music\_specifier/.
    .2  \_\_init\_\_.py\DTcomment{
        The material package's Python initializer.
        }.
    .2  definition.py\DTcomment{
        The material's definition file.
        }.
    .2  illustration.ly\DTcomment{
        The material illustration's LilyPond source.
        }.
    .2  illustration.pdf\DTcomment{
        The material's rendered illustration.
        }.
}
\end{singlespacing}
\caption{Directory listing of \emph{Ersilia}'s
\texttt{guitar\_tremolo\_music\_specifier} material package.}
\end{figure}

Materials, depending on the specific \emph{type} of material, can be
illustrated. That is to say, if the class housed in the material definition
file implements an \texttt{\_\_illustrate\_\_()} method -- described in
\autoref{sec:representing-objects} --, it can be illustrated. Any generated
LilyPond illustration source and PDF output is stored in the material package
alongside the definition module. The means by which those illustration files
come to reside there is elaborated on in \autoref{ssec:illustrating}.

\subsection{Segment packages}
\label{ssec:segment-packages}

Segments, like materials, are implemented as Python packages, grouped together
into the top-level \texttt{segments/} directory. They can be imported, they
each have an initializer, and they each have a definition module containing the
definition of that segment's segment-maker. As Consort's segment-maker class is
illustrable, each segment package eventually houses that segment's illustration
LilyPond sources and output PDFs.

\begin{figure}[h!]
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\dirtree{%
.1  segments/.
    .2  \_\_init\_\_.py\DTcomment{
        The subpackage initializer.
        }.
    .2  \_\_metadata\_\_.py\DTcomment{
        Metadata about the order of segments in the score.
        }.
    .2  chemish/\DTcomment{
        A segment package.
        }.
        .3  \_\_init\_\_.py\DTcomment{
            The segment package's Python initializer.
            }.
        .3  \_\_metadata\_\_.py\DTcomment{
            Auto-generated metadata about this score segment.
            }.
        .3  definition.py\DTcomment{
            The segment's definition file, containing a configured
            segment-maker.
            }.
        .3  illustration.ly\DTcomment{
            The segment illustration's LilyPond source.
            }.
        .3  illustration.pdf\DTcomment{
            The segment's rendered illustration.
            }.
    .2  cut\_1/\DTcomment{
        Another segment package.
        }.
        .3  ....
    .2  komokome/\DTcomment{
        Another segment package.
        }.
        .3  ....
    .2  cut\_2/\DTcomment{
        Another segment package.
        }.
        .3  ....
    .2  sort/\DTcomment{
        Yet another segment package.
        }.
        .3  ....
}
\end{singlespacing}
\caption{Overview of \emph{Ersilia}'s \texttt{segments/} directory.}
\end{figure}

Each segment subpackage may also house a \texttt{\_\_metadata\_\_.py}
module, which stores information about that segment such as the number of
measures it contains, the final time signature and tempo, and so forth. This
information is generated automatically during the segment-maker's
interpretation, and allows other segment-makers in other segment packages to
draw conclusions about their own segment's context in the full score without
requiring the re-interpretation of any other segments. Like the illustration
sources, these are discussed in more depth in \autoref{ssec:illustrating}.

A \texttt{\_\_metadata\_\_.py} module sibling to each segment package simply
defines the order of segments. For example, the order of segments in
\emph{Ersilia} is \texttt{komokome}, \texttt{cut\_1}, \texttt{sort},
\texttt{cut\_2}, then \texttt{chemish}. Such an order must be declared
explicitly as it cannot be ascertained from the lexical ordering of the names
of the segment packages. The \texttt{segments/}-local metadata module allows
for such an explicit ordering.

\subsection{The \texttt{stylesheets/} directory}
\label{ssec:the-stylesheets-directory}

The \texttt{stylesheets/} directory consists of LilyPond files containing
typographic overrides, context definitions, document header markup, page layout
configuration and Scheme function definitions. The file \texttt{stylesheet.ily}
represents the primary stylesheet for the entire score, and contains most of
the typographic customization. However, LilyPond stylesheets can
\emph{cascade}: multiple stylesheets can be included into the same master score
file with definitions in subsequently included stylesheets overriding those in
the earlier. Likewise, stylesheets -- because they are simply LilyPond files --
can be included directly into one another.

For example, in \emph{Ersilia}, the master stylesheet file
\texttt{stylesheet.ily} directly includes Scheme definitions from the
file \texttt{scheme.ily}. That master stylesheet is included into the
interpreted LilyPond source of every segment. However, segments beyond the
first also include the stylesheet file \texttt{nonfirst-segment.ily} which
suppresses the appearance of titles and other headers at the top of those
segment illustrations.

\begin{figure}[h!]
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\dirtree{%
.1  stylesheets/.
    .2  nonfirst-segment.ily\DTcomment{
        Style information for segments after the first segment.
        }.
    .2  parts-landscape.ily\DTcomment{
        Style information for landscape-orientation parts.
        }.
    .2  parts-portrait.ily\DTcomment{
        Style information for portrait-orientation parts.
        }.
    .2  scheme.ily\DTcomment{
        LilyPond Scheme commands to be included in the primary stylesheet.
        }.
    .2  stylesheet.ily\DTcomment{
        The primary stylesheet.
        }.
}
\end{singlespacing}
\caption{
Directory listing of \emph{Ersilia}'s \texttt{stylesheets/} directory.
}
\end{figure}

Because LilyPond supports the inclusion of one LilyPond source file into
another, it is possible to define the musical contents of a work in one source
file and collect global typographic overrides into another. This is the
approach I have taken, out of necessity, when building scores with Abjad and
Consort. It is certainly possible to define every one of the typographic
overrides found in \texttt{stylesheet.ily} in Abjad via its top-level
\texttt{override()} and \texttt{set\_()} functions. However, typesetting the
illustration source of a segment in LilyPond generally takes less time than for
that segment to be interpreted in Python. By separating out typographic
overwrites from the musical \enquote{content} it becomes easier to iterate over
refining those overrides by simply adjusting the stylesheet by hand and
recompiling the already-interpreted segment illustration sources.

\subsection{The \texttt{build/} directory}
\label{ssec:the-build-directory}

The \texttt{build/} directory holds source files pertinent to building scores
and parts, along within any component documents, including front and back
covers, prefaces or performance notes. The contents of the \texttt{build/}
directory are organized into \emph{document targets} and \emph{sources}. Each
document target subdirectory consists of source files for producing scores and
parts in a particular format, such as tabloid or A4 paper, or for a particular
performance or language translation. Sources consist of any LilyPond and LaTeX
files containing content to be included into document targets, such as segment
illustration LilyPond sources, LilyPond stylesheets or LaTeX includes -- housed
in \texttt{assets/} -- containing blocks of prose to be flowed into a preface.

\begin{figure}[h!]
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\dirtree{%
.1  build/.
    .2  11x17-landscape/\DTcomment{
        A document build target directory.
        }.
        .3  ....
    .2  11x17-portrait/\DTcomment{
        Another document build target directory.
        }.
        .3  ....
    .2  assets/\DTcomment{
        LaTeX files to be included into each preface layout.
        }.
        .3  calvino.tex.
        .3  instrumentation.tex.
        .3  leguin.tex.
        .3  performance-notes.tex.
    .2  legal-landscape/\DTcomment{
        Another document build target directory.
        }.
        .3  ....
    .2  legal-portrait/\DTcomment{
        Yet another document build target directory.
        }.
        .3  ....
    .2  parts.ily\DTcomment{
        A LilyPond include file for generating parts.
        }.
    .2  segments/\DTcomment{
        Segment illustration LilyPond sources.
        }.
        .3  chemish.ily.
        .3  cut-1.ily.
        .3  cut-2.ily.
        .3  komokome.ily.
        .3  sort.ily.
    .2  segments.ily\DTcomment{
        A LilyPond include file giving the order of the segments to
        concatenate.
        }.
}
\end{singlespacing}
\caption{Overview of \emph{Ersilia}'s \texttt{build/} directory.}
\end{figure}

The file \texttt{parts.ily}, discussed in \autoref{ssec:part-extraction},
defines LilyPond commands for outputting parts. The file \texttt{segments.ily}
defines -- in LilyPond syntax -- the order in which the segment illustration
sources, collected in the \texttt{segments/} subdirectory of the
\texttt{build/} directory, are to be concatenated.

\begin{figure}[h!]
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\dirtree{%
.1  11x17-landscape/\DTcomment{
    A build target directory.
    }.
    .2  Makefile\DTcomment{
        A Makefile for GNU \texttt{make} affords various build tasks.
        }.
    .2  back-cover.pdf\DTcomment{
        PDF output of the back cover LaTeX source.
        }.
    .2  back-cover.tex\DTcomment{
        LaTeX source for the back cover.
        }.
    .2  front-cover.pdf\DTcomment{
        PDF output of the front cover LaTeX source.
        }.
    .2  front-cover.tex\DTcomment{
        LaTeX source for the back cover.
        }.
    .2  music.ly\DTcomment{
        LilyPond source for the concatenated score segments.
        }.
    .2  music.pdf\DTcomment{.
        PDF output for the concatenated score segments LilyPond source.
        }.
    .2  parts.ly\DTcomment{
        LilyPond source for generating individual parts PDFs.
        }.
    .2  preface.pdf\DTcomment{
        PDF output for the preface LaTeX source.
        }.
    .2  preface.tex\DTcomment{
        LaTeX source for the preface.
        }.
    .2  score.pdf\DTcomment{
        PDF output of the complete score LaTeX source.
        }.
    .2  score.tex\DTcomment{
        LaTeX source for the complete score.
        }.
}
\end{singlespacing}
\caption{Directory listing of a document build target in \emph{Ersilia}.}
\end{figure}

Each document target directory consists of a similar collection of files: LaTeX
sources for the front cover, back cover, and preface, LilyPond sources for the
musical content of the score itself and parts, and a master LaTeX source which
combines covers, the preface and the music into a single score PDF. The
LilyPond \texttt{music.ily} contains \texttt{\textbackslash{}include}
statements which pull in the \texttt{segments.ily} file from the
\texttt{build/} directory as well as the score's main LilyPond stylesheet from
the top-level \texttt{stylesheets} directory.

\subsection{The \texttt{etc/} and \texttt{distribution/} directories}
\label{ssec:the-etc-and-distribution-directories}

The \texttt{etc/} and \texttt{distribution/} directories are perhaps the
simplest. The former holds any notes, plans or to-do lists pertinent to the
compositional process of the score while the latter collects completed scores
and parts for each document target from the \texttt{build/} directory.

\subsection{The \texttt{test/} directory}
\label{ssec:the-test-directory}

Finally, the \texttt{test/} directory contains Python modules defining
parameterized tests which attempt to import each material package and then
import and illustrate each segment in the entire score. The test modules are
run by the \texttt{pytest} testing tool.

\begin{figure}[h!]
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\dirtree{%
.1  test/.
.2  test\_materials.py\DTcomment{
    Parameterized tests for validating integrity of each material package.
    }.
.2  test\_segments.py\DTcomment{
    Parameterized tests for validating integrity of each segment package.
    }.
}
\end{singlespacing}
\caption{Parameterized tests.}
\end{figure}

Note that these tests do not attempt to guarantee that a particular segment
produces some score exactly matching a target, but simply that the
segment-maker manages to interpret without failure, and that LilyPond manages
to typeset the resulting source without error.

\subsection{Python packaging}
\label{ssec:python-packaging}

Each score package should also be properly \emph{packaged} according to Python
standards so that it can be installed on other systems. This might strike
composers as an unmotivated suggestion. Why should one structure their private
score such that it can be used by others? Making a score installable in this
way affords a number of conveniences related to testing. Installable scores can
be tested in \emph{virtual environments} -- a common Python practice -- by
automated test runners like \texttt{tox} or run on remote
continuous-integration testing services such as Travis-CI. Both of these tools
are addressed in \autoref{ssec:testing}.

\begin{figure}[h!]
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\dirtree{%
.1  ersilia/.
    .2 .git/\DTcomment{
        The Git repository history.
        }.
    .2 .gitignore\DTcomment{
        File patterns to be ignored by the Git version control system.
        }.
    .2 .travis.yml\DTcomment{
        The Travis-CI build configuration script.
        }.
    .2 README.md\DTcomment{
        A MarkDown text file containing introductory information about the
        score package.
        }.
    .2 ersilia/\DTcomment{
        The score package itself.
        }.
    .2 requirements.txt\DTcomment{
        Dependency information, for use when installing on Travis-CI.
        }.
    .2 setup.cfg\DTcomment{
        Python packaging configuration.
        }.
    .2 setup.py\DTcomment{
        The Python package installation script.
        }.
    .2 tox.ini\DTcomment{
        Configuration for the \texttt{tox} automated testing tool.
        }.
}
\end{singlespacing}
\caption{Overview of \emph{Ersilia}'s Python packaging assets.}
\end{figure}

For those who wish to make both their scores and code completely public -- as I
have -- installation affordances are simply necessary for letting others
explore the code as quickly and easily as possible.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Document preparation work-flow}
\label{sec:document-preparation-work-flow}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Build tools}
\label{ssec:build-tools}

I make use of a variety of custom build tools for managing assets within a
score package which will not be discussed here in any detail. These tools
simplify various tasks such as creating new segment and material packages,
executing segment definition modules in order to illustrate the contained
segment-makers, comparing new illustration LilyPond sources and PDF outputs
against previously rendered ones, and collecting and massaging segment LilyPond
sources from each segment package into the build directory for document
preparation.

\subsection{Editing}
\label{ssec:editing}

I do everything in text. vim is my primary tool, but any decent text editor
will do. Facility in making mass transformations across files is key - you may
want to rename things that appear in multiple places. searching is important.
syntax highlighting, and easy access to every file in your project and any
project you rely on is key.

\subsection{Illustrating}
\label{ssec:illustrating}

how does illustrating work? you can do it at the command-line by importing a
definition by hand, but this gets tedious.

Write a script that does the illustrating. You can also make each segment
definition file executable.

Segment metadata. Each segment can return not just an illustration but also a
dictionary containing information about the segment it created. What was its
tempo? Did it repeat? How many bars were there? What was the last time
signature used? This metadata dictionary can be persisted to disk just like the
segment's illustration.

Choose the order of the segments and write that into its own metadata python
module. When you illustrate, you can peek at the other segment packages,
examine their metadata and construct a model of pertinent information about
what has happened prior to the current segment under consideration.

\subsection{LilyPond stylesheets}
\label{ssec:lilypond-stylesheets}

Stylesheets cascade.

A master stylesheet describes the overall look-and-feel of the score.

A stylesheet for scheme functions (LilyPond is scriptable, remember?)

A stylesheet for parts.

\subsection{Collecting segment files}
\label{ssec:collecting-segment-files}

LilyPond concatenates contexts.

.ily vs .ly: just a convention. .ly can be compiled by itself, .ily either has
no music, or requires includes which are not present.

Copy segments illustration files out of each segment package into
build/segments.

Rename each segment from illustration.ly to segment-package-name.ily

Trim every except the \texttt{\textbackslash{}context} block.

Trimming removes the unnecessary header and styling information from each
collected segment illustration and allows LilyPond to concatenate the score
contexts together into a single score structure.

\begin{singlespacing}
\vspace{-0.5\baselineskip}
\inputminted{tex}{../../Documents/Scores/ersilia/ersilia/build/segments.ily}
\end{singlespacing}

\subsection{LaTeX assets}
\label{ssec:latex-assets}

what latex assets does each document target require?

Front-cover, back-cover, performance-notes, music.

use a master score.tex to include all of the document target assets together.
Latex can merge pdfs easily, so just do that.

\begin{figure}[h!]
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\inputminted{tex}{../../Documents/Scores/ersilia/ersilia/build/11x17-portrait/ersilia-11x17-portrait-score.tex}
\end{singlespacing}
\vspace{-0.5\baselineskip}
\caption{A score LaTeX source in \emph{Ersilia}.}
\end{figure}

\subsection{Part extraction}
\label{ssec:part-extraction}

%Tags. You can use tags in LilyPond to filter out or keep any musical
%expression, from a single note to an entire score. By tagging every staff or
%staff group with a unique name, you can use LilyPond's tag filtering commands
%to generate PDFs containing only selected musical content.
%
%Bookpart blocks. LilyPond can be instructed to build PDFs consisting of
%multiple separate scores, appearing on separate pages. For example, hymnals, or
%multi-movement works. \enquote{Books} can consist of multiple
%\enquote{bookparts} which can themselves consist of multiple scores. You can
%construct bookparts such that LilyPond outputs each bookpart as a separate PDF.
%This is an ideal way to structure a document to output parts.
%
%One bookpart per part PDF, with the appropriate tag.

When working with LilyPond and Abjad, part extraction relies on two fairly
simple LilyPond mechanisms: \emph{tags} and \emph{book blocks}. In LilyPond,
any music expression can be labeled with a tag, a string or symbol which
identifies that music expression. Later, music expressions can be filtered to
either remove or solely preserve any expression with a given tag. Consider the
following pseudo-score, consisting of a score containing three staves and a
time signature context:

\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{tex}
\keepWithTag #'(time B)
\new Score <<
    \tag #'time \new TimeSignatureContext = "Time Signature Context" { ... }
    \tag #'A \new Staff = "Staff A" { ... }
    \tag #'B \new Staff = "Staff B" { ... }
    \tag #'C \new Staff = "Staff C" { ... }
>>
\end{minted}
\end{singlespacing}

\noindent Each context contained by the \texttt{Score} context -- the three
staves and the time signature context -- is tagged via a LilyPond
\texttt{\textbackslash{}tag} command, associating that context's music
expression with the tag's symbol. The command preceding the score itself --
\texttt{\textbackslash{}keepWithTag \#\'(time B)} -- indicates that the score
should filter out any tagged music expression which do not belong to the list
of expressions \texttt{\#\'(time B)}. That is, the score should omit the two
staves tagged \texttt{A} and \texttt{C}, effectively producing a score
structured like so:

\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{tex}
\new Score <<
    \new TimeSignatureContext = "Time Signature Context" { ... }
    \new Staff = "Staff B" { ... }
>>
\end{minted}
\end{singlespacing}

\noindent This tagging technique is used in every score developed with Consort.
Each score's score template includes tag commands labeling both the time
signature context -- which must appear both in the full score and all parts as
it contains time signature, tempo and rehearsal mark information -- as well as
all inner contexts necessary for individual performers. By constructing the
appropriate \texttt{\textbackslash{}keepWithTag} commands, music expressions
representing each performer's part can be constructed easily.
Note the use of \texttt{\textbackslash{}tag} commands throughout the structure
of \emph{Armilla}'s score:

\begin{singlespacing}
\vspace{-0.5\baselineskip}
\inputminted[
    gobble=8,
    firstline=19,
    lastline=71,
]{tex}{../../Documents/Scores/armilla/armilla/makers/ArmillaScoreTemplate.py}
\end{singlespacing}

\noindent The time signature context receives its own tag, and the staff groups
wrapping each performer's bowing and fingering staves are also tagged
appropriately.

While tagging allows for extracting parts as music expressions, it does not yet
result in actual documents for each part. LilyPond's book block structure,
combined with the \texttt{\textbackslash{}bookOutputSuffix} command, provide a
concise mechanism for generating multiple output PDFs from a single LilyPond
input file. As demonstrated throughout this document, LilyPond files are
structured into blocks -- context blocks, score blocks, header and paper
blocks, and so forth. The highest level block is a
\texttt{\textbackslash{}book} block. Somewhat like parts in LaTeX, book blocks
separate content from one another by page breaks. Score blocks contained in
separate book blocks are guaranteed to never appear on the same page together.
Furthermore, by specifying a book output suffix within each book block,
LilyPond will not simply separate that book blocks's content by page breaks but
will actually output a wholly separate PDF, whose filename is suffixed with
that book output suffix.

Consider the excerpt from \emph{Ersilia}'s \texttt{parts.ily} file in
\autoref{fig:ersilia-parts-ily}.

\begin{singlespacing}
\vspace{-0.5\baselineskip}
\inputminted[
    lastline=23,
]{tex}{../../Documents/Scores/ersilia/ersilia/build/parts.ily}
\end{singlespacing}

\noindent This file contains one book block per instrument. Each book block
specifies an output suffix pertinent to a specific performer in the ensemble.
Each book block also contains a score block whose contents consist entirely of
an include statement -- pointing at \texttt{segments.ily}, which concatenates
all score segments into a single music expression -- wrapped in a
\texttt{\textbackslash{}keepWithTag} command which filters out everything
except that performer's musical content and the global time signature context.



\begin{singlespacing}
\vspace{-0.5\baselineskip}
\inputminted[
    firstline=3,
]{tex}{../../Documents/Scores/ersilia/ersilia/build/11x17-portrait/ersilia-11x17-portrait-parts.ly}
\end{singlespacing}

\noindent Note that there are methods by which composers can generate parts in
LilyPond. Most LilyPond users who work strictly with LilyPond, writing
\enquote{by hand}, would likely places each of the instrumental parts in the
score into a separate file or variable. Those parts would then be combined into
either the full score or a part for a single player as necessary. Because
Consort produces a single score, complete with all parts joined into a single
expression, filtering must be used to \enquote{strip} the score down to the
desired musical elements.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Project maintenance}
\label{sec:project-maintenance}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

foo

\subsection{Testing}
\label{ssec:testing}

Parameterized tests which run each segment and import each material. Why do
this? It's a simple entry point to check the stability of your entire score as
you work. If your score depends on another project -- e.g. Abjad or Consort --
where that project is also being actively developed testing lets you check that
your project continues to interoperate.

Continuous integration testing via Travis-CI or similar service. Run your tests
on a remote server in a virtual machine. This guarantees that your score can be
installed on a fresh machine which is also probably of a different
architecture. Also guarantees that any other project your score depends on,
e.g. Abjad or any of Abjad's dependencies, can also be installed and used in a
fresh environment. Why do things in a fresh environment? Our local workspace
can become a blind-spot to us.

\subsection{Version control}
\label{ssec:version-control}

This is the most important aspect of working computationally. If I can impart
\emph{any} advice to anyone working with computers, even if they never program
ever, it would be to learn how to use version control.