%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Practicalities: project management}
\label{chap:practicalities}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Core concepts:

Version control. Always be in control of the changes in your project.
Text-based development strongly supports this manner of working.
Tagging allows you to pinpoint versions of the work which correspond to
premiers or performances. You always know what's different about one version
versus another version. Branching allows you to try out new pathways without
worry of clobbering your work. Version control is also concise - no more
cluttering up your workspace with multiple directories. You can't compare those
- it's a cognitive burden.

Automated typesetting. Separate content from layout. This extends to both
textual document components and musical document components. Affords easy part
extraction. Cascading stylesheets.

Structured code. Make a clear distinction between classes, materials, and
segments. Segments represent in-time composition. Materials represent
out-of-time composition. Makers represent abstract processes or utilities which
afford the creation of materials and segments.

Testing. Automate proofreading. Guarantee computationally-afforded score
projects continue to function properly over time, ensuring the longevity of the
code-base.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Score directory layout}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

A clear way of structuring one's workspace clarifies both the way one thinks
about the act of composing, as well as the menial work flows of document
preparation which are inseparable from score-based composition.

\begin{singlespacing}
\vspace{-0.5\baselineskip}
\dirtree{%
.1  ersilia/.
    .2  build/\DTcomment{
        LilyPond and LaTeX files for building document targets.
        }.
    .2  distribution/\DTcomment{
        Finished PDFs for performers and conductors.
        }.
    .2  etc/\DTcomment{
        Notes, to-do lists and plans.
        }.
    .2  makers/\DTcomment{
        Customized segment-makers, score templates and other classes.
        }.
    .2  materials/\DTcomment{
        Materials used to configure segment-makers. 
        }.
    .2  segments/\DTcomment{
        Configured segment-makers and their illustrations.
        }.
    .2  stylesheets/\DTcomment{
        LilyPond stylesheets.
        }.
    .2  test/\DTcomment{
        The score package test suite.
        }.
}
\end{singlespacing}

Each directory serves a specific purpose and by-and-large describes a
particular kind of task during composition and document preparation.

\subsection{Material packages}

Materials are out-of-time. Pitch collections, rhythm-makers, music specifiers.
Compositional and musical objects which may appear at some point during a
piece.

Materials are implemented as Python packages. They have an initializer and a
definition file. Of course, those could be conflated, but I choose not to out
of habit.

Materials, depending on the specific kind of material, can be illustrated. If
the class housed in the material definition file implements \_\_illustrate\_\_,
it can be illustrated.

Materials can be imported.

\begin{singlespacing}
\vspace{-0.5\baselineskip}
\dirtree{%
.1  materials/.
    .2  \_\_init\_\_.py\DTcomment{
        The subpackage initializer.
        }.
    .2  abbreviations/\DTcomment{
        A material package.
        }.
    .2  dense\_timespan\_maker/\DTcomment{
        Another material package.
        }.
    .2  guitar\_agitato\_music\_specifier/\DTcomment{
        Yet another material package.
        }.
    .2  guitar\_strummed\_music\_specifier/.
    .2  guitar\_tremolo\_music\_specifier/.
    .2  guitar\_undulation\_tremolo\_music\_specifier/.
    .2  percussion\_bamboo\_windchimes\_music\_specifier/.
    .2  percussion\_crotales\_flash\_music\_specifier/.
    .2  percussion\_crotales\_interruption\_music\_specifier/.
    .2  ....
    .2  ...\DTcomment{
        Many more material packages.
        }.
}
\end{singlespacing}

The anatomy of a material package.

\begin{singlespacing}
\vspace{-0.5\baselineskip}
\dirtree{%
.1  guitar\_tremolo\_music\_specifier/.
    .2  \_\_init\_\_.py\DTcomment{
        The material package's Python initializer.
        }.
    .2  definition.py\DTcomment{
        The material's definition file.
        }.
    .2  illustration.ly\DTcomment{
        The material illustration's LilyPond source.
        }.
    .2  illustration.pdf\DTcomment{
        The material's rendered illustration.
        }.
}
\end{singlespacing}

\subsection{Segment packages}

Segments, like materials, are Python packages.

They can be imported. They have an initializer and a definition module. They
can optionally have metadata modules.

A metadata module sibling to each segment package provides ordering
information.

\begin{singlespacing}
\vspace{-0.5\baselineskip}
\dirtree{%
.1  segments/.
    .2  \_\_init\_\_.py\DTcomment{
        The subpackage initializer.        
        }.
    .2  \_\_metadata\_\_.py\DTcomment{
        Metadata about the order of segments in the score.
        }.
    .2  chemish/\DTcomment{
        A segment package.
        }.
        .3  \_\_init\_\_.py\DTcomment{
            The segment package's Python initializer. 
            }.
        .3  \_\_metadata\_\_.py\DTcomment{
            Auto-generated metadata about this score segment.
            }.
        .3  definition.py\DTcomment{
            The segment's definition file, containing a configured
            segment-maker.
            }.
        .3  illustration.ly\DTcomment{
            The segment illustration's LilyPond source.
            }.
        .3  illustration.pdf\DTcomment{
            The segment's rendered illustration.
            }.
    .2  cut\_1/\DTcomment{
        Another segment package.
        }.
        .3  ....
    .2  komokome/\DTcomment{
        Another segment package.
        }.
        .3  ....
    .2  cut\_2/\DTcomment{
        Another segment package.
        }.
        .3  ....
    .2  sort/\DTcomment{
        Yet another segment package.
        }.
        .3  ....
}
\end{singlespacing}

\subsection{The \texttt{stylesheets/} directory}

Stylesheets cascade.

You can use one primary stylesheet and include it into each segment
illustration, as well as into the concatenated segment LilyPond sources that
live in each document target directory in build/.

\begin{singlespacing}
\vspace{-0.5\baselineskip}
\dirtree{%
.1  stylesheets/.
    .2  nonfirst-segment.ily\DTcomment{
        Style information for segments after the first segment.
        }.
    .2  parts-landscape.ily\DTcomment{
        Style information for landscape-orientation parts.
        }.
    .2  parts-portrait.ily\DTcomment{
        Style information for portrait-orientation parts.
        }.
    .2  scheme.ily\DTcomment{
        LilyPond Scheme commands to be included in the primary stylesheet.
        }.
    .2  stylesheet.ily\DTcomment{
        The primary stylesheet.
        }.
}
\end{singlespacing}

\subsection{The \texttt{build/} directory}

XXX

\begin{singlespacing}
\vspace{-0.5\baselineskip}
\dirtree{%
.1  build/.
    .2  11x17-landscape/\DTcomment{
        A document build target directory.
        }.
        .3  ....
    .2  11x17-portrait/\DTcomment{
        Another document build target directory.
        }.
        .3  ....
    .2  assets/\DTcomment{
        LaTeX files to be included into each preface layout.
        }.
        .3  calvino.tex.
        .3  instrumentation.tex.
        .3  leguin.tex.
        .3  performance-notes.tex.
    .2  legal-landscape/\DTcomment{
        Another document build target directory.
        }.
        .3  ....
    .2  legal-portrait/\DTcomment{
        Yet another document build target directory.
        }.
        .3  ....
    .2  parts.ily\DTcomment{
        A LilyPond include file for generating parts.
        }.
    .2  segments/\DTcomment{
        Segment illustration LilyPond sources.
        }.
        .3  chemish.ily.
        .3  cut-1.ily.
        .3  cut-2.ily.
        .3  komokome.ily.
        .3  sort.ily.
    .2  segments.ily\DTcomment{
        A LilyPond include file giving the order of the segments to
        concatenate.
        }.
}
\end{singlespacing}

XXX

\begin{singlespacing}
\vspace{-0.5\baselineskip}
\dirtree{%
.1  11x17-landscape/\DTcomment{
    A build target directory.
    }.
    .2  Makefile\DTcomment{
        A Makefile for GNU \texttt{make} affords various build tasks.
        }.
    .2  back-cover.pdf\DTcomment{
        PDF output of the back cover LaTeX source.
        }.
    .2  back-cover.tex\DTcomment{
        LaTeX source for the back cover.
        }.
    .2  front-cover.pdf\DTcomment{
        PDF output of the front cover LaTeX source.
        }.
    .2  front-cover.tex\DTcomment{
        LaTeX source for the back cover.
        }.
    .2  music.ly\DTcomment{
        LilyPond source for the concatenated score segments.
        }.
    .2  music.pdf\DTcomment{.
        PDF output for the concatenated score segments LilyPond source. 
        }.
    .2  parts.ly\DTcomment{
        LilyPond source for generating individual parts PDFs.
        }.
    .2  preface.pdf\DTcomment{
        PDF output for the preface LaTeX source.
        }.
    .2  preface.tex\DTcomment{
        LaTeX source for the preface.
        }.
    .2  score.pdf\DTcomment{
        PDF output of the complete score LaTeX source. 
        }.
    .2  score.tex\DTcomment{
        LaTeX source for the complete score.
        }.
}
\end{singlespacing}

\subsection{The \texttt{etc/} and \texttt{distribution/} directories}

Put notes, plans and to-dos about the process of composing into etc/.

Collect finished document targets into distribution/. These should be organized
by gig, and should contain only the files you would need to send to an
ensemble.

\subsection{The \texttt{test/} directory}

XXX

\begin{singlespacing}
\vspace{-0.5\baselineskip}
\dirtree{%
.1  test/.
.2  test\_materials.py\DTcomment{
    Parameterized tests for validating integrity of each material package.
    }.
.2  test\_segments.py\DTcomment{
    Parameterized tests for validating integrity of each segment package.
    }.
}
\end{singlespacing}

\subsection{Python packaging}

XXX

\begin{singlespacing}
\vspace{-0.5\baselineskip}
\dirtree{%
.1  ersilia/.
    .2 .git/\DTcomment{
        The Git repository history.
        }.
    .2 .gitignore\DTcomment{
        File patterns to be ignored by the Git version control system.
        }.
    .2 .travis.yml\DTcomment{
        The Travis-CI build configuration script.
        }.
    .2 README.md\DTcomment{
        A MarkDown text file containing introductory information about the
        score package.
        }.
    .2 ersilia/\DTcomment{
        The score package itself.
        }.
    .2 requirements.txt\DTcomment{
        Dependency information, for use when installing on Travis-CI.
        }.
    .2 setup.cfg\DTcomment{
        Packaging information.
        }.
    .2 setup.py\DTcomment{
        A Python install script.
        }.
}
\end{singlespacing}

\section{Document preparation work-flow}

\subsection{Build tools}

I make use of a variety of custom build tools for managing assets within a
score package which will not be discussed here in any detail. These tools
simplify various tasks such as creating new segment and material packages,
executing segment definition modules in order to illustrate the contained
segment-makers, comparing new illustration LilyPond sources and PDF outputs
against previously rendered ones, and collecting and massaging segment LilyPond
sources from each segment package into the build directory for document
preparation.

\subsection{Editing}

I do everything in text. vim is my primary tool, but any decent text editor
will do. Facility in making mass transformations across files is key - you may
want to rename things that appear in multiple places. searching is important.
syntax highlighting, and easy access to every file in your project and any
project you rely on is key.

\subsection{Illustrating}

how does illustrating work? you can do it at the command-line by importing a
definition by hand, but this gets tedious.

Write a script that does the illustrating. You can also make each segment
definition file executable.

Segment metadata. Each segment can return not just an illustration but also a
dictionary containing information about the segment it created. What was its
tempo? Did it repeat? How many bars were there? What was the last time
signature used? This metadata dictionary can be persisted to disk just like the
segment's illustration.

Choose the order of the segments and write that into its own metadata python
module. When you illustrate, you can peek at the other segment packages,
examine their metadata and construct a model of pertinent information about
what has happened prior to the current segment under consideration.

\subsection{LilyPond stylesheets}

Stylesheets cascade.

A master stylesheet describes the overall look-and-feel of the score.

A stylesheet for scheme functions (LilyPond is scriptable, remember?)

A stylesheet for parts.

\subsection{Collecting segment files}

LilyPond concatenates contexts.

.ily vs .ly: just a convention. .ly can be compiled by itself, .ily either has
no music, or requires includes which are not present.

Copy segments illustration files out of each segment package into
build/segments.

Rename each segment from illustration.ly to segment-package-name.ily

Trim every except the \texttt{\textbackslash{}context} block.

Trimming removes the unnecessary header and styling information from each
collected segment illustration and allows LilyPond to concatenate the score
contexts together into a single score structure.

\begin{singlespacing}
\vspace{-0.5\baselineskip}
\inputminted{tex}{../../Documents/Scores/ersilia/ersilia/build/segments.ily}
\end{singlespacing}

\subsection{LaTeX assets}

what latex assets does each document target require?

Front-cover, back-cover, performance-notes, music.

use a master score.tex to include all of the document target assets together.
Latex can merge pdfs easily, so just do that.

\begin{singlespacing}
\vspace{-0.5\baselineskip}
\inputminted{tex}{../../Documents/Scores/ersilia/ersilia/build/11x17-portrait/ersilia-11x17-portrait-score.tex}
\end{singlespacing}

\subsection{Part extraction}

Tags. You can use tags in LilyPond to filter out or keep any musical
expression, from a single note to an entire score. By tagging every staff or
staff group with a unique name, you can use LilyPond's tag filtering commands
to generate PDFs containing only selected musical content.

Bookpart blocks. LilyPond can be instructed to build PDFs consisting of
multiple separate scores, appearing on separate pages. For example, hymnals, or
multi-movement works. \enquote{Books} can consist of multiple
\enquote{bookparts} which can themselves consist of multiple scores. You can
construct bookparts such that LilyPond outputs each bookpart as a separate PDF.
This is an ideal way to structure a document to output parts.

\begin{singlespacing}
\vspace{-0.5\baselineskip}
\inputminted[
    lastline=23,
]{tex}{../../Documents/Scores/ersilia/ersilia/build/parts.ily}
\end{singlespacing}

One bookpart per part PDF, with the appropriate tag.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Project maintenance}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

foo

\subsection{Testing}

Parameterized tests which run each segment and import each material. Why do
this? It's a simple entry point to check the stability of your entire score as
you work. If your score depends on another project -- e.g. Abjad or Consort --
where that project is also being actively developed testing lets you check that
your project continues to interoperate.

Continuous integration testing via Travis-CI or similar service. Run your tests
on a remote server in a virtual machine. This guarantees that your score can be
installed on a fresh machine which is also probably of a different
architecture. Also guarantees that any other project your score depends on,
e.g. Abjad or any of Abjad's dependencies, can also be installed and used in a
fresh environment. Why do things in a fresh environment? Our local workspace
can become a blind-spot to us.

\subsection{Version control}

This is the most important aspect of working computationally. If I can impart
\emph{any} advice to anyone working with computers, even if they never program
ever, it would be to learn how to use version control.