%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Practicalities: project management}
\label{chap:practicalities}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Core concepts:

Version control. Always be in control of the changes in your project.
Text-based development strongly supports this manner of working.
Tagging allows you to pinpoint versions of the work which correspond to
premiers or performances. You always know what's different about one version
versus another version. Branching allows you to try out new pathways without
worry of clobbering your work. Version control is also concise - no more
cluttering up your workspace with multiple directories. You can't compare those
- it's a cognitive burden.

Automated typesetting. Separate content from layout. This extends to both
textual document components and musical document components. Affords easy part
extraction. Cascading stylesheets.

Structured code. Make a clear distinction between classes, materials, and
segments. Segments represent in-time composition. Materials represent
out-of-time composition. Makers represent abstract processes or utilities which
afford the creation of materials and segments.

Testing. Automate proofreading. Guarantee computationally-afforded score
projects continue to function properly over time, ensuring the longevity of the
code-base.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Score directory layout}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

A structured approach to arranging one's compositional workspace clarifies both
the way one thinks about the act of composing, as well as the more menial
workflows of document preparation which are inseparable from score-based
composition. Each of the \emph{Invisible Cities} scores included in part II of
this dissertation are implemented as Python packages extending Abjad model of
notation and Consort's model of composition. Likewise, each \emph{Invisible
Cities} score package is structured into a nearly identical arrange of eight
top-level directories, each with a clearly delineated purpose and substructure.

\begin{figure}[h!]
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\noindent%
\dirtree{%
.1  ersilia/.
    .2  \_\_init\_\_.py\DTcomment{
        The score package Python initializer.
        }.
    .2  build/\DTcomment{
        LilyPond and LaTeX files for building document targets.
        }.
    .2  distribution/\DTcomment{
        Finished PDFs for performers and conductors.
        }.
    .2  etc/\DTcomment{
        Notes, to-do lists and plans.
        }.
    .2  makers/\DTcomment{
        Customized segment-makers, score templates and other classes.
        }.
    .2  materials/\DTcomment{
        Materials used to configure segment-makers.
        }.
    .2  segments/\DTcomment{
        Configured segment-makers and their illustrations.
        }.
    .2  stylesheets/\DTcomment{
        LilyPond stylesheets.
        }.
    .2  test/\DTcomment{
        The score package test suite.
        }.
}
\end{singlespacing}
\caption{\emph{Ersilia}'s top-level directory layout.}
\end{figure}

\noindent The top-level directories named above house specific collections of
assets used during composition or document preparation. Note too the presence
of an \texttt{\_\_init\_\_.py} file. This signals to Python that this directory
represents an importable Python package. Assuming Python is aware of the
location of the score, it and any further subpackages within it can be
imported:

\begin{comment}
<abjad>
import ersilia
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> import ersilia
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Consort very broadly groups the objects used during composition into
\emph{makers}, \emph{materials} and \emph{segments}. Makers comprise any
classes used during composition, such as segment-maker, pitch-handler or music
specifier classes, but not their instances. Materials comprise instances of
classes representing \emph{out-of-time} musical constructs, such as pitch
segments or music specifiers which have not yet been deployed along the
timeline of the score. Segments comprise configured instances of a
segment-maker class and maquette together previously-defined materials
\emph{in-time} into a musical chronology. Each of these three categories of
objects has its own directory in the directory structure outlined here:
\texttt{makers/}, \texttt{materials/} and \texttt{segments/}.

Likewise, the document preparation process involves a number of different types
of assets and tasks. Any LilyPond-typeset PDF created during the composition of
a score, such as a material or segment illustration or the final score itself,
likely requires a corresponding score-specific stylesheet containing the
typographic overrides and LilyPond context definitions pertinent to that score.
These stylesheets reside in the top-level \texttt{stylesheets/} directory.
Scores composed with Abjad and Consort and typeset with LilyPond and LaTeX
involve potentially many source files: LilyPond sources for the musical
content, yet more LilyPond sources for concatenating and styling that content,
LaTeX sources for cover pages, prefaces and performance notes, and still more
LaTeX sources for concatenating the PDFs created while typesetting various
other sources. These source files, in their various stages of typesetting,
occupy the \texttt{build/} directory. Finally, the finished documents, ready to
be delivered to ensembles, occupy the \texttt{distribution/} directory.

\subsection{Makers}
\label{ssec:makers}

Each score's \texttt{makers/} directory houses classes specific to that score.
In the case of my three \emph{Invisible Cities} scores, this always comprises a
subclass of Consort's \texttt{SegmentMaker} and \texttt{ScoreTemplate} classes.
The segment-maker subclasses effectively pre-load common information about the
score, such as what time signatures to permit by default or what the
end-of-score markup should look like. They may also define a considerable
amount of additional score post-processing, as in the case of
\emph{Armilla}, where many passes of voice copying were required to create the
typography for the bowing staves. A score's score template necessarily defines
the instrumentation and structure of the score layout itself. As none of the
scores in this dissertation make use of common instrumentations, each required
that a completely new score template be defined.

Any other class definitions required by the score package should also be placed
into the \texttt{makers/} directory. For example, \emph{Plague Water}, whose
directory structure is effectively identical to the \emph{Invisible Cities}
series but whose composition model both predated and heavily informed the
development of Consort, houses nearly thirty separate class definitions in its
\texttt{makers/} directory.

\subsection{Material packages}
\label{ssec:material-packages}

Materials represent \emph{out-of-time} musical objects, such as pitch
collections, rhythm-makers, and even fully-configured music specifiers, which
may appear at some point in the time-line of a piece. They are implemented as
importable Python packages, grouped flatly into the \texttt{materials/}
directory, itself a Python package due to the presence of an initializer file.

\begin{figure}[h!]
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\dirtree{%
.1  materials/.
    .2  \_\_init\_\_.py\DTcomment{
        The subpackage initializer.
        }.
    .2  abbreviations/\DTcomment{
        A material package.
        }.
    .2  dense\_timespan\_maker/\DTcomment{
        Another material package.
        }.
    .2  guitar\_agitato\_music\_specifier/\DTcomment{
        Yet another material package.
        }.
    .2  guitar\_strummed\_music\_specifier/.
    .2  guitar\_tremolo\_music\_specifier/.
    .2  guitar\_undulation\_tremolo\_music\_specifier/.
    .2  percussion\_bamboo\_windchimes\_music\_specifier/.
    .2  percussion\_crotales\_flash\_music\_specifier/.
    .2  percussion\_crotales\_interruption\_music\_specifier/.
    .2  ....
    .2  ...\DTcomment{
        Many more material packages.
        }.
}
\end{singlespacing}
\caption{Overview of \emph{Ersilia}'s \texttt{materials/} directory.}
\end{figure}

Each material package contains at the least its own initializer as well as
\texttt{definition.py} file containing Python code which defines or configures
that material. Crucially, the actual code object expressed in that
definition.py should be named after the material package itself. This
simplifies the Python import process as simple importing utilities can be
written to iterate over every directory within the \texttt{materials/}
directory and produce corresponding Python import statements of the form
\mintinline{python}{from my_material.definition import my_material}.

\begin{figure}[h!]
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\dirtree{%
.1  guitar\_tremolo\_music\_specifier/.
    .2  \_\_init\_\_.py\DTcomment{
        The material package's Python initializer.
        }.
    .2  definition.py\DTcomment{
        The material's definition file.
        }.
    .2  illustration.ly\DTcomment{
        The material illustration's LilyPond source.
        }.
    .2  illustration.pdf\DTcomment{
        The material's rendered illustration.
        }.
}
\end{singlespacing}
\caption{Directory listing of \emph{Ersilia}'s
\texttt{guitar\_tremolo\_music\_specifier} material package.}
\end{figure}

Materials, depending on the specific \emph{type} of material, can be
illustrated. That is to say, if the class housed in the material definition
file implements an \texttt{\_\_illustrate\_\_()} method -- described in
\autoref{sec:representing-objects} --, it can be illustrated. Any generated
LilyPond illustration source and PDF output is stored in the material package
alongside the definition module. The means by which those illustration files
come to reside there is elaborated on in
\autoref{ssec:illustrating-and-persisting-segments}.

\subsection{Segment packages}
\label{ssec:segment-packages}

Segments, like materials, are implemented as Python packages, grouped together
into the top-level \texttt{segments/} directory. They can be imported, they
each have an initializer, and they each have a definition module containing the
definition of that segment's segment-maker. As Consort's segment-maker class is
illustrable, each segment package eventually houses that segment's illustration
LilyPond sources and output PDFs.

\begin{figure}[h!]
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\dirtree{%
.1  segments/.
    .2  \_\_init\_\_.py\DTcomment{
        The subpackage initializer.
        }.
    .2  \_\_metadata\_\_.py\DTcomment{
        Metadata about the order of segments in the score.
        }.
    .2  chemish/\DTcomment{
        A segment package.
        }.
        .3  \_\_init\_\_.py\DTcomment{
            The segment package's Python initializer.
            }.
        .3  \_\_metadata\_\_.py\DTcomment{
            Auto-generated metadata about this score segment.
            }.
        .3  definition.py\DTcomment{
            The segment's definition file, containing a configured
            segment-maker.
            }.
        .3  illustration.ly\DTcomment{
            The segment illustration's LilyPond source.
            }.
        .3  illustration.pdf\DTcomment{
            The segment's rendered illustration.
            }.
    .2  cut\_1/\DTcomment{
        Another segment package.
        }.
        .3  ....
    .2  komokome/\DTcomment{
        Another segment package.
        }.
        .3  ....
    .2  cut\_2/\DTcomment{
        Another segment package.
        }.
        .3  ....
    .2  sort/\DTcomment{
        Yet another segment package.
        }.
        .3  ....
}
\end{singlespacing}
\caption{Overview of \emph{Ersilia}'s \texttt{segments/} directory.}
\end{figure}

Each segment subpackage may also house a \texttt{\_\_metadata\_\_.py}
module, which stores information about that segment such as the number of
measures it contains, the final time signature and tempo, and so forth. This
information is generated automatically during the segment-maker's
interpretation, and allows other segment-makers in other segment packages to
draw conclusions about their own segment's context in the full score without
requiring the re-interpretation of any other segments. Like the illustration
sources, these are discussed in more depth in
\autoref{ssec:illustrating-and-persisting-segments}.

A \texttt{\_\_metadata\_\_.py} module sibling to each segment package simply
defines the order of segments. For example, the order of segments in
\emph{Ersilia} is \texttt{komokome}, \texttt{cut\_1}, \texttt{sort},
\texttt{cut\_2}, then \texttt{chemish}. Such an order must be declared
explicitly as it cannot be ascertained from the lexical ordering of the names
of the segment packages. The \texttt{segments/}-local metadata module allows
for such an explicit ordering.

\subsection{The \texttt{stylesheets/} directory}
\label{ssec:the-stylesheets-directory}

The \texttt{stylesheets/} directory consists of LilyPond files containing
typographic overrides, context definitions, document header markup, page layout
configuration and Scheme function definitions. The file \texttt{stylesheet.ily}
represents the primary stylesheet for the entire score, and contains most of
the typographic customization. However, LilyPond stylesheets can
\emph{cascade}: multiple stylesheets can be included into the same master score
file with definitions in subsequently included stylesheets overriding those in
the earlier. Likewise, stylesheets -- because they are simply LilyPond files --
can be included directly into one another.

For example, in \emph{Ersilia}, the master stylesheet file
\texttt{stylesheet.ily} directly includes Scheme definitions from the
file \texttt{scheme.ily}. That master stylesheet is included into the
interpreted LilyPond source of every segment. However, segments beyond the
first also include the stylesheet file \texttt{nonfirst-segment.ily} which
suppresses the appearance of titles and other headers at the top of those
segment illustrations.

\begin{figure}[h!]
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\dirtree{%
.1  stylesheets/.
    .2  nonfirst-segment.ily\DTcomment{
        Style information for segments after the first segment.
        }.
    .2  parts-landscape.ily\DTcomment{
        Style information for landscape-orientation parts.
        }.
    .2  parts-portrait.ily\DTcomment{
        Style information for portrait-orientation parts.
        }.
    .2  scheme.ily\DTcomment{
        LilyPond Scheme commands to be included in the primary stylesheet.
        }.
    .2  stylesheet.ily\DTcomment{
        The primary stylesheet.
        }.
}
\end{singlespacing}
\caption{
Directory listing of \emph{Ersilia}'s \texttt{stylesheets/} directory.
}
\end{figure}

Because LilyPond supports the inclusion of one LilyPond source file into
another, it is possible to define the musical contents of a work in one source
file and collect global typographic overrides into another. This is the
approach I have taken, out of necessity, when building scores with Abjad and
Consort. It is certainly possible to define every one of the typographic
overrides found in \texttt{stylesheet.ily} in Abjad via its top-level
\texttt{override()} and \texttt{set\_()} functions. However, typesetting the
illustration source of a segment in LilyPond generally takes less time than for
that segment to be interpreted in Python. By separating out typographic
overwrites from the musical \enquote{content} it becomes easier to iterate over
refining those overrides by simply adjusting the stylesheet by hand and
recompiling the already-interpreted segment illustration sources.

\subsection{The \texttt{build/} directory}
\label{ssec:the-build-directory}

The \texttt{build/} directory holds source files pertinent to building scores
and parts, along within any component documents, including front and back
covers, prefaces or performance notes. The contents of the \texttt{build/}
directory are organized into \emph{document targets} and \emph{sources}. Each
document target subdirectory consists of source files for producing scores and
parts in a particular format, such as tabloid or A4 paper, or for a particular
performance or language translation. Sources consist of any LilyPond and LaTeX
files containing content to be included into document targets, such as segment
illustration LilyPond sources, LilyPond stylesheets or LaTeX includes -- housed
in \texttt{assets/} -- containing blocks of prose to be flowed into a preface.

\begin{figure}[h!]
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\dirtree{%
.1  build/.
    .2  11x17-landscape/\DTcomment{
        A document build target directory.
        }.
        .3  ....
    .2  11x17-portrait/\DTcomment{
        Another document build target directory.
        }.
        .3  ....
    .2  assets/\DTcomment{
        LaTeX files to be included into each preface layout.
        }.
        .3  calvino.tex.
        .3  instrumentation.tex.
        .3  leguin.tex.
        .3  performance-notes.tex.
    .2  legal-landscape/\DTcomment{
        Another document build target directory.
        }.
        .3  ....
    .2  legal-portrait/\DTcomment{
        Yet another document build target directory.
        }.
        .3  ....
    .2  parts.ily\DTcomment{
        A LilyPond include file for generating parts.
        }.
    .2  segments/\DTcomment{
        Segment illustration LilyPond sources.
        }.
        .3  chemish.ily.
        .3  cut-1.ily.
        .3  cut-2.ily.
        .3  komokome.ily.
        .3  sort.ily.
    .2  segments.ily\DTcomment{
        A LilyPond include file giving the order of the segments to
        concatenate.
        }.
}
\end{singlespacing}
\caption{Overview of \emph{Ersilia}'s \texttt{build/} directory.}
\end{figure}

The file \texttt{parts.ily}, discussed in \autoref{ssec:part-extraction},
defines LilyPond commands for outputting parts. The file \texttt{segments.ily}
defines -- in LilyPond syntax -- the order in which the segment illustration
sources, collected in the \texttt{segments/} subdirectory of the
\texttt{build/} directory, are to be concatenated.

\begin{figure}[h!]
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\dirtree{%
.1  11x17-landscape/\DTcomment{
    A build target directory.
    }.
    .2  Makefile\DTcomment{
        A Makefile for GNU \texttt{make} affords various build tasks.
        }.
    .2  back-cover.pdf\DTcomment{
        PDF output of the back cover LaTeX source.
        }.
    .2  back-cover.tex\DTcomment{
        LaTeX source for the back cover.
        }.
    .2  front-cover.pdf\DTcomment{
        PDF output of the front cover LaTeX source.
        }.
    .2  front-cover.tex\DTcomment{
        LaTeX source for the back cover.
        }.
    .2  music.ly\DTcomment{
        LilyPond source for the concatenated score segments.
        }.
    .2  music.pdf\DTcomment{.
        PDF output for the concatenated score segments LilyPond source.
        }.
    .2  parts.ly\DTcomment{
        LilyPond source for generating individual parts PDFs.
        }.
    .2  preface.pdf\DTcomment{
        PDF output for the preface LaTeX source.
        }.
    .2  preface.tex\DTcomment{
        LaTeX source for the preface.
        }.
    .2  score.pdf\DTcomment{
        PDF output of the complete score LaTeX source.
        }.
    .2  score.tex\DTcomment{
        LaTeX source for the complete score.
        }.
}
\end{singlespacing}
\caption{Directory listing of a document build target in \emph{Ersilia}.}
\end{figure}

Each document target directory consists of a similar collection of files: LaTeX
sources for the front cover, back cover, and preface, LilyPond sources for the
musical content of the score itself and parts, and a master LaTeX source which
combines covers, the preface and the music into a single score PDF. The
LilyPond \texttt{music.ily} contains \texttt{\textbackslash{}include}
statements which pull in the \texttt{segments.ily} file from the
\texttt{build/} directory as well as the score's main LilyPond stylesheet from
the top-level \texttt{stylesheets} directory.

\subsection{The \texttt{etc/} and \texttt{distribution/} directories}
\label{ssec:the-etc-and-distribution-directories}

The \texttt{etc/} and \texttt{distribution/} directories are perhaps the
simplest. The former holds any notes, plans or to-do lists pertinent to the
compositional process of the score while the latter collects completed scores
and parts for each document target from the \texttt{build/} directory.

\subsection{The \texttt{test/} directory}
\label{ssec:the-test-directory}

Finally, the \texttt{test/} directory contains Python modules defining
parameterized tests which attempt to import each material package and then
import and illustrate each segment in the entire score. The test modules are
run by the \texttt{pytest} testing tool.

\begin{figure}[h!]
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\dirtree{%
.1  test/.
.2  test\_materials.py\DTcomment{
    Parameterized tests for validating integrity of each material package.
    }.
.2  test\_segments.py\DTcomment{
    Parameterized tests for validating integrity of each segment package.
    }.
}
\end{singlespacing}
\caption{Parameterized tests.}
\end{figure}

Note that these tests do not attempt to guarantee that a particular segment
produces some score exactly matching a target, but simply that the
segment-maker manages to interpret without failure, and that LilyPond manages
to typeset the resulting source without error.

\subsection{Python packaging}
\label{ssec:python-packaging}

Each score package should also be properly \emph{packaged} according to Python
standards so that it can be installed on other systems. This might strike
composers as an unmotivated suggestion. Why should one structure their private
score such that it can be used by others? Making a score installable in this
way affords a number of conveniences related to testing. Installable scores can
be tested in \emph{virtual environments} -- a common Python practice -- by
automated test runners like \texttt{tox} or run on remote
continuous-integration testing services such as Travis-CI. Both of these tools
are addressed in \autoref{ssec:testing}.

\begin{figure}[h!]
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\dirtree{%
.1  ersilia/.
    .2 .git/\DTcomment{
        The Git repository history.
        }.
    .2 .gitignore\DTcomment{
        File patterns to be ignored by the Git version control system.
        }.
    .2 .travis.yml\DTcomment{
        The Travis-CI build configuration script.
        }.
    .2 README.md\DTcomment{
        A MarkDown text file containing introductory information about the
        score package.
        }.
    .2 ersilia/\DTcomment{
        The score package itself.
        }.
    .2 requirements.txt\DTcomment{
        Dependency information, for use when installing on Travis-CI.
        }.
    .2 setup.cfg\DTcomment{
        Python packaging configuration.
        }.
    .2 setup.py\DTcomment{
        The Python package installation script.
        }.
    .2 tox.ini\DTcomment{
        Configuration for the \texttt{tox} automated testing tool.
        }.
}
\end{singlespacing}
\caption{Overview of \emph{Ersilia}'s Python packaging assets.}
\end{figure}

For those who wish to make both their scores and code completely public -- as I
have -- installation affordances are simply necessary for letting others
explore the code as quickly and easily as possible.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Document preparation work-flow}
\label{sec:document-preparation-work-flow}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

As with working with Abjad in the simplest case, the work flow of composing and
preparing scores with Consort continues to revolve around the cycle of defining
musical structures in text, illustrating that music visually, then refining the
textual definitions. Unlike creating simple musical examples at the
command-line, as demonstrated throughout this dissertation -- especially in
\autoref{chap:a-model-of-notation} --, managing a large-scale score requires
considerably more tools and many more file-system assets. The following
sections discuss some of the additional complexities involved in organizing and
typesetting a large-scale score computationally.

\subsection{Build tools}
\label{ssec:build-tools}

I make use of a variety of custom build tools for managing assets within a
score package which will not be discussed here in any detail as they are still
rather provisional. These tools simplify various tasks such as creating new
segment and material packages, executing segment definition modules in order to
illustrate the contained segment-makers, comparing new illustration LilyPond
sources and PDF outputs against previously rendered ones, and collecting and
massaging segment LilyPond sources from each segment package into the build
directory for document preparation. Simply put, build tools for score packages
streamline the problems of moving files and folders into their appropriate
locations, executing Python modules, persisting code objects to disk and
cleaning up after any transient files.

\subsection{Illustrating \& persisting segments}
\label{ssec:illustrating-and-persisting-segments}

All of the examples of object illustration demonstrated throughout this
dissertation involve illustrating objects in a live Python interpreter session.
However, in order to construct a score made of potentially many concatenated
segment illustrations, those illustrations must be persisted to disk. While
persistence can certainly also be handled in a live interpreter session,
by-hand illustration and persistence are both error-prone and tedious. One way
to simplify the task of illustrating segments and persisting their
illustrations to disk is by adding executable code to the end of each segment
definition module. When run by Python as a script, those segment definition
modules can be instructed to illustrate  their segment makers and persist the
resulting illustration and segment metadata to disk in the same directory as
the segment definition module. Consider the following code:

\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
import os
import consort
from abjad import persist


segment_maker = consort.SegmentMaker(
    desired_duration_in_seconds=4,
    )


if __name__ == '__main__':
    illustration, metadata = segment_maker()
    directory_path = os.path.dirname(os.path.abspath(__file__))
    illustration_pdf_file_path = os.path.join(directory_path, 'illustration.pdf')
    metadata_file_path = os.path.join(directory_path, '__metadata__.py')
    persist(illustration).as_pdf(
        pdf_file_path=illustration_pdf_file_path,
        candidacy=True,
        )
    persist(metadata).as_module(
        module_file_path=metadata_file_path,
        object_name='metadata',
        )
\end{minted}
\end{singlespacing}

\noindent When run by Python as a script -- via a command like
\mintinline{bash}{python my_segment_definition.py} -- rather than imported, the
code in the segment definition module executes in the module namespace
\texttt{\_\_main\_\_}. The conditional \mintinline{python}{if __name__ ==
'__main__':} guarantees then that the suite beneath that conditional executes
if and only if the current module name is \texttt{\_\_main\_\_}, again because
the segment definition module was run as a script. This crucially prevents
illustration code from running when the definition module is simply imported
rather than executed. However, if the suite underneath the conditional
\emph{does} execute, it first calls the previously defined segment-maker. That
segment-maker then returns both the illustration and a segment metadata
dictionary. Next, file paths relative to the segment module's file path are
determined in order to persist the just-created illustration and metadata. The
global variable \texttt{\_\_file\_\_} in any Python code module gives the
location of that module on the file system, from which that module's directory
can be determined. Finally, calls to Abjad's top-level \texttt{persist()}
function against the illustration and metadata expose persistence agent
instances which afford persisting each object to disk as a
LilyPond file and Python module respectively. The \texttt{candidacy=True}
keyword argument to \mintinline{python}{persist{illustration}.as_pdf(...)}
checks whether a PDF already exists and only overwrites if the new would
differ.

As mentioned in \autoref{ssec:build-tools}, I make use of custom build tools
for my scores which afford a more elaborate version of the illustration and
persistence task outlined above. One such elaboration passes the metadata for
the previous segment -- if such metadata exists -- to the current
segment-maker's \texttt{\_\_call\_\_()} method. Recall that the previous
segment can be determined by consulting the \texttt{\_\_metadata\_\_.py} module
sibling to the segment packages, as outlined in
\autoref{ssec:segment-packages}. A modified version of the current
segment-maker's metadata is also passed as an argument at call-time, and
includes both a count of the total number of segments and the current segment's
index within those segments. Such metadata allows a segment-maker to
automatically determine if it is the first or last of all segments, as well as
to take into account any pertinent settings effective at the end of the
previous segment, such as the previous segment's ending tempo or time
signature.

Note too that persisting material illustrations can be handled in a nearly
identical fashion. And unlike segments, they do not need to even optionally
consult or persist metadata.

\subsection{Collecting and concatenating segment illustrations}
\label{ssec:collecting-and-concatenating-segment-illustrations}

The model of composition afforded by Consort assumes scores consist of multiple
segments, each of which is persisted as a LilyPond score context based on an
identical score template. This assumption relies on LilyPond's ability to
concatenate like-named contexts. Consider the following LilyPond expression:

\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{tex}
{
    \context Score = "The Score" <<
        \context Staff = "Staff A" { c'1 d'1 }
        \context Staff = "Staff B" { c'1 b1 }
    >>
    \context Score = "The Score" <<
        \context Staff = "Staff A" { e'1 f'1 }
        \context Staff = "Staff B" { a1 g1 }
    >>
    \context Score = "The Score" <<
        \context Staff = "Staff A" { g'1 a'1 }
        \context Staff = "Staff B" { f1 e1 }
    >>
}
\end{minted}
\end{singlespacing}

\noindent The above example contains three like-named scores grouped by braces
into a single music expression. Because the scores have identical names and the
staff contexts within them are also identically named, LilyPond concatenates
each like-named context in each score together. The resulting music expression
is equivalent to the following:

\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{tex}
\context Score = "The Score" <<
    \context Staff = "Staff A" { c'1 d'1 e'1 f'1 g'1 a'1 }
    \context Staff = "Staff B" { c'1 b1 a1 g1 f1 e1 }
>>
\end{minted}
\end{singlespacing}

\noindent An identical context concatenation process is used to fuse the scores
defined in each segment's illustration file into a single music expression.
First however, those segment illustrations must be collected into the
\texttt{segments/} directory within the \texttt{build/} directory and their
sources massaged to permit concatenation.

\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{tex}
\version "2.19.17"
\language "english"

#(ly:set-option 'relative-includes #t)

\include "../../stylesheets/stylesheet.ily"

\score {
    \context Score = "The Score" <<
        ...
    >>
}
\end{minted}
\end{singlespacing}

\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{tex}
\context Score = "The Score" <<
    ...
>>
\end{minted}
\end{singlespacing}

LilyPond concatenates contexts.

.ily vs .ly: just a convention. .ly can be compiled by itself, .ily either has
no music, or requires includes which are not present.

Copy segments illustration files out of each segment package into
build/segments.

Rename each segment from illustration.ly to segment-package-name.ily

Trim every except the \texttt{\textbackslash{}context} block.

Trimming removes the unnecessary header and styling information from each
collected segment illustration and allows LilyPond to concatenate the score
contexts together into a single score structure.

\begin{singlespacing}
\vspace{-0.5\baselineskip}
\inputminted{tex}{../../Documents/Scores/ersilia/ersilia/build/segments.ily}
\end{singlespacing}

\subsection{Organizing and typesetting LaTeX assets}
\label{ssec:organizing-and-typesetting-latex-assets}

what latex assets does each document target require?

Front-cover, back-cover, performance-notes, music.

use a master score.tex to include all of the document target assets together.
Latex can merge pdfs easily, so just do that.

\begin{figure}[h!]
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\inputminted{tex}{../../Documents/Scores/ersilia/ersilia/build/11x17-portrait/ersilia-11x17-portrait-score.tex}
\end{singlespacing}
\vspace{-0.5\baselineskip}
\caption{A score LaTeX source in \emph{Ersilia}.}
\end{figure}

Also, collect all preface and performance note prose into build/assets/ as
include-able TeX files. Use TPGrid and input to flow those assets into
different layouts.

Undoubtedly more seasoned LaTeX users have more sophisticated ways of dealing
with these situations, but this works perfectly well, is easy to understand and
also pithy.

\begin{singlespacing}
\vspace{-0.5\baselineskip}
\inputminted[
    firstline=18,
]{tex}{../../Documents/Scores/ersilia/ersilia/build/11x17-landscape/ersilia-11x17-landscape-preface.tex}
\end{singlespacing}

\begin{singlespacing}
\vspace{-0.5\baselineskip}
\inputminted[
    firstline=18,
]{tex}{../../Documents/Scores/ersilia/ersilia/build/legal-portrait/ersilia-legal-portrait-preface.tex}
\end{singlespacing}

\subsection{Part extraction}
\label{ssec:part-extraction}

When working with LilyPond and Abjad, part extraction relies on two fairly
simple LilyPond mechanisms: \emph{tags} and \emph{book blocks}. In LilyPond,
any music expression can be labeled with a tag, a string or symbol which
identifies that music expression. Later, music expressions can be filtered to
either remove or solely preserve any expression with a given tag. Consider the
following pseudo-score, consisting of a score containing three staves and a
time signature context:

\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{tex}
\keepWithTag #'(time B)
\new Score <<
    \tag #'time \new TimeSignatureContext = "Time Signature Context" { ... }
    \tag #'A \new Staff = "Staff A" { ... }
    \tag #'B \new Staff = "Staff B" { ... }
    \tag #'C \new Staff = "Staff C" { ... }
>>
\end{minted}
\end{singlespacing}

\noindent Each context contained by the \texttt{Score} context -- the three
staves and the time signature context -- is tagged via a LilyPond
\texttt{\textbackslash{}tag} command, associating that context's music
expression with the tag's symbol. The command preceding the score itself --
\texttt{\textbackslash{}keepWithTag \#\'(time B)} -- indicates that the score
should filter out any tagged music expression which do not belong to the list
of expressions \texttt{\#\'(time B)}. That is, the score should omit the two
staves tagged \texttt{A} and \texttt{C}, effectively producing a score
structured like so:

\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{tex}
\new Score <<
    \new TimeSignatureContext = "Time Signature Context" { ... }
    \new Staff = "Staff B" { ... }
>>
\end{minted}
\end{singlespacing}

\noindent This tagging technique is used in every score developed with Consort.
Each score's score template includes tag commands labeling both the time
signature context -- which must appear both in the full score and all parts as
it contains time signature, tempo and rehearsal mark information -- as well as
all inner contexts necessary for individual performers. By constructing the
appropriate \texttt{\textbackslash{}keepWithTag} commands, music expressions
representing each performer's part can be constructed easily.
Note the use of \texttt{\textbackslash{}tag} commands throughout the structure
of \emph{Armilla}'s score:

\begin{singlespacing}
\vspace{-0.5\baselineskip}
\inputminted[
    gobble=8,
    firstline=19,
    lastline=71,
]{tex}{../../Documents/Scores/armilla/armilla/makers/ArmillaScoreTemplate.py}
\end{singlespacing}

\noindent The time signature context receives its own tag, and the staff groups
wrapping each performer's bowing and fingering staves are also tagged
appropriately.

While tagging allows for extracting parts as music expressions, it does not yet
result in actual documents for each part. LilyPond's book block structure,
combined with the \texttt{\textbackslash{}bookOutputSuffix} command, provide a
concise mechanism for generating multiple output PDFs from a single LilyPond
input file. As demonstrated throughout this document, LilyPond files are
structured into blocks -- context blocks, score blocks, header and paper
blocks, and so forth. The highest level block is a
\texttt{\textbackslash{}book} block. Somewhat like parts in LaTeX, book blocks
separate content from one another by page breaks. Score blocks contained in
separate book blocks are guaranteed to never appear on the same page together.
Furthermore, by specifying a book output suffix within each book block,
LilyPond will not simply separate that book blocks's content by page breaks but
will actually output a wholly separate PDF, whose filename is suffixed with
that book output suffix.

Consider this excerpt from \emph{Ersilia}'s \texttt{parts.ily} file:

\begin{singlespacing}
\vspace{-0.5\baselineskip}
\inputminted[
    lastline=23,
]{tex}{../../Documents/Scores/ersilia/ersilia/build/parts.ily}
\end{singlespacing}

\noindent This file contains one book block per instrument. Each book block
specifies an output suffix pertinent to a specific performer in the ensemble.
Each book block also contains a score block whose contents consist entirely of
an include statement -- pointing at \texttt{segments.ily}, which concatenates
all score segments into a single music expression -- wrapped in a
\texttt{\textbackslash{}keepWithTag} command which filters out everything
except that performer's musical content and the global time signature context.

With these techniques in mind, a complete parts-extraction file would likely
look the following, from \emph{Ersilia}:

\begin{singlespacing}
\vspace{-0.5\baselineskip}
\inputminted[
    firstline=3,
]{tex}{../../Documents/Scores/ersilia/ersilia/build/11x17-landscape/ersilia-11x17-landscape-parts.ly}
\end{singlespacing}

\noindent Beyond the initial LilyPond boilerplate of specifying a LilyPond
version and pitch-name input language, basically consists of an include for the
global stylesheet, a page-layout command, an include for a stylesheet for
landscape parts and finally an include for the global parts definition file,
\texttt{parts.ily}. When interpreted by LilyPond, the above will generate one
11x17 landscape PDF per book block defined in \texttt{parts.ily}.

Note that there are methods by which composers can generate parts in
LilyPond. Most LilyPond users who work strictly with LilyPond, writing
\enquote{by hand}, would likely places each of the instrumental parts in the
score into a separate file or variable. Those parts would then be combined into
either the full score or a part for a single player as necessary. Because
Consort produces a single score, complete with all parts joined into a single
expression, filtering must be used to \enquote{strip} the score down to the
desired musical elements.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Project maintenance}
\label{sec:project-maintenance}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

foo

\subsection{Testing}
\label{ssec:testing}

Parameterized tests which run each segment and import each material. Why do
this? It's a simple entry point to check the stability of your entire score as
you work. If your score depends on another project -- e.g. Abjad or Consort --
where that project is also being actively developed testing lets you check that
your project continues to interoperate.

Continuous integration testing via Travis-CI or similar service. Run your tests
on a remote server in a virtual machine. This guarantees that your score can be
installed on a fresh machine which is also probably of a different
architecture. Also guarantees that any other project your score depends on,
e.g. Abjad or any of Abjad's dependencies, can also be installed and used in a
fresh environment. Why do things in a fresh environment? Our local workspace
can become a blind-spot to us.

\subsection{Version control}
\label{ssec:version-control}

This is the most important aspect of working computationally. If I can impart
\emph{any} advice to anyone working with computers, even if they never program
ever, it would be to learn how to use version control.