%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Practicalities: project management}
\label{chap:practicalities}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Core concepts:

Version control. Always be in control of the changes in your project.
Text-based development strongly supports this manner of working.
Tagging allows you to pinpoint versions of the work which correspond to
premiers or performances. You always know what's different about one version
versus another version. Branching allows you to try out new pathways without
worry of clobbering your work. Version control is also concise - no more
cluttering up your workspace with multiple directories. You can't compare those
- it's a cognitive burden.

Automated typesetting. Separate content from layout. This extends to both
textual document components and musical document components. Affords easy part
extraction. Cascading stylesheets.

Structured code. Make a clear distinction between classes, materials, and
segments. Segments represent in-time composition. Materials represent
out-of-time composition. Makers represent abstract processes or utilities which
afford the creation of materials and segments.

Testing. Automate proofreading. Guarantee computationally-afforded score
projects continue to function properly over time, ensuring the longevity of the
code-base.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Score directory layout}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

A structured approach to arranging one's compositional workspace clarifies both
the way one thinks about the act of composing, as well as the more menial
workflows of document preparation which are inseparable from score-based
composition. Each of the \emph{Invisible Cities} scores included in part II of
this dissertation are implemented as Python packages extending Abjad model of
notation and Consort's model of composition. Likewise, each \emph{Invisible
Cities} score package is structured into a nearly identical arrange of eight
top-level directories, each with a clearly delineated purpose and substructure.

\begin{figure}[h!]
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\noindent%
\dirtree{%
.1  ersilia/.
    .2  \_\_init\_\_.py\DTcomment{
        The score package Python initializer.
        }.
    .2  build/\DTcomment{
        LilyPond and LaTeX files for building document targets.
        }.
    .2  distribution/\DTcomment{
        Finished PDFs for performers and conductors.
        }.
    .2  etc/\DTcomment{
        Notes, to-do lists and plans.
        }.
    .2  makers/\DTcomment{
        Customized segment-makers, score templates and other classes.
        }.
    .2  materials/\DTcomment{
        Materials used to configure segment-makers. 
        }.
    .2  segments/\DTcomment{
        Configured segment-makers and their illustrations.
        }.
    .2  stylesheets/\DTcomment{
        LilyPond stylesheets.
        }.
    .2  test/\DTcomment{
        The score package test suite.
        }.
}
\end{singlespacing}
\caption{\emph{Ersilia}'s top-level directory layout.}
\end{figure}

\noindent The top-level directories named above house specific collections of
assets used during composition or document preparation.

Consort very broadly groups the objects used during composition into
\emph{makers}, \emph{materials} and \emph{segments}. Makers comprise any
classes used during composition, such as segment-maker, pitch-handler or music
specifier classes. but not their instances. Materials comprise instances of
classes representing \emph{out-of-time} musical constructs, such as pitch
segments or music specifiers. Segments comprise configured instances of a
segment-maker class, and maquette together previously-defined materials
\emph{in-time} into a musical chronology. Each of these three categories of
objects has its own directory in the directory structure outlined here:
\texttt{makers/}, \texttt{materials/} and \texttt{segments/}.

Likewise, the document preparation process involves a number of different types
of assets and tasks. Any LilyPond-typeset PDF created during the composition of
a score, such as a material or segment illustration or the final score itself,
likely requires a corresponding score-specific stylesheet containing the
typographic overrides and LilyPond context definitions pertinent to that score.
These stylesheets reside in the top-level \texttt{stylesheets/} directory.
Scores composed with Abjad and Consort and typeset with LilyPond and LaTeX
involve potentially many source files: LilyPond sources for the musical
content, yet more LilyPond sources for concatenating and styling that content,
LaTeX sources for cover pages, prefaces and performance notes, and still more
LaTeX sources for concatenating the PDFs created while typesetting various
other sources. These source files, in their various stages of typesetting,
occupy the \texttt{build/} directory. Finally, the finished documents, ready to
be delivered to ensembles, occupy the \texttt{distribution/} directory.

\subsection{Makers}
\label{ssec:makers}

Each score's \texttt{makers/} directory houses classes specific to that score.
In the case of my three \emph{Invisible Cities} scores, this always comprises a
subclass of Consort's \texttt{SegmentMaker} and \texttt{ScoreTemplate} classes.
The segment-maker subclasses effectively pre-load common information about the
score, such as what time signatures to permit or what the end-of-score markup
should look like. They may also define a considerable amount of additional
score post-processing, such as in the case of \emph{Armilla}, where many passes
of voice copying were required to create the typography for the bowing staves.
The score templates necessarily define the instrumentation and structure of the
score layout itself. As none of the scores in this dissertation make use of
common instrumentations, each required that a completely new score template be
defined.

Any other class definitions required by the score package should also be placed
into the \texttt{makers/} directory. For example, \emph{Plague Water}, whose
directory structure is effectively identical to the \emph{Invisible Cities}
series but whose composition model predates and heavily informed the
development of Consort , houses nearly thirty separate class definitions in its
\texttt{makers/} directory.

\subsection{Material packages}
\label{ssec:material-packages}

Materials are implemented as Python packages.

They have an initializer and a
definition file.

Of course, those could be conflated, but I choose not to out
of habit.


Materials are out-of-time. Pitch collections, rhythm-makers, music specifiers.
Compositional and musical objects which may appear at some point during a
piece.

Materials, depending on the specific kind of material, can be illustrated. If
the class housed in the material definition file implements \_\_illustrate\_\_,
it can be illustrated.

Materials can be imported.

\begin{figure}[h!]
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\dirtree{%
.1  materials/.
    .2  \_\_init\_\_.py\DTcomment{
        The subpackage initializer.
        }.
    .2  abbreviations/\DTcomment{
        A material package.
        }.
    .2  dense\_timespan\_maker/\DTcomment{
        Another material package.
        }.
    .2  guitar\_agitato\_music\_specifier/\DTcomment{
        Yet another material package.
        }.
    .2  guitar\_strummed\_music\_specifier/.
    .2  guitar\_tremolo\_music\_specifier/.
    .2  guitar\_undulation\_tremolo\_music\_specifier/.
    .2  percussion\_bamboo\_windchimes\_music\_specifier/.
    .2  percussion\_crotales\_flash\_music\_specifier/.
    .2  percussion\_crotales\_interruption\_music\_specifier/.
    .2  ....
    .2  ...\DTcomment{
        Many more material packages.
        }.
}
\end{singlespacing}
\caption{Overview of \emph{Ersilia}'s \texttt{materials/} directory.}
\end{figure}

The anatomy of a material package.

\begin{figure}[h!]
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\dirtree{%
.1  guitar\_tremolo\_music\_specifier/.
    .2  \_\_init\_\_.py\DTcomment{
        The material package's Python initializer.
        }.
    .2  definition.py\DTcomment{
        The material's definition file.
        }.
    .2  illustration.ly\DTcomment{
        The material illustration's LilyPond source.
        }.
    .2  illustration.pdf\DTcomment{
        The material's rendered illustration.
        }.
}
\end{singlespacing}
\caption{Directory listing of \emph{Ersilia}'s
\texttt{guitar\_tremolo\_music\_specifier} material package.}
\end{figure}

\subsection{Segment packages}
\label{ssec:segment-packages}

Segments, like materials, are Python packages.

They can be imported. They have an initializer and a definition module. They
can optionally have metadata modules.

A metadata module sibling to each segment package provides ordering
information.

\begin{figure}[h!]
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\dirtree{%
.1  segments/.
    .2  \_\_init\_\_.py\DTcomment{
        The subpackage initializer.        
        }.
    .2  \_\_metadata\_\_.py\DTcomment{
        Metadata about the order of segments in the score.
        }.
    .2  chemish/\DTcomment{
        A segment package.
        }.
        .3  \_\_init\_\_.py\DTcomment{
            The segment package's Python initializer. 
            }.
        .3  \_\_metadata\_\_.py\DTcomment{
            Auto-generated metadata about this score segment.
            }.
        .3  definition.py\DTcomment{
            The segment's definition file, containing a configured
            segment-maker.
            }.
        .3  illustration.ly\DTcomment{
            The segment illustration's LilyPond source.
            }.
        .3  illustration.pdf\DTcomment{
            The segment's rendered illustration.
            }.
    .2  cut\_1/\DTcomment{
        Another segment package.
        }.
        .3  ....
    .2  komokome/\DTcomment{
        Another segment package.
        }.
        .3  ....
    .2  cut\_2/\DTcomment{
        Another segment package.
        }.
        .3  ....
    .2  sort/\DTcomment{
        Yet another segment package.
        }.
        .3  ....
}
\end{singlespacing}
\caption{Overview of \emph{Ersilia}'s \texttt{segments/} directory.}
\end{figure}

\subsection{The \texttt{stylesheets/} directory}
\label{ssec:the-stylesheets-directory}

Stylesheets cascade.

You can use one primary stylesheet and include it into each segment
illustration, as well as into the concatenated segment LilyPond sources that
live in each document target directory in build/.

\begin{figure}[h!]
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\dirtree{%
.1  stylesheets/.
    .2  nonfirst-segment.ily\DTcomment{
        Style information for segments after the first segment.
        }.
    .2  parts-landscape.ily\DTcomment{
        Style information for landscape-orientation parts.
        }.
    .2  parts-portrait.ily\DTcomment{
        Style information for portrait-orientation parts.
        }.
    .2  scheme.ily\DTcomment{
        LilyPond Scheme commands to be included in the primary stylesheet.
        }.
    .2  stylesheet.ily\DTcomment{
        The primary stylesheet.
        }.
}
\end{singlespacing}
\caption{
Directory listing of \emph{Ersilia}'s \texttt{stylesheets/} directory.
}
\end{figure}

\subsection{The \texttt{build/} directory}
\label{ssec:the-build-directory}

XXX

\begin{figure}[h!]
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\dirtree{%
.1  build/.
    .2  11x17-landscape/\DTcomment{
        A document build target directory.
        }.
        .3  ....
    .2  11x17-portrait/\DTcomment{
        Another document build target directory.
        }.
        .3  ....
    .2  assets/\DTcomment{
        LaTeX files to be included into each preface layout.
        }.
        .3  calvino.tex.
        .3  instrumentation.tex.
        .3  leguin.tex.
        .3  performance-notes.tex.
    .2  legal-landscape/\DTcomment{
        Another document build target directory.
        }.
        .3  ....
    .2  legal-portrait/\DTcomment{
        Yet another document build target directory.
        }.
        .3  ....
    .2  parts.ily\DTcomment{
        A LilyPond include file for generating parts.
        }.
    .2  segments/\DTcomment{
        Segment illustration LilyPond sources.
        }.
        .3  chemish.ily.
        .3  cut-1.ily.
        .3  cut-2.ily.
        .3  komokome.ily.
        .3  sort.ily.
    .2  segments.ily\DTcomment{
        A LilyPond include file giving the order of the segments to
        concatenate.
        }.
}
\end{singlespacing}
\caption{Overview of \emph{Ersilia}'s \texttt{build/} directory.}
\end{figure}

XXX

\begin{figure}[h!]
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\dirtree{%
.1  11x17-landscape/\DTcomment{
    A build target directory.
    }.
    .2  Makefile\DTcomment{
        A Makefile for GNU \texttt{make} affords various build tasks.
        }.
    .2  back-cover.pdf\DTcomment{
        PDF output of the back cover LaTeX source.
        }.
    .2  back-cover.tex\DTcomment{
        LaTeX source for the back cover.
        }.
    .2  front-cover.pdf\DTcomment{
        PDF output of the front cover LaTeX source.
        }.
    .2  front-cover.tex\DTcomment{
        LaTeX source for the back cover.
        }.
    .2  music.ly\DTcomment{
        LilyPond source for the concatenated score segments.
        }.
    .2  music.pdf\DTcomment{.
        PDF output for the concatenated score segments LilyPond source. 
        }.
    .2  parts.ly\DTcomment{
        LilyPond source for generating individual parts PDFs.
        }.
    .2  preface.pdf\DTcomment{
        PDF output for the preface LaTeX source.
        }.
    .2  preface.tex\DTcomment{
        LaTeX source for the preface.
        }.
    .2  score.pdf\DTcomment{
        PDF output of the complete score LaTeX source. 
        }.
    .2  score.tex\DTcomment{
        LaTeX source for the complete score.
        }.
}
\end{singlespacing}
\caption{Directory listing of a document build target in \emph{Ersilia}.}
\end{figure}

\subsection{The \texttt{etc/} and \texttt{distribution/} directories}
\label{ssec:the-etc-and-distribution-directories}

Put notes, plans and to-dos about the process of composing into etc/.

Collect finished document targets into distribution/. These should be organized
by gig, and should contain only the files you would need to send to an
ensemble.

\subsection{The \texttt{test/} directory}
\label{ssec:the-test-directory}

XXX

\begin{figure}[h!]
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\dirtree{%
.1  test/.
.2  test\_materials.py\DTcomment{
    Parameterized tests for validating integrity of each material package.
    }.
.2  test\_segments.py\DTcomment{
    Parameterized tests for validating integrity of each segment package.
    }.
}
\end{singlespacing}
\caption{Parameterized tests.}
\end{figure}

\subsection{Python packaging}
\label{ssec:python-packaging}

XXX

\begin{figure}[h!]
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\dirtree{%
.1  ersilia/.
    .2 .git/\DTcomment{
        The Git repository history.
        }.
    .2 .gitignore\DTcomment{
        File patterns to be ignored by the Git version control system.
        }.
    .2 .travis.yml\DTcomment{
        The Travis-CI build configuration script.
        }.
    .2 README.md\DTcomment{
        A MarkDown text file containing introductory information about the
        score package.
        }.
    .2 ersilia/\DTcomment{
        The score package itself.
        }.
    .2 requirements.txt\DTcomment{
        Dependency information, for use when installing on Travis-CI.
        }.
    .2 setup.cfg\DTcomment{
        Packaging information.
        }.
    .2 setup.py\DTcomment{
        A Python install script.
        }.
}
\end{singlespacing}
\caption{Overview of \emph{Ersilia}'s Python packaging assets.}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Document preparation work-flow}
\label{sec:document-preparation-work-flow}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Build tools}
\label{ssec:build-tools}

I make use of a variety of custom build tools for managing assets within a
score package which will not be discussed here in any detail. These tools
simplify various tasks such as creating new segment and material packages,
executing segment definition modules in order to illustrate the contained
segment-makers, comparing new illustration LilyPond sources and PDF outputs
against previously rendered ones, and collecting and massaging segment LilyPond
sources from each segment package into the build directory for document
preparation.

\subsection{Editing}
\label{ssec:editing}

I do everything in text. vim is my primary tool, but any decent text editor
will do. Facility in making mass transformations across files is key - you may
want to rename things that appear in multiple places. searching is important.
syntax highlighting, and easy access to every file in your project and any
project you rely on is key.

\subsection{Illustrating}
\label{ssec:illustrating}

how does illustrating work? you can do it at the command-line by importing a
definition by hand, but this gets tedious.

Write a script that does the illustrating. You can also make each segment
definition file executable.

Segment metadata. Each segment can return not just an illustration but also a
dictionary containing information about the segment it created. What was its
tempo? Did it repeat? How many bars were there? What was the last time
signature used? This metadata dictionary can be persisted to disk just like the
segment's illustration.

Choose the order of the segments and write that into its own metadata python
module. When you illustrate, you can peek at the other segment packages,
examine their metadata and construct a model of pertinent information about
what has happened prior to the current segment under consideration.

\subsection{LilyPond stylesheets}
\label{ssec:lilypond-stylesheets}

Stylesheets cascade.

A master stylesheet describes the overall look-and-feel of the score.

A stylesheet for scheme functions (LilyPond is scriptable, remember?)

A stylesheet for parts.

\subsection{Collecting segment files}
\label{ssec:collecting-segment-files}

LilyPond concatenates contexts.

.ily vs .ly: just a convention. .ly can be compiled by itself, .ily either has
no music, or requires includes which are not present.

Copy segments illustration files out of each segment package into
build/segments.

Rename each segment from illustration.ly to segment-package-name.ily

Trim every except the \texttt{\textbackslash{}context} block.

Trimming removes the unnecessary header and styling information from each
collected segment illustration and allows LilyPond to concatenate the score
contexts together into a single score structure.

\begin{singlespacing}
\vspace{-0.5\baselineskip}
\inputminted{tex}{../../Documents/Scores/ersilia/ersilia/build/segments.ily}
\end{singlespacing}

\subsection{LaTeX assets}
\label{ssec:latex-assets}

what latex assets does each document target require?

Front-cover, back-cover, performance-notes, music.

use a master score.tex to include all of the document target assets together.
Latex can merge pdfs easily, so just do that.

\begin{figure}[h!]
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\inputminted{tex}{../../Documents/Scores/ersilia/ersilia/build/11x17-portrait/ersilia-11x17-portrait-score.tex}
\end{singlespacing}
\vspace{-0.5\baselineskip}
\caption{A score LaTeX source in \emph{Ersilia}.}
\end{figure}

\subsection{Part extraction}
\label{ssec:part-extraction}

Tags. You can use tags in LilyPond to filter out or keep any musical
expression, from a single note to an entire score. By tagging every staff or
staff group with a unique name, you can use LilyPond's tag filtering commands
to generate PDFs containing only selected musical content.

Bookpart blocks. LilyPond can be instructed to build PDFs consisting of
multiple separate scores, appearing on separate pages. For example, hymnals, or
multi-movement works. \enquote{Books} can consist of multiple
\enquote{bookparts} which can themselves consist of multiple scores. You can
construct bookparts such that LilyPond outputs each bookpart as a separate PDF.
This is an ideal way to structure a document to output parts.

\begin{figure}[h!]
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\inputminted[
    lastline=23,
]{tex}{../../Documents/Scores/ersilia/ersilia/build/parts.ily}
\end{singlespacing}
\vspace{-0.5\baselineskip}
\caption{Excerpt from \emph{Ersilia}'s \texttt{parts.ily} parts definition
LilyPond include file.}
\end{figure}

One bookpart per part PDF, with the appropriate tag.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Project maintenance}
\label{sec:project-maintenance}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

foo

\subsection{Testing}
\label{ssec:testing}

Parameterized tests which run each segment and import each material. Why do
this? It's a simple entry point to check the stability of your entire score as
you work. If your score depends on another project -- e.g. Abjad or Consort --
where that project is also being actively developed testing lets you check that
your project continues to interoperate.

Continuous integration testing via Travis-CI or similar service. Run your tests
on a remote server in a virtual machine. This guarantees that your score can be
installed on a fresh machine which is also probably of a different
architecture. Also guarantees that any other project your score depends on,
e.g. Abjad or any of Abjad's dependencies, can also be installed and used in a
fresh environment. Why do things in a fresh environment? Our local workspace
can become a blind-spot to us.

\subsection{Version control}
\label{ssec:version-control}

This is the most important aspect of working computationally. If I can impart
\emph{any} advice to anyone working with computers, even if they never program
ever, it would be to learn how to use version control.