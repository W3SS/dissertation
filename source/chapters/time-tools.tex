%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Tools for modeling time, rhythm and meter}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{comment}
<abjad>[hide=true]
import collections
import consort
</abjad>
\end{comment}

Consort implements a model of composition which relies on a number of
interrelated but distinct approaches to working with musical time. Abjad's
\emph{\index{timespan}} object suggests a \enquote{coarse} approach to musical
time. Timespans represent arbitrary durated events on a timeline, without
respect for score hierarchy or meter. They are well-suited for modeling large
scale phrasing or gestural density structures and can handle overlap,
splitting, stretching and other transformations without requiring any
notational reality. Annotated \index{timespan}s allow composers to position
metadata anywhere on a timeline, much like arranging audio regions in a DAW.
Moreover, every durated object in a score hierarchy can be described as a
\index{timespan}, allowing score components to engage in abstract time
relations. In contrast, notated rhythms, composed of note, rest, tie and tuplet
objects -- among others, provide the most \enquote{fine-grained} approach to
musical time. While incredibly expressive, fully notated rhythms are
potentially complex to create, and must ultimately be anchored in a score
hierarchy. Rhythm maker classes ameliorate the complexity of creating notated
rhythms by providing a high-level interface to the process of rhythmic
generation. Meter coordinates time and rhythm vertically across score
hierarchy, and bridges the coarse and fine stages of rhythmic interpretation.
Meter sequences can be generated from \index{timespan}-based phrase structures,
and those meter sequences used to transform notated rhythms in turn. A thorough
discussion of the implementations of time models and their implications will
clarify a later analysis of Consort's score interpretation stage.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Timespans}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\emph{Timespans} model left-closed / right-open intervals of time positioned
absolutely along a timeline. This means that every \index{timespan} describes
an interval of time starting with -- and including -- some start offset and
leading up to -- but not including -- some stop offset. Note that all leaves in
a score describe such half-bounded interval of time. Adjacent notes in a score
do not overlap, but rather abut one another because their timespans do not
overlap. In fact, every durated object in a score -- every note, chord, rest,
measure, staff, and even the score itself -- can be described in terms of
timespans. Yet while score objects can always be described in terms of
timespans, timespans themselved do not -- by definition -- refer to any score
objects. Abjad implements timespans as immutable constants, much like Abjad's
\texttt{Pitch} and \texttt{Duration} objects, and similarly to Python's
implementation of numbers or strings. Constancy allows timespans to avoid a
variety of computational reference problems. Multiple objects can reference the
same timespan without fear of that timespan changing state, much as multiple
objects can reference the integer 11 without fear that it will change into the
integer 5.

Abjad implements timespans via the \texttt{timespantools.Timespan} class. The
following timespan begins at the offset 1/4 and continues up until the offset
3/2:

\begin{comment}
<abjad>
timespan = timespantools.Timespan(
    start_offset=Offset(1, 4),
    stop_offset=Offset(3, 2),
    )
print(timespan)
show(timespan)
</abjad>
\end{comment}

\noindent The \texttt{Timespan} class provides a large number of methods and
properties for inspecting timespans, comparing them to other timespans or
offsets, and for operating on timespans to generate new timespans. Once
instantiated, the timespan can be examined for its start offset, stop offset
and duration. Because of the \texttt{Timespan} class' immutability, these
properties are read-only and therefore can only be accessed, but not changed.

\begin{comment}
<abjad>
timespan.start_offset
timespan.stop_offset
timespan.duration
</abjad>
\end{comment}

\noindent A timespan's start offset must be equal to or less than its stop
offset. Timespans with identical start and stop offsets have a duration of 0
and effectively model a single time-point. Such timespans are considered not
\enquote{well-formed}:

\begin{comment}
<abjad>
timepoint_timespan = timespantools.Timespan(1, 1)
timepoint_timespan.duration
timepoint_timespan.is_well_formed
</abjad>
\end{comment}

\noindent Both the \texttt{start\_offset} and \texttt{stop\_offset} keywords to
the \texttt{Timespan} class' initializer are optional, and default to Abjad's
built-in rational constants \texttt{NegativeInfinity} and \texttt{Infinity}
respectively. A timespan created without specifying either a start or stop
offset effectively describes the timespan which encompasses all possible
offsets in time:

\begin{comment}
<abjad>
infinite_timespan = timespantools.Timespan()
infinite_timespan.start_offset
infinite_timespan.stop_offset
infinite_timespan.duration
</abjad>
\end{comment}

\noindent By specifying only a start or stop offset, timespans can also be
created which encompass the infinite set of offsets up until some stop offset,
or the infinite set of offsets starting at and following some start-offset:

\begin{comment}
<abjad>
timespantools.Timespan(stop_offset=0)
timespantools.Timespan(start_offset=0)
</abjad>
\end{comment}

\noindent \texttt{Timespan} objects also partake in Abjad's templating regime.
New timespans can be created from old ones through the use of the top-level
\texttt{new()} function:

\begin{comment}
<abjad>
new(timespan, stop_offset=(5, 16))
</abjad>
\end{comment}

\subsection{Annotated timespans} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

While the \texttt{Timespan} class only has two configurable properties -- its
start offset and stop offset -- subclassing allows for the creation of new
classes with the same core functionality as \texttt{Timespan} but expanded to
allow for other configurable properties. As an example, \texttt{timespantools}
provides an \texttt{AnnotatedTimespan} class which subclasses \texttt{Timespan}
and adds a third read-only \texttt{annotation} property:

\begin{comment}
<abjad>
annotated_timespan = timespantools.AnnotatedTimespan(
    start_offset=(1, 8),
    stop_offset=(7, 8),
    annotation='Any arbitrary object can act as an annotation.'
    )
annotated_timespan.annotation
</abjad>
\end{comment}

\noindent Annotated timespans let composers position annotations or other
metadata arbitrarily along a timeline. If the annotation is itself a mutable
datastructure like a dictionary, that annotation can be used to store
increasing amounts of arbitrary information during the compositional process.
Abjad's top-level \texttt{new()} function can also be used to template new
annotated timespans from old ones, replacing one annotation with another:

\begin{comment}
<abjad>
metadata_timespan = new(annotated_timespan,
    stop_offset=(3, 2),
    annotation={
        'durations': ((1, 8), (1, 8), (3, 16)),
        'dynamic': indicatortools.Dynamic('ppp'),
        'pitch_segment': pitchtools.PitchSegment([0, 1, 4, 7]),
        },
    )
metadata_timespan.annotation['bow_contact_point'] = Multiplier(1, 3)
print(format(metadata_timespan))
</abjad>
\end{comment}

\noindent Other subclasses are also possible, allowing for even more
configurable properties, as well as new methods. Two \texttt{Timespan}
subclasses discussed later, \texttt{consort.PerformedTimespan} and
\texttt{consort.SilentTimespan}, are core components in Consort's score
interpretation algorithm.

\subsection{Time relations} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Abjad's \texttt{timespantools} provides a \texttt{TimeRelation} class and a
collection of factory methods for configuring \texttt{TimeRelation} instances
which formalize all possible dispositions of a timespan relative another
timespan or relative an offset\footnote{ The thirty-three time relation factory
functions contained in \texttt{timespantools} are
\texttt{offset\_happens\_after\_timespan\_starts()},
\texttt{offset\_happens\_after\_timespan\_stops()},
\texttt{offset\_happens\_before\_timespan\_starts()},
\texttt{offset\_happens\_before\_timespan\_stops()},
\texttt{offset\_happens\_during\_timespan()},
\texttt{offset\_happens\_when\_timespan\_starts()},
\texttt{offset\_happens\_when\_timespan\_stops()},
\texttt{timespan\_2\_contains\_timespan\_1\_improperly()},
\texttt{timespan\_2\_curtails\_timespan\_1()},
\texttt{timespan\_2\_delays\_timespan\_1()},
\texttt{timespan\_2\_happens\_during\_timespan\_1()},
\texttt{timespan\_2\_intersects\_timespan\_1()},
\texttt{timespan\_2\_is\_congruent\_to\_timespan\_1()},
\texttt{timespan\_2\_overlaps\_all\_of\_timespan\_1()},
\texttt{timespan\_2\_overlaps\_only\_start\_of\_timespan\_1()},
\texttt{timespan\_2\_overlaps\_only\_stop\_of\_timespan\_1()},
\texttt{timespan\_2\_overlaps\_start\_of\_timespan\_1()},
\texttt{timespan\_2\_overlaps\_stop\_of\_timespan\_1()},
\texttt{timespan\_2\_starts\_after\_timespan\_1\_starts()},
\texttt{timespan\_2\_starts\_after\_timespan\_1\_stops()},
\texttt{timespan\_2\_starts\_before\_timespan\_1\_starts()},
\texttt{timespan\_2\_starts\_before\_timespan\_1\_stops()},
\texttt{timespan\_2\_starts\_during\_timespan\_1()},
\texttt{timespan\_2\_starts\_when\_timespan\_1\_starts()},
\texttt{timespan\_2\_starts\_when\_timespan\_1\_stops()},
\texttt{timespan\_2\_stops\_after\_timespan\_1\_starts()},
\texttt{timespan\_2\_stops\_after\_timespan\_1\_stops()},
\texttt{timespan\_2\_stops\_before\_timespan\_1\_starts()},
\texttt{timespan\_2\_stops\_before\_timespan\_1\_stops()},
\texttt{timespan\_2\_stops\_during\_timespan\_1()},
\texttt{timespan\_2\_stops\_when\_timespan\_1\_starts()},
\texttt{timespan\_2\_stops\_when\_timespan\_1\_stops()} and
\texttt{timespan\_2\_trisects\_timespan\_1()}. }. Time relations may be
configured with or without reference to any timespans or offsets at all,
allowing for the possibility of modeling a purely abstract time relationship.

\begin{comment}
<abjad>
time_relation_1 = timespantools.timespan_2_intersects_timespan_1()
print(format(time_relation_1))
</abjad>
\end{comment}

\noindent A \enquote{half-configured} time relation is also possible. Such
object acts like a kind of \enquote{frozen} predicate function, and can be
called like a function on another timespan or offset to return a truth value.

\begin{comment}
<abjad>
time_relation_2 = timespantools.timespan_2_intersects_timespan_1(
    timespan_1=timespantools.Timespan(0, 10),
    )
time_relation_2(timespan_2=timespantools.Timespan(5, 15))
time_relation_2(timespan_2=timespantools.Timespan(30, 45))
</abjad>
\end{comment}

\noindent Time relations which are \enquote{fully loaded} will be evaluated
immediately:

\begin{comment}
<abjad>
timespantools.timespan_2_intersects_timespan_1(
    timespan_1=timespantools.Timespan(1, 3),
    timespan_2=timespantools.Timespan(2, 4),
    )
</abjad>
\end{comment}

\noindent The time relation factory functions in \texttt{timespantools} are
also implemented as methods on the \texttt{Timespan} class itself, allowing
composers to determine the various relations of any timespan relative any other
timespan or offset in an object-oriented fashion. The \texttt{Timespan} object
automatically \enquote{fills in} the \texttt{timespan\_1} argument to the
\texttt{TimeRelation} with itself, and can pass the optional argument to its
method call as the other object in the relation, allowing for the immediate
evaluation of the relation as either true or false.

Consider the following three timespans:

\begin{comment}
<abjad>
timespan_1 = timespantools.Timespan(0, 10)
timespan_2 = timespantools.Timespan(5, 15)
timespan_3 = timespantools.Timespan(10, 20)
</abjad>
\end{comment}

\noindent These three timespans could be represented together visually like
this:

\begin{comment}
<abjad>[hide=true]
timespan_inventory = timespantools.TimespanInventory([
    timespan_1,
    timespan_2,
    timespan_3,
    ])
show(timespan_inventory)
</abjad>
\end{comment}

\noindent We can test for intersection between these three timespans via the
\texttt{intersects\_timespan()} method. Two timespans are considered to
intersect if any part of one timespan overlaps any part of another, and is
therefore commutative. Note that \texttt{timespan\_1} and \texttt{timespan\_3}
do not overlap even though they share the offset 10. As discussed earlier,
timespans are left-closed / right-open, meaning that while their start offset is
contained in the infinite set of offsets they cover, their stop offset is not.

\begin{comment}
<abjad>
timespan_1.intersects_timespan(timespan_2)
timespan_1.intersects_timespan(timespan_3)
timespan_2.intersects_timespan(timespan_1)
timespan_2.intersects_timespan(timespan_3)
timespan_3.intersects_timespan(timespan_1)
timespan_3.intersects_timespan(timespan_2)
</abjad>
\end{comment}

\noindent Congruency tests whether two timespans share the same start and stop
offset. Every timespan is congruent with itself:

\begin{comment}
<abjad>
timespan_1.is_congruent_to_timespan(timespan_2)
timespan_1.is_congruent_to_timespan(timespan_1)
</abjad>
\end{comment}

\noindent Tangency tests whether one timespan's stop offset is the same as
another timespan's start offset, or vice versa. Tangency can be used to
determine if a sorted collection of timespans are all contiguous together.

\begin{comment}
<abjad>
timespan_1.is_tangent_to_timespan(timespan_2)
timespan_1.is_tangent_to_timespan(timespan_3)
</abjad>
\end{comment}

\noindent A wide variety of other time relation predicates are also possible,
such as testing if a timespan intersects with a specific offset, testing if a
timespan overlaps only the beginning or end of another timespan, or testing if
a timespan contains another timespan entirely. These predicates make possible
many of the generative operations carried out on timespans.

\subsection{Operations on timespans} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Many \texttt{Timespan} methods provide transformations, such as translation,
scaling or offset rounding. Because timespans are immutable, these methods
create a new timespan based on the old one and then return the new, leaving
the old exactly as it was:

\begin{comment}
<abjad>
timespan = timespantools.Timespan(0, 15)
timespan.translate(3)
timespan.scale(3)
timespan.round_offsets(2)
</abjad>
\end{comment}

\noindent Internally, these generative methods are implemented via templating
as described earlier, allowing annotated timespan subclasses to partake in the
same templating functionality -- templating their start and / or stop offsets,
but maintaining all other previously configured properties:

\begin{comment}
<abjad>
annotated_timespan = timespantools.AnnotatedTimespan(0, 5, 'an annotation')
scaled_annotated_timespan = annotated_timespan.translate((-1, 3))
print(format(scaled_annotated_timespan))
</abjad>
\end{comment}

\noindent Some generative operations may return zero or more timespans,
aggregated in a datastructure called a \emph{timespan inventory}, which is
discussed at length in the following section. Splitting a timespan by an offset
is one such operation. If the offset to be split by is \emph{properly
contained}\footnote{\emph{Proper containment} of an offset means that the
offset is greater than the timespan's start offset and less than the timespan's
stop offset. \emph{Improper containment} would indicated the offset is greater
than or equal to the timespan's start offset and less than or equal to its stop
offset.} by the timespan to be split, two new timespans will be returned,
otherwise a \index{timespan inventory} containing a copy of the original input timespan
will be returned:

\begin{comment}
<abjad>
two_shards = timespan.split_at_offset(5)
print(format(two_shards))
one_shard = timespan.split_at_offset(10000)
print(format(one_shard))
</abjad>
\end{comment}

\noindent More complex operations between timespans which result in timespan
inventories include subtraction, as well as logical \texttt{AND}, \texttt{OR}
and \texttt{XOR}. These generative operations are conceptually \emph{set}
operations -- union, difference, intersection, symmetric difference, etc. --
performed on the two sets of offsets contained by the two timespan operands.
Consider these same set operations -- union, difference, intersection,
symmetric difference -- carried out on trivial sets in Python:

\begin{comment}
<abjad>
set([1, 2, 3]) | set([2, 3, 4])  # union
set([1, 2, 3]) - set([2, 3, 4])  # difference
set([1, 2, 3]) & set([2, 3, 4])  # intersection
set([1, 2, 3]) ^ set([2, 3, 4])  # symmetric difference
</abjad>
\end{comment}

\noindent Set operations performed on timespans are conceptually identical, but
operate on infinite but bounded sets of offsets instead of discrete sets of
objects such as integers. For example, subtracting one timespan from another
computes the set difference of the offsets contained by both. This operation is
not commutative -- subtracting one timespan from another will not result in the
same ouput as subtract the latter from the former. Subtracting a timespan from
itself always results in the empty set of offsets: no timespan at all:

\begin{comment}
<abjad>
result = timespantools.Timespan(0, 10) - timespantools.Timespan(0, 10)
print(format(result))
result = timespantools.Timespan(0, 10) - timespantools.Timespan(5, 15)
print(format(result))
result = timespantools.Timespan(0, 10) - timespantools.Timespan(10, 20)
print(format(result))
result = timespantools.Timespan(5, 15) - timespantools.Timespan(0, 10)
print(format(result))
result = timespantools.Timespan(5, 15) - timespantools.Timespan(5, 15)
print(format(result))
result = timespantools.Timespan(5, 15) - timespantools.Timespan(10, 20)
print(format(result))
result = timespantools.Timespan(10, 20) - timespantools.Timespan(0, 10)
print(format(result))
result = timespantools.Timespan(10, 20) - timespantools.Timespan(5, 15)
print(format(result))
result = timespantools.Timespan(10, 20) - timespantools.Timespan(10, 20)
print(format(result))
</abjad>
\end{comment}

\noindent Computing the logical \texttt{OR} of two timespans results in an
offset set union -- a commutative operation, effectively fusing the timespans
together if they overlap:

\begin{comment}
<abjad>
result = timespantools.Timespan(0, 10) | timespantools.Timespan(5, 15)
print(format(result))
result = timespantools.Timespan(0, 10) | timespantools.Timespan(10, 20)
print(format(result))
result = timespantools.Timespan(5, 15) | timespantools.Timespan(10, 20)
print(format(result))
</abjad>
\end{comment}

\noindent Unioning guarantees that all of the offsets contained in the two
input timespans will appear in the output timespan(s), whether or not any
overlap occurred:

\begin{comment}
<abjad>
result = timespantools.Timespan(10, 20) | timespantools.Timespan(25, 50)
print(format(result))
</abjad>
\end{comment}

\noindent The logical \texttt{AND} -- set intersection -- results in the
intersection of the two input timespans:

\begin{comment}
<abjad>
result = timespantools.Timespan(0, 10) & timespantools.Timespan(5, 15)
print(format(result))
result = timespantools.Timespan(0, 10) & timespantools.Timespan(10, 20)
print(format(result))
result = timespantools.Timespan(5, 15) & timespantools.Timespan(10, 20)
print(format(result))
</abjad>
\end{comment}

\noindent Logical \texttt{XOR} -- also known as exclusive \texttt{OR} --
results in the symmetric difference of the two input timespans. Only those
offsets which are contained by only one of the two input timespans will occur
in the output:

\begin{comment}
<abjad>
result = timespantools.Timespan(0, 10) ^ timespantools.Timespan(5, 15)
print(format(result))
result = timespantools.Timespan(0, 10) ^ timespantools.Timespan(10, 20)
print(format(result))
result = timespantools.Timespan(5, 15) ^ timespantools.Timespan(10, 20)
print(format(result))
</abjad>
\end{comment}

\noindent These operations, while perhaps initially rather abstract, are
incredibly powerful and artistically useful. They afford composers with the
procedural building blocks to mask temporal objects with one another, fuse them
together, or create lacunae. When extended to operate on many timespans at
once, wholesale transformations on massed timespans becomes practical.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Timespan inventories}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Abjad provides a \texttt{TimespanInventory} class specifically for aggregating
together a collection of \texttt{Timespan} objects. Timespan inventories
implement Python's \emph{mutable sequence protocol} which allow them to behave
exactly like lists, supporting appension, extension, insertion, indexing,
sorting, iteration and other procedures pertinent to list-like objects. They
also provide a wide variety of properties and methods for interacting with
massed groups of timespans such as searching for timespans matching a time
relation, splitting all timespans which interact with a given offset or
partitioning one inventory into multiple separate inventories of overlapping
timespans.

A \index{timespan inventory} can be created with a list of zero or more timespans as an
argument, be appended to, or extended into:

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(0, 16),
    ])
timespan_inventory.append(timespantools.Timespan(5, 12))
timespan_inventory.extend([
    timespantools.Timespan(-2, 8),
    timespantools.Timespan(15, 20),
    ])
print(format(timespan_inventory))
show(timespan_inventory)
</abjad>
\end{comment}

\noindent Timespan inventories can also be queried for their length -- just
like any other sequence in Python --, be indexed into, or iterated over:

\begin{comment}
<abjad>
len(timespan_inventory)
timespan_inventory[1]
for timespan in timespan_inventory:
    timespan

</abjad>
\end{comment}

\noindent Similarly, one timespan inventory can be created from another -- just
like one can create a Python list simply by calling \texttt{list()} on another
iterable object -- by passing the first \index{timespan inventory} as an instantiation
argument to the second. As many of the mutating methods implemented on timespan
inventories operate in place, this instantiation pattern provides a simple
means of \enquote{copying}, allowing composers to duplicate a timespan
structure before operating on it, thereby preserving the original.

\begin{comment}
<abjad>
duplicate = timespantools.TimespanInventory(timespan_inventory)
duplicate == timespan_inventory
duplicate is timespan_inventory
print(format(duplicate))
</abjad>
\end{comment}

Timespan inventories can be treated as timespans themselves, having
a start offset equal to the minimum start offset of any of their contained
timespans, and a stop offset equal to the maximum stop offset of any of their
contained timespans. Their start and stop offset properties allow them to
express a duration, as well as provide a concrete timespan representation.
Because timespan inventories can be modeled as timespans, they can even be
inserted into other timespan inventories.

\begin{comment}
<abjad>
timespan_inventory.start_offset
timespan_inventory.stop_offset
timespan_inventory.duration
timespan_inventory.timespan
</abjad>
\end{comment}

\noindent Because timespan inventories aggregate multiple timespans together,
they also provide properties for describing collective qualities of those
timespans. \emph{Contiguity} tests if every timespan in the inventory is
tangent to another timespan, and does not overlap any other timespan,
\emph{overlap} tests if any timespan intersects any other timespan, and
\emph{well-formedness} tests that all timespans' durations are greater than 0.
A \index{timespan inventory} whose timespans are contiguous is necessarily
also non-overlapping.

\begin{comment}
<abjad>
timespan_inventory.all_are_contiguous
timespan_inventory.all_are_nonoverlapping
timespan_inventory.all_are_well_formed
</abjad>
\end{comment}

\noindent The following timespan inventory's timespans are non-overlapping but
also non-contiguous:

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(0, 10),
    timespantools.Timespan(10, 20),
    timespantools.Timespan(30, 40),
    ])
show(timespan_inventory)
timespan_inventory.all_are_contiguous
timespan_inventory.all_are_nonoverlapping
</abjad>
\end{comment}

\noindent In contrast, this timespan inventory's timespans are both
non-overlapping and contiguous:

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(0, 10),
    timespantools.Timespan(10, 20),
    timespantools.Timespan(20, 30),
    ])
show(timespan_inventory)
timespan_inventory.all_are_contiguous
timespan_inventory.all_are_nonoverlapping
</abjad>
\end{comment}

\subsection{Operations on timespan inventories} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Timespan inventory implement unioning, differencing and splitting methods which
parallel those implemented on timespans themselves. These methods
map the desired operation onto the contents of the inventory by, for example,
splitting every timespan contained in a given inventory by some offset. All of
these operations act in place. The intersection of all of the timespans in a
\index{timespan inventory} relative another timespan can be computed with the
\texttt{\&} operator, just like with single timespans:

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(0, 16),
    timespantools.Timespan(5, 12),
    timespantools.Timespan(-2, 8),
    ])
show(timespan_inventory)
timespan_operand = timespantools.Timespan(6, 10)
result = timespan_inventory & timespan_operand
show(result, range_=(-2, 16))
</abjad>
\end{comment}

\noindent Likewise, the offsets bound by a given timespan can be subtracted
from all of the timespans in a \index{timespan inventory}, effectively cutting a hole
in that inventory's timeline:

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(0, 16),
    timespantools.Timespan(5, 12),
    timespantools.Timespan(-2, 8),
    ])
show(timespan_inventory)
timespan_operand = timespantools.Timespan(6, 10)
result = timespan_inventory - timespan_operand
show(result)
</abjad>
\end{comment}

\noindent As with a single timespan and an offset, an entire timespan inventory
can be split into two separate inventories via the \texttt{split\_at\_offset()}
method:

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(0, 3),
    timespantools.Timespan(3, 6),
    timespantools.Timespan(6, 10),
    ])
show(timespan_inventory)
left, right = timespan_inventory.split_at_offset(4)
show(left, range_=(0, 10))
show(right, range_=(0, 10))
</abjad>
\end{comment}

\noindent The \texttt{TimespanInventory} class also provides the convenience
method \texttt{split\_at\_offsets()} for splitting an inventory by an arbitrary
number of offsets at once:

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(0, 3),
    timespantools.Timespan(3, 6),
    timespantools.Timespan(6, 10),
    ])
show(timespan_inventory)
shards = timespan_inventory.split_at_offsets((2, 4, 7))
for shard in shards:
    show(shard, range_=(0, 10))

</abjad>
\end{comment}

The mutating methods described above modify a timespan inventory
by mapping some procedure against its contents and some outside timespan or
offset. However, timespan inventories may also be modified by applying a
procedure solely against the contents of the inventory itself, mapping each
timespan in the collection against each other timespan in that collection.

For example, a timespan inventory can be modified by computing the logical
\texttt{OR} -- the set union -- of every timespan in the inventory relative
every other timespan, effectively fusing all overlapping timespans together:

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(-2, 2),
    timespantools.Timespan(0, 10),
    timespantools.Timespan(5, 12),
    ])
show(timespan_inventory)
result = timespan_inventory.compute_logical_or()
print(format(result))
show(result)
</abjad>
\end{comment}

\noindent A timespan inventory can also be modified by computing the logical
\texttt{AND} of every timespan in the inventory relative every other timespan.
This procedure leaves only those offsets where every single timespan
overlaps:

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(-2, 8),
    timespantools.Timespan(0, 10),
    timespantools.Timespan(5, 12),
    ])
show(timespan_inventory)
result = timespan_inventory.compute_logical_and()
print(format(result))
show(result, range_=(-2, 12))
</abjad>
\end{comment}

\noindent Lastly, computing the in-place logical \texttt{XOR} removes all
overlap from the timespan inventory, leaving only those offsets occupied by
only one timespan:

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(-2, 2),
    timespantools.Timespan(0, 10),
    timespantools.Timespan(5, 12),
    ])
show(timespan_inventory)
result = timespan_inventory.compute_logical_xor()
print(format(result))
show(result, range_=(-2, 12))
</abjad>
\end{comment}

Timespan partitioning separates a timespan inventory into groups of overlapping
and optionally tangent timespans, aggregated into new timespan inventories.
This procedure allows composers to isolate contiguous blocks of activity.

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(0, 10),
    timespantools.Timespan(5, 15),
    timespantools.Timespan(15, 20),
    timespantools.Timespan(25, 30),
    ])
show(timespan_inventory)
for shard in timespan_inventory.partition():
    show(shard, range_=(0, 30))

for shard in timespan_inventory.partition(include_tangent_timespans=True):
    show(shard, range_=(0, 30))

</abjad>
\end{comment}

The procedures outlined above provide high-level tools for interacting with
large numbers of timespans at once. All of the techniques described in later
chapters with regards to Consort's score interpretation algorithm -- timespan
consolidation, cascading overlap resolution, multiplexing multiple inventories
into one, demultiplexing one inventory into many, and so forth -- build on and
extend these techniques.

\subsection{Optimized timespan inventories} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Consort provides its own timespan collection class -- the
\texttt{TimespanCollection}. This class stores timespans internally not as a
list, but in a balanced \emph{interval tree}\footnote{An interval tree is an
augmented self-balancing binary tree which stores both start offsets as well as
stop offsets.} datastructure which guarantees sorting and allows for highly
optimized lookups of timespans intersecting specific offsets. This class is
used at crucial points during Consort's interpretation stage simply for
purposes of speed, and should be considered an implementation detail. It
implements only a few methods, specifically for affording rapid search and
retrieval of timespans intersecting other timespans or offsets. With work, its
internal datastructure may eventually be merged into Abjad's own
\texttt{TimespanInventory} class.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Annotated timespans in Consort}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

While the above datastructures and operations are potentially very useful, a
larger question remains: how can composers create enough timespans, and in
various patterns, to be musically interesting? Consort approaches this problem
by providing a collection of factory classes -- \emph{timespan makers} -- which
can be configured and called to create arbitrarily large amounts of timespans.
However, before turning to a detailed discussion of timespan makers, we must
discuss the products of the timespan themselves: Consort's annotated timespan
subclasses.

Consort provides two separate timespan subclasses which are integral, if
transient, components of its score interpretation algorithm: the
\texttt{PerformedTimespan} and \texttt{SilentTimespan} classes. These classes
are never created \enquote{by hand} during Consort's specification stage --
this is, explicitly instantiated by a composer while specifying a score segment
--, but are instead generated as transitory objects during interpretation.
Consort uses \texttt{PerformedTimespan} objects to specify locations in the
score timeline where some active musical material should appear, while
\texttt{SilentTimespan} objects specify tacet passages.

As will be described in more detail in the following chapters, Consort requires
composers to specify musical materials in \emph{layers}, and to specify
specifically in which voices in the score -- vertically -- that material should
occur in. During the course of interpretation, Consort separates out generated
timespans by voice name and layer into separate timespan inventories, and then
progressively masks out timespans in timespan inventories with lower layer
numbers by timespans in timespan inventories with higher layer numbers. This
process is somewhat analogous to the use of opaque layers in image editing
software. Both the \texttt{PerformedTimespan} and \texttt{SilentTimespan}
classes provide configurable properties for layer and voice name, in addition
to the start offset and stop offset properties provided by their parent
\texttt{Timespan} class. These properties allow the processes that generate
them to record \emph{when} they were created, as well as \emph{where} the
should appear in the score, should they survive the masking process.

Silent timespans do not appear in the score, but can be created for a
particular layer and used to simply erase any timespan in a lower layer by
masking.

\begin{comment}
<abjad>
performed_timespan = consort.PerformedTimespan(
    layer=1,
    start_offset=(1, 2),
    stop_offset=(7, 8),
    voice_name='Clarinet Voice',
    )
silent_timespan = consort.SilentTimespan(
    layer=2,
    start_offset=Offset(0, 1),
    stop_offset=Offset(1, 4),
    voice_name='Oboe Voice',
    )
</abjad>
\end{comment}

\begin{comment}
<abjad>
performed_timespan = consort.PerformedTimespan(
    layer=1,
    minimum_duration=Duration(1, 8),
    music_specifier=consort.MusicSpecifier(),
    start_offset=Offset(1, 4),
    stop_offset=Offset(2, 1),
    voice_name='Violin 1 LH Voice',
    )
</abjad>
\end{comment}

- forbid fusing

- forbid splitting

- minimum duration

- (additionally, music specifier: minimum phrase duration)

- divisions

- music

- music specifier

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Timespan makers}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

- timespan specifier

- independent vs dependent

- target timespans

- talea

- padding

\subsection{FloodedTimespanMaker} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{comment}
<abjad>
flooded_timespan_maker = consort.FloodedTimespanMaker()
print(format(flooded_timespan_maker))
</abjad>
\end{comment}

\begin{comment}
<abjad>
music_specifiers = {'Violin Voice': 'violin music'}
target_timespan = timespantools.Timespan((1, 4), (11, 8))
timespan_inventory = flooded_timespan_maker(
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
print(format(timespan_inventory))
</abjad>
\end{comment}

Adding a second music specifier entry and a layer keyword generates another
collection of timespans.

\begin{comment}
<abjad>
music_specifiers = {
    'Violin Voice': 'violin music',
    'Cello Voice': 'cello music',
    }
timespan_inventory = flooded_timespan_maker(
    layer=3,
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
print(format(timespan_inventory))
show(timespan_inventory, key='voice_name')
</abjad>
\end{comment}

A new flooded timespan maker, configured with padding and a timespan specifier
which will further configure each generated timespan.

\begin{comment}
<abjad>
flooded_timespan_maker = consort.FloodedTimespanMaker(
    padding=Duration(1, 4),
    timespan_specifier=consort.TimespanSpecifier(
        minimum_duration=Duration(1, 8),
        ),
    )
timespan_inventory = flooded_timespan_maker(
    layer=5,
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
print(format(timespan_inventory))
show(timespan_inventory, key='voice_name')
</abjad>
\end{comment}

\subsection{TaleaTimespanMaker} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{comment}
<abjad>
talea_timespan_maker = consort.TaleaTimespanMaker()
print(format(talea_timespan_maker))
</abjad>
\end{comment}

\begin{comment}
<abjad>
import collections
music_specifiers = collections.OrderedDict([
    ('Voice 1', None),
    ('Voice 2', None),
    ('Voice 3', None),
    ('Voice 4', None),
    ])
target_timespan = timespantools.Timespan(0, (19, 4))
</abjad>
\end{comment}

\begin{comment}
<abjad>
result = talea_timespan_maker(
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
show(result, key='voice_name')
</abjad>
\end{comment}

\begin{comment}
<abjad>
talea_timespan_maker = new(
    talea_timespan_maker,
    playing_talea=rhythmmakertools.Talea(
        counts=(1, 2, 3, 4),
        denominator=4,
        )
    )
result = talea_timespan_maker(
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
show(result, key='voice_name')
</abjad>
\end{comment}

\begin{comment}
<abjad>
talea_timespan_maker = new(
    talea_timespan_maker,
    playing_groupings=(1, 2),
    )
result = talea_timespan_maker(
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
show(result, key='voice_name')
</abjad>
\end{comment}

\begin{comment}
<abjad>
talea_timespan_maker = new(
    talea_timespan_maker,
    silence_talea=rhythmmakertools.Talea(
        counts=(3, 1, 1),
        denominator=8,
        ),
    )
result = talea_timespan_maker(
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
show(result, key='voice_name')
</abjad>
\end{comment}

\begin{comment}
<abjad>
talea_timespan_maker = new(
    talea_timespan_maker,
    initial_silence_talea=rhythmmakertools.Talea(
        counts=(0, 1, 3),
        denominator=8,
        ),
    )
result = talea_timespan_maker(
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
show(result, key='voice_name')
</abjad>
\end{comment}

\begin{comment}
<abjad>
talea_timespan_maker = new(
    talea_timespan_maker,
    reflect=True,
    )
result = talea_timespan_maker(
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
show(result, key='voice_name')
</abjad>
\end{comment}

\begin{comment}
<abjad>
synchronized_talea_timespan_maker = consort.TaleaTimespanMaker(
    playing_talea=rhythmmakertools.Talea(
        counts=(1, 2, 3, 4, 5),
        denominator=8,
        ),
    silence_talea=rhythmmakertools.Talea(
        counts=(4, 7),
        denominator=8,
        ),
    synchronize_step=True,
    )
result = synchronized_talea_timespan_maker(
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
show(result, key='voice_name')
</abjad>
\end{comment}

\begin{comment}
<abjad>
synchronized_talea_timespan_maker = new(
    synchronized_talea_timespan_maker,
    initial_silence_talea=rhythmmakertools.Talea(
        counts=(0, 1, 2),
        denominator=8,
        ),
    padding=Duration(1, 8),
    )
result = synchronized_talea_timespan_maker(
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
show(result, key='voice_name')
</abjad>
\end{comment}


\subsection{DependentTimespanMaker} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    consort.PerformedTimespan(0, 10, voice_name='Voice 1'),
    consort.PerformedTimespan(10, 20, voice_name='Voice 1'),
    consort.PerformedTimespan(25, 30, voice_name='Voice 1'),
    consort.PerformedTimespan(50, 60, voice_name='Voice 1'),
    consort.PerformedTimespan(0, 10, voice_name='Voice 2'),
    consort.PerformedTimespan(15, 35, voice_name='Voice 2'),
    consort.PerformedTimespan(40, 45, voice_name='Voice 2'),
    consort.PerformedTimespan(45, 75, voice_name='Voice 2'),
    ])
show(timespan_inventory, key='voice_name')
</abjad>
\end{comment}

\begin{comment}
<abjad>
music_specifiers = {'Voice 3': None}
dependent_timespan_maker = consort.DependentTimespanMaker(
    voice_names=(
        'Voice 1',
        'Voice 2',
        )
    )
result = dependent_timespan_maker(
    music_specifiers=music_specifiers,
    timespan_inventory=new(timespan_inventory),
    )
show(result, key='voice_name')
</abjad>
\end{comment}

\begin{comment}
<abjad>
new_dependent_timespan_maker = new(
    dependent_timespan_maker,
    include_inner_starts=True,
    )
result = new_dependent_timespan_maker(
    music_specifiers=music_specifiers,
    timespan_inventory=new(timespan_inventory),
    )
show(result, key='voice_name')
</abjad>
\end{comment}

\begin{comment}
<abjad>
new_dependent_timespan_maker = new(
    dependent_timespan_maker,
    include_inner_stops=True,
    )
result = new_dependent_timespan_maker(
    music_specifiers=music_specifiers,
    timespan_inventory=new(timespan_inventory),
    )
show(result, key='voice_name')
</abjad>
\end{comment}

\begin{comment}
<abjad>
new_dependent_timespan_maker = new(
    dependent_timespan_maker,
    include_inner_starts=True,
    include_inner_stops=True,
    )
result = new_dependent_timespan_maker(
    music_specifiers=music_specifiers,
    timespan_inventory=new(timespan_inventory),
    )
show(result, key='voice_name')
</abjad>
\end{comment}

\begin{comment}
<abjad>
result = new_dependent_timespan_maker(
    music_specifiers=music_specifiers,
    target_timespan=timespantools.Timespan(17, 58),
    timespan_inventory=new(timespan_inventory),
    )
show(result, key='voice_name', range_=(0, 75))
</abjad>
\end{comment}

\begin{comment}
<abjad>
rotated_dependent_timespan_maker = new(
    new_dependent_timespan_maker,
    rotation_indices=(1,),
    )
result = rotated_dependent_timespan_maker(
    music_specifiers=music_specifiers,
    timespan_inventory=new(timespan_inventory),
    )
show(result, key='voice_name', range_=(0, 75))
</abjad>
\end{comment}

\begin{comment}
<abjad>
rotated_dependent_timespan_maker = new(
    new_dependent_timespan_maker,
    rotation_indices=(1, -1),
    )
result = rotated_dependent_timespan_maker(
    music_specifiers=music_specifiers,
    timespan_inventory=new(timespan_inventory),
    )
show(result, key='voice_name', range_=(0, 75))
</abjad>
\end{comment}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Rhythm makers}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

- divisions

\begin{comment}
<abjad>
divisions = [(3, 8), (4, 8), (3, 16), (4, 16), (5, 8), (2, 4)]
</abjad>
\end{comment}

- rhythm maker

\begin{comment}
<abjad>
note_rhythm_maker = rhythmmakertools.NoteRhythmMaker()
show(note_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

\begin{comment}
<abjad>
note_rhythm_maker = new(
    note_rhythm_maker,
    tie_specifier=rhythmmakertools.TieSpecifier(
        tie_across_divisions=True,
        ),
    )
show(note_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

\begin{comment}
<abjad>
note_rhythm_maker = rhythmmakertools.NoteRhythmMaker(
    output_masks=[
        rhythmmakertools.BooleanPattern(
            indices=[0],
            period=2,
            ),
        ],
    )
show(note_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

\begin{comment}
<abjad>
note_rhythm_maker = rhythmmakertools.NoteRhythmMaker(
    output_masks=[
        rhythmmakertools.BooleanPattern(
            indices=[0],
            period=1,
            ),
        ],
    )
show(note_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

\begin{comment}
<abjad>
incised_rhythm_maker = rhythmmakertools.IncisedRhythmMaker(
    incise_specifier=rhythmmakertools.InciseSpecifier(
        suffix_talea=[-1],
        suffix_counts=[1],
        talea_denominator=16,
        ),
    )
show(incised_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

\begin{comment}
<abjad>
incised_rhythm_maker = rhythmmakertools.IncisedRhythmMaker(
    incise_specifier=rhythmmakertools.InciseSpecifier(
        fill_with_notes=False,
        prefix_counts=[2, 1],
        prefix_talea=[1],
        talea_denominator=16,
        ),
    )
show(incised_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

\begin{comment}
<abjad>
incised_rhythm_maker = rhythmmakertools.IncisedRhythmMaker(
    incise_specifier=rhythmmakertools.InciseSpecifier(
        outer_divisions_only=True,
        prefix_counts=[1],
        prefix_talea=[-1],
        suffix_counts=[1],
        suffix_talea=[-1],
        talea_denominator=8,
        ),
    )
show(incised_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

\begin{comment}
<abjad>
incised_rhythm_maker = new(
    incised_rhythm_maker,
    tie_specifier=rhythmmakertools.TieSpecifier(
        tie_across_divisions=True,
        ),
    )
show(incised_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

\begin{comment}
<abjad>
even_division_rhythm_maker = rhythmmakertools.EvenDivisionRhythmMaker()
show(even_division_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

\begin{comment}
<abjad>
even_division_rhythm_maker = new(
    even_division_rhythm_maker,
    denominators=[8, 16],
    )
show(even_division_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

\begin{comment}
<abjad>
even_division_rhythm_maker = new(
    even_division_rhythm_maker,
    denominators=[8, 4, 16],
    )
show(even_division_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

\begin{comment}
<abjad>
even_division_rhythm_maker = new(
    even_division_rhythm_maker,
    denominators=[8],
    extra_counts_per_division=(0, 1),
    )
show(even_division_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

\begin{comment}
<abjad>
even_division_rhythm_maker = new(
    even_division_rhythm_maker,
    tie_specifier=rhythmmakertools.TieSpecifier(
        tie_across_divisions=True,
        ),
    )
show(even_division_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

\begin{comment}
<abjad>
even_division_rhythm_maker = new(
    even_division_rhythm_maker,
    denominators=[8, 4, 16],
    )
show(even_division_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

\begin{comment}
<abjad>
talea_rhythm_maker = rhythmmakertools.TaleaRhythmMaker(
    talea=rhythmmakertools.Talea(
        counts=[1],
        denominator=16,
        ),
    )
show(talea_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

\begin{comment}
<abjad>
talea_rhythm_maker = new(
    talea_rhythm_maker,
    talea__counts=[1, 2],
    )
show(talea_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

\begin{comment}
<abjad>
talea_rhythm_maker = new(
    talea_rhythm_maker,
    talea__counts=[1, 2, 3, 4],
    )
show(talea_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

\begin{comment}
<abjad>
talea_rhythm_maker = new(
    talea_rhythm_maker,
    extra_counts_per_division=[0, 1, 1],
    )
show(talea_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

\begin{comment}
<abjad>
talea_rhythm_maker = new(
    talea_rhythm_maker,
    tie_specifier=rhythmmakertools.TieSpecifier(
        tie_across_divisions=True,
        ),
    )
show(talea_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

\begin{comment}
<abjad>
talea_rhythm_maker = new(
    talea_rhythm_maker,
    burnish_specifier=rhythmmakertools.BurnishSpecifier(
        left_classes=[Rest, Note],
        left_counts=[1],
        ),
    )
show(talea_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

\subsection{Composite rhythm makers} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{comment}
<abjad>
composite_rhythm_maker = consort.CompositeRhythmMaker(
    default=talea_rhythm_maker,
    last=note_rhythm_maker,
    first=incised_rhythm_maker,
    )
show(composite_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Modeling meter}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Abjad models meter as a \emph{rhythm-tree} of nested, durated nodes which
outline a series of strongly and weakly accented offsets. The accent strength
of a particular offset found in a meter's rhythm-tree derives from the number
of nodes in that tree sharing that offset as a start or stop. The more nodes in
the rhythm-tree which share an offset, the greater the weight -- the
accentedness -- of that offset is taken to be. Abjad can construct the rhythm
tree for any meter from a numerator / denominator pair such as a rational
duration or time signature. Meter construction involves the progressive
division of the numerator of the input pair into groups of two and
threes\footnote{The factors 4 and 5 are also used in meter rhythm-tree
generation as they provide better typical results during meter rewriting.}, and
the decomposition of any other prime factors into groups of threes and twos.
Division by two always occurs before division by three, giving preference to
even metrical structures above odd or otherwise prime divisions. Constructing
rhythm-trees in this fashion gives results which generally align with common
practice expectations.

Consider the following 6/8 meter and its graph representation:

\begin{comment}
<abjad>
six_eight_meter = metertools.Meter((6, 8))
graph(six_eight_meter)
</abjad>
\end{comment}

\noindent The triangular and rectangular boxes indicate nodes in the
rhythm-tree itself. Rectangular boxes represent \enquote{beats} -- the leaves
of the rhythm-tree -- while triangular boxes indicate larger metrical
groupings. The ovals at the bottom of the graph indicate -- at their top -- the
start or stop offset of the nodes connected to them from above and -- at their
bottom -- the relative weight of their accent. The final oval on the right
indicates the offset and accent weight of the \enquote{next} downbeat.

The topmost triangle in the above graph represent the \enquote{highest}
metrical grouping in a 6/8 meter. Tracing the leftmost and rightmost arrows
down through the topmost node's children gives the offsets 0 and 3/4: the first
downbeat and next downbeat in a 6/8 meter. Offsets 0 and 3/4 also have the
strongest accent weights as they occur as either the start offset or stop
offset of nodes at three levels of hierarchy in the rhythm tree. At the second
level the 6/8 grouping divides into two 3/8 groupings, following common
practice expectations: metrical groupings tend to subdivide into groups of two
before they subdivide into groups of three\footnote{Consider a 12/8 meter.
Western musicians tend to subdivide twelve into either two groups of six or
four groups of three rather than into three groups of four.}. Both second-level
nodes share the offset of 3/8, which also occurs in the third level, giving 3/8
a weight of two. The third level contains the 1/8 duration beats, grouped by
their parents in the second level into two groups three 1/8 duration nodes. The
offsets 1/8, 1/4, 1/2 and 5/8 are not shared by any nodes except at the lowest
metrical level and therefore all receive an accent weight of one.

\subsection{Examples of meter} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Consider the following examples of meters modeled in Abjad.

A 3/4 meter consists of a top-level 3/4 metrical grouping divided into three
1/4 duration beats:

\begin{comment}
<abjad>
three_four_meter = metertools.Meter((3, 4))
graph(three_four_meter)
</abjad>
\end{comment}

\noindent By default, a 7/8 meter subdivides its top-level metrical grouping
into 3/8+2/8+2/8 groupings:

\begin{comment}
<abjad>
seven_eight_meter = metertools.Meter((7, 8))
graph(seven_eight_meter)
</abjad>
\end{comment}

\noindent A 12/8 meter subdivides into four 3/8 duration groupings, each
containining three 1/8 duration beats:

\begin{comment}
<abjad>
twelve_eight_meter = metertools.Meter((12, 8))
graph(twelve_eight_meter)
</abjad>
\end{comment}

\subsection{Alternate meter representations} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Abjad permits alternate representations of meters with the same numerator and
denominator. The default interpretation of 4/4 generates a top-level rhythmic
grouping with a duration of 4/4 and four 1/4 beats as children\footnote{A
\enquote{flat} 4/4 metrical structure is useful for meter rewriting as it
allows the meter rewriting algorithm to ignore many common rhythmic idioms like
1/4+1/2+1/4 and 1/4+3/4.}.

\begin{comment}
<abjad>
four_four_meter = metertools.Meter((4, 4))
graph(four_four_meter)
</abjad>
\end{comment}

\noindent While meter objects are usually instantiated from numerator /
denominator pairs, with their rhythm-tree structure determined programmatically
from that input pair, they can also be instantiated from strings parseable as
rhythm-trees, or from RhythmTree objects themselves. All meters, because they
are implemented in terms of rhythm-trees, can be represented by a Lisp-like
rhythm-tree syntax:

\begin{comment}
<abjad>
print(four_four_meter.pretty_rtm_format)
</abjad>
\end{comment}

Instantiating meters from explicit rhythm tree syntax allows composers to
choose alternate representations of metrical structures. For example, a 4/4
meter which strongly emphasizes beat three is possible by subdividing the
top-level 4/4 metrical grouping into two 2/4 duration groupings, which are then
subdivided each into two 1/4 duration beats:

\begin{comment}
<abjad>
arbitrary_meter_1 = metertools.Meter('(4/4 ((2/4 (1/4 1/4)) (2/4 (1/4 1/4))))')
graph(arbitrary_meter_1)
</abjad>
\end{comment}

\noindent Unusual metrical structures are also possible, such as the following
4/4 meter which divides into two parts, with the first part dividing into two
again, and the second grouping of that divided into two again:

\begin{comment}
<abjad>
arbitrary_meter_2 = metertools.Meter('(4/4 ((2/4 (1/4 (1/4 (1/8 1/8)))) 1/2))')
graph(arbitrary_meter_2)
</abjad>
\end{comment}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Rewriting meters}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Notated rhythms can be expressed in multiple ways while maintaining the same
attack-point and duration structure. \emph{Meter rewriting} formalizes the
process of re-notating a rhythm according to the offset structure inherent to
some meter while maintaining the original attack-points and durations.

Consider the following rhythm:

\begin{comment}
<abjad>
parseable = "abj: | 2/4 c'2 ~ |"
parseable += "| 4/4 c'32 d'2.. ~ d'16 e'32 ~ |"
parseable += "| 2/4 e'2 |"
staff = Staff(parseable)
show(staff)
</abjad>
\end{comment}

The middle measure is notated in a perfectly valid manner. However, the
double-dotted D does not align with or break against any of the offsets of a
4/4 metrical structure: 0/4, 1/4, 2/4, 3/4 or 4/4.

\begin{comment}
<abjad>
four_four_meter = metertools.Meter((4, 4))
graph(four_four_meter)
</abjad>
\end{comment}

\begin{comment}
<abjad>
mutate(staff[1][:]).rewrite_meter(four_four_meter)
show(staff)
</abjad>
\end{comment}

\begin{comment}
<abjad>
two_two_meter = metertools.Meter((2, 2))
staff = Staff(parseable)
mutate(staff[1][:]).rewrite_meter(two_two_meter)
show(staff)
</abjad>
\end{comment}

\subsection{Dot count} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{comment}
<abjad>
measure = Measure((3, 4), "c'32 d'8 e'8 fs'4...")
show(measure)
</abjad>
\end{comment}

\begin{comment}
<abjad>
mutate(measure[:]).rewrite_meter((3, 4))
show(measure)
</abjad>
\end{comment}

\begin{comment}
<abjad>
measure = Measure((3, 4), "c'32 d'8 e'8 fs'4...")
mutate(measure[:]).rewrite_meter((3, 4), maximum_dot_count=2)
show(measure)
</abjad>
\end{comment}

\begin{comment}
<abjad>
measure = Measure((3, 4), "c'32 d'8 e'8 fs'4...")
mutate(measure[:]).rewrite_meter((3, 4), maximum_dot_count=1)
show(measure)
</abjad>
\end{comment}

\begin{comment}
<abjad>
measure = Measure((3, 4), "c'32 d'8 e'8 fs'4...")
mutate(measure[:]).rewrite_meter((3, 4), maximum_dot_count=0)
show(measure)
</abjad>
\end{comment}

\subsection{Boundary depth} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{comment}
<abjad>
nine_eight_meter = metertools.Meter((9, 8))
graph(nine_eight_meter)
</abjad>
\end{comment}

\begin{comment}
<abjad>
measure = Measure((9, 8), "c'2 d'2 e'8")
show(measure)
</abjad>
\end{comment}

\begin{comment}
<abjad>
mutate(measure[:]).rewrite_meter(nine_eight_meter)
show(measure)
</abjad>
\end{comment}

\begin{comment}
<abjad>
measure = Measure((9, 8), "c'2 d'2 e'8")
mutate(measure[:]).rewrite_meter(
    nine_eight_meter,
    boundary_depth=1,
    )
show(measure)
</abjad>
\end{comment}

\subsection{Recursive meter rewriting} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{comment}
<abjad>
parseable = "abj: | 4/4 c'16 ~ c'4 d'8. ~ "
parseable += "2/3 { d'8. ~ 3/5 { d'16 e'8 ~ e'16 f'16 ~ } } "
parseable += "f'4 |"
measure = parse(parseable)
show(measure)
</abjad>
\end{comment}

\begin{comment}
<abjad>
mutate(measure[:]).rewrite_meter(
    measure,
    boundary_depth=1,
    )
show(measure)
</abjad>
\end{comment}

\subsection{Examples} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{comment}
<abjad>
staff = Staff(context_name='RhythmicStaff')
staff.extend("{ c'2 c'4 } { c'4. c'4. } { c'2 ~ c'8 c'8 }")
attach(TimeSignature((3, 4)), staff)
show(staff)
</abjad>
\end{comment}

\begin{comment}
<abjad>
for container in staff:
    mutate(container[:]).rewrite_meter((3, 4), boundary_depth=1)

show(staff)
</abjad>
\end{comment}

\begin{comment}
<abjad>
staff = Staff(context_name='RhythmicStaff')
staff.extend("{ c'2 c'4 } { c'4. c'4. } { c'2 ~ c'8 c'8 }")
attach(TimeSignature((6, 8)), staff)
for container in staff:
    mutate(container[:]).rewrite_meter((6, 8), boundary_depth=1)

show(staff)
</abjad>
\end{comment}

\begin{comment}
<abjad>
selections = talea_rhythm_maker(divisions)
lilypond_file = rhythmmakertools.make_lilypond_file(selections, divisions)
show(staff)
</abjad>
\end{comment}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Finding meters}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

How can we generate a series of meters?

A meter's weighted-offset pattern can be used as 1-dimensional kernel, or
convolution matrix, to determine how strongly an arbitrary collection of
offsets appears to express that meter. 

Abjad's \texttt{metertools} provides a \texttt{MetricAccentKernel} class.

\subsection{Offset counters} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Before convolving a meter with a collection of offsets, those offsets need to
be extracted and counted. Abjad's \texttt{metertools} provides an
\texttt{OffsetCounter} class which maps offsets against counts. Offset counters
can be instantiated from any expression containing offsets, or whose elements
can be expressed as timespans and therefore possess both start and stop
offsets. Offsets which appear multiple times in the input expression will
result in a higher count in the offset counter, and will in turn have a greater
influence during the meter convolution process.

Consider the following score example:

\begin{comment}
<abjad>
upper_staff = Staff("c'8 d'4. e'8 f'4.")
lower_staff = Staff(r'\clef bass c4 b,4 a,2')
piano_staff = scoretools.StaffGroup(
    [upper_staff, lower_staff],
    context_name='PianoStaff',
    )
show(piano_staff)
</abjad>
\end{comment}

\noindent The offsets found in all of the leaves of the score can be counted by
selecting the score's leaves and instantiating an offset counter from them.
Because all score components can be expressed as timespans via
\texttt{inspect\_(some\_component).get\_timespan()} the offset counter can
retrieve both their start and stop offsets within the score.

\begin{comment}
<abjad>
leaves = piano_staff.select_leaves(allow_discontiguous_leaves=True)
piano_staff_counter = metertools.OffsetCounter(leaves)
print(format(piano_staff_counter))
show(piano_staff_counter)
</abjad>
\end{comment}

\noindent Note that the offset 1/2 shows a count of 4. This is because 1/2 acts
as both the start and stop offset for four separate leaves in the score.

Offset counters can also be generated from timespan inventories, allowing meter
convolution to be used without reference to any score objects at all.

\begin{comment}
<abjad>
timespans = timespantools.TimespanInventory([
    timespantools.Timespan(-1, 10),
    timespantools.Timespan(5, 15),
    timespantools.Timespan(15, 20),
    timespantools.Timespan(10, 15),
    ])
timespan_counter = metertools.OffsetCounter(timespans)
show(timespan_counter)
</abjad>
\end{comment}

\subsection{Metric accent kernels} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

As demonstrated earlier, Abjad's model of meter describes a sequence of offsets
with varying degrees of weight -- accentedness -- attributed to each offset, as
determined by the hierarchical tree structure of that meter. This model allows
us to explain how downbeats have a stronger weight than upbeats, and how the
3/8 offset in a 6/8 measure is less strong than its downbeat but still stronger
than the offsets at 1/8, 2/8, 4/8 or 5/8. However, the default model of a 6/8
meter makes no explicit reference to offsets such as 1/16 or 3/16. A common
practice understanding of meter tells us that these offsets should be taken as
less accented than those at 1/8, 2/8, 3/8 and so forth. They effectively
represent an even lower level of leaves on the rhythm-tree for 6/8. Likewise,
offsets with a denominator of 32 or 64 should be explainable in an identical
fashion.

Abjad's \texttt{MetricAccentKernel} provides an object model for both the act
of progressively subdividing the weighted offsets of a meter down to some
arbitrary denominator, and for convolving those offsets as a one-dimensional
convolution kernel against an offset counter. This allows meters to be fitted
against offset counters containing offsets not explicitly modeled by those same
meters. Here a metric accent kernel is generated from a 4/4 meter, extending
its denominator to a limit of 1/16. The weights at each offset are normalized
such that they sum to 1.

\begin{comment}
<abjad>
meter = metertools.Meter((4, 4))
kernel_44 = metertools.MetricAccentKernel.from_meter(meter, denominator=16)
for offset, weight in sorted(kernel_44.kernel.items()):
    print('{!s}\t{!s}'.format(offset, weight))

</abjad>
\end{comment}

\noindent The 4/4 metric accent kernel can be called against an offset counter
-- as though it were a function -- to generate the convolution response. The
count at each offset in the input offset counter is multiplied against the
weight at the corresponding offset in the metric accent kernel. If no
corresponding offset exists in the kernel, the weight is taken as 0. The
weighted counts are then added together and returned.

\begin{comment}
<abjad>
response = kernel_44(piano_staff_counter)
float(response)
</abjad>
\end{comment}

\noindent The following loop demonstrates the logic underlying the meter
convolution process.

\begin{comment}
<abjad>
total = Multiplier(0, 1)
for offset, count in sorted(piano_staff_counter.items()):
    weight = Multiplier(0, 1)
    if offset in kernel_44.kernel:
        weight = kernel_44.kernel[offset]
    weighted_count = weight * count
    total += weighted_count
    print(offset, count, weight, weighted_count, total)

</abjad>
\end{comment}

\noindent Now consider the metric accent kernels for 3/4, 7/8 and 5/4 meters:

\begin{comment}
<abjad>
kernel_34 = metertools.MetricAccentKernel.from_meter((3, 4), denominator=16)
kernel_78 = metertools.MetricAccentKernel.from_meter((7, 8), denominator=16)
kernel_54 = metertools.MetricAccentKernel.from_meter((5, 4), denominator=16)
</abjad>
\end{comment}

\noindent We can generate an response for each of these kernels against the
piano staff offset counter.

\begin{comment}
<abjad>
float(kernel_34(piano_staff_counter))
float(kernel_78(piano_staff_counter))
float(kernel_54(piano_staff_counter))
</abjad>
\end{comment}

\noindent Note that the previously recorded response for a 4/4 meter is still
higher than any of these three responses.

\subsection{Meter fitting} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Meter fitting involves the progressive comparison of a collection of permitted
meters against the offsets and weights in an offset counter. Starting from the
lowest offset, the accent kernel for each meter is applied against all those
offsets which it overlaps. The response from each comparison is recorded and
the meter with the highest associated response is selected to represent those
offsets. The process repeats, starting at the right-most offset of the last
meter selected, until no more offsets remain to compare against.

The following offsets are separated from one another by the duration of a whole
note, outlining the start and stop offsets of a series of 4/4 meters.

\begin{comment}
<abjad>
offset_counter = metertools.OffsetCounter([
    (0, 4), (4, 4), (8, 4), (12, 4), (16, 4),
    ])
show(offset_counter, range_=(0, 5))
</abjad>
\end{comment}

\noindent Given the following collection of meters, after meter fitting is
performed, only 4/4 meters should be selected because they perfectly align with
the previously defined collection of offsets.

\begin{comment}
<abjad>
permitted_meters = metertools.MeterInventory([(3, 4), (4, 4), (5, 4)])
show(permitted_meters, range_=(0, 5))
fitted_meters = metertools.Meter.fit_meters_to_expr(
    expr=offset_counter,
    meters=permitted_meters,
    )
show(fitted_meters, range_=(0, 5))
</abjad>
\end{comment}

\noindent If we change the input offsets to no longer outline only 4/4 meters,
the meter fitting process will provide different output. Note how the fitted
meters emphasize the 3/4 and 5/4 durations inherent to the input offsets. The
initial 3/4 fitted meter perfectly matches the offsets 0/1 and 3/4, while the
following 4/4 meter matches the 5/4 offset against its third beat. The
following 3/4 meter's right-most offset aligns against the 5/2 offset allowing
the meter fitting process to match the remaining offsets against a pair of 5/4
meters.

\begin{comment}
<abjad>
offset_counter = metertools.OffsetCounter([
    (0, 4), (3, 4), (5, 4), (10, 4), (15, 4), (20, 4),
    ])
fitted_meters = metertools.Meter.fit_meters_to_expr(
    expr=offset_counter,
    meters=permitted_meters,
    )
show(offset_counter, range_=(0, 5))
show(fitted_meters, range_=(0, 5))
</abjad>
\end{comment}

\noindent Meter fitting can control for how many times meters are permitted to
immediately repeat. The above example ends with two 5/4 meters in a row. If
desired, this repetition can be prevented entirely by the
\texttt{maximum\_run\_length} keyword to
\texttt{Meter.fit\_meters\_to\_expr()}. A pair of 3/4 and 4/4 meters replace
the previously final 5/4 meter.

\begin{comment}
<abjad>
fitted_meters = metertools.Meter.fit_meters_to_expr(
    expr=offset_counter,
    meters=permitted_meters,
    maximum_run_length=1,
    )
show(fitted_meters, range_=(0, 5))
</abjad>
\end{comment}

\subsection{Example}

The output of timespan makers motivates meter fitting more forcefully than the
above trivial examples. Densely layered timespan-based textures often involve
hundreds or thousands of offsets with many points of simultaneity or overlap.
Careful management of meter fitting can result in convincing metrical
solutions to these textures.

Recall the quartet timespan texture from earlier in this chapter.

\begin{comment}
<abjad>
music_specifiers = collections.OrderedDict([
    ('Voice 1', None),
    ('Voice 2', None),
    ('Voice 3', None),
    ('Voice 4', None),
    ])
target_timespan = timespantools.Timespan(0, (19, 4))
timespan_inventory = talea_timespan_maker(
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
show(timespan_inventory, key='voice_name')
</abjad>
\end{comment}

\noindent Constructing an offset counter from this timespan inventory shows
several offsets with strong simultaneities.

\begin{comment}
<abjad>
offset_counter = metertools.OffsetCounter(timespan_inventory)
show(offset_counter, range_=(0, (19, 4)))
</abjad>
\end{comment}

\begin{comment}
<abjad>
permitted_meters = metertools.MeterInventory([
    (5, 8), (3, 4), (6, 8), (7, 8), (4, 4),
    ])
fitted_meters = metertools.Meter.fit_meters_to_expr(
    expr=offset_counter,
    meters=permitted_meters,
    maximum_run_length=1,
    )
show(offset_counter, range_=(0, (19, 4)))
show(fitted_meters, range_=(0, (19, 4)))
</abjad>
\end{comment}

\noindent Removing the 5/8 meter from the permitted meters inventory gives less
convincing results. Notably, the strong simultaneities at offsets 11/8 and 17/8
no longer align with any downbeats in the fitted meters.

\begin{comment}
<abjad>
permitted_meters = metertools.MeterInventory([
    (3, 4), (6, 8), (7, 8), (4, 4),
    ])
fitted_meters = metertools.Meter.fit_meters_to_expr(
    expr=offset_counter,
    maximum_run_length=1,
    meters=permitted_meters,
    )
show(offset_counter, range_=(0, (19, 4)))
show(fitted_meters, range_=(0, (19, 4)))
</abjad>
\end{comment}

\noindent Lifting the constraint on meter repetition does not improve the
results. Both the 11/8 and 17/8 offsets still align with weak beats in the
fitted meters. The only real change is the swapping of 6/8 and 3/4 meters in
the first and last pairs of fitted meters.

\begin{comment}
<abjad>
fitted_meters = metertools.Meter.fit_meters_to_expr(
    expr=offset_counter,
    meters=permitted_meters,
    )
show(offset_counter, range_=(0, (19, 4)))
show(fitted_meters, range_=(0, (19, 4)))
</abjad>
\end{comment}

\noindent However, reinstating the repetition constraint and permitting a
greater variety of meters gives an even closer fitting than the very first
example. Not only do the 11/8 and 17/8 offsets align at downbeats, but the
three-weight offset at 25/8 matches the downbeat of a 3/4 meter with two-weight
accents on both its second and third beat as well as the following downbeat.

\begin{comment}
<abjad>
permitted_meters = metertools.MeterInventory([
    (2, 4), (4, 8), (3, 4), (6, 8), (7, 8), (4, 4),
    ])
fitted_meters = metertools.Meter.fit_meters_to_expr(
    expr=offset_counter,
    maximum_run_length=1,
    meters=permitted_meters,
    )
show(offset_counter, range_=(0, (19, 4)))
show(fitted_meters, range_=(0, (19, 4)))
</abjad>
\end{comment}

\noindent Increasing the number of permitted offsets even further does not
necessarily improve results. A better initial meter fitting -- like the initial
9/8 here -- often diminishes the choices possible afterward.

\begin{comment}
<abjad>
permitted_meters = metertools.MeterInventory([
    (2, 4), (3, 16), (3, 4), (4, 4), (4, 8), (5, 16),
    (5, 4), (5, 8), (6, 8), (7, 8), (9, 8),
    ])
poorly_fitted_meters = metertools.Meter.fit_meters_to_expr(
    expr=offset_counter,
    maximum_run_length=1,
    meters=permitted_meters,
    )
show(offset_counter, range_=(0, (19, 4)))
show(poorly_fitted_meters, range_=(0, (19, 4)))
</abjad>
\end{comment}

\noindent The process of meter fitting described here is not perfect. While
useful for creating generally convincing metrical solutions to dense timespan
structures, meter fitting could probably be better solved through human
intervention. The fitting process often over-emphasizes local attack point
maxima while ignoring larger or more elegant metrical patterns. Likewise, the
process often provides an accurate fitting for the very first meter, but causes
a cascade of poor solutions for every following meter. Where procedural meter
fitting wins over human intervention is in speed. Solutions to enormous
timespan inventories with hundreds or thousands of timespans can be found in
less than a second, facilitating the rapid sketching and revising of
timespan-based musical structures.

Meter fitting can be considered as a kind of constraint problem. The set of
permitted meters act as a search space while each progressive selection of
offsets from the input offset counter act as the problem to solve against. In
that light, improvements might involve searching for meter solutions with
increased \emph{lookahead} -- that is, fitting the current meter based not only
on its response to a selection of offsets, but also on how well any meter
following it would score. Searching the offset counter for patterns, changing
the weighting algorithm of metric accent kernels, or jumping directly to the
attack point maxima in the input offset counter and solving forwards and
backwards from them are also possible avenues for improvement.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Synthesizing time techniques}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The techniques outlined in this chapter -- timespan inventories,
timespan-makers, rhythm-makers, meter fitting and rewriting -- describe various
ways of modeling, creating and manipulating aspects of musical score. Taken
separately, none of them can ever result in the rhythmic framework for a
polyphonic piece of music. However, by combining all of them together, it is
possible to construct powerful tools for generating arbitrarily large amounts
of notation.

The following \texttt{build\_score()} function outlines one possible approach
to combining these techniques. This function creates a score from a
rhythm-maker, a sequence of permitted meters, a score template and a timespan
inventory. The timespan inventory must contain performed timespans whose voice
names align with the voice names in the score produced by the score template.
For example, Abjad's \texttt{GroupedRhythmicStavesScoreTemplate} class can
produce scores containing voices with names like \enquote{Voice 1},
\enquote{Voice 2} and so forth. The timespan inventory used for this example --
created earlier in this chapter -- contains performed timespans with the voice
names \enquote{Voice 1}, \enquote{Voice 2}, \enquote{Voice 3} and
\enquote{Voice 4}, requiring a score template capabable of creating scores with
four staves of one voice each.

\begin{comment}
<abjad>
show(timespan_inventory, key='voice_name')
score_template = templatetools.GroupedRhythmicStavesScoreTemplate(
    staff_count=4, with_clefs=True,
    )
score = score_template()
print(format(score))
</abjad>
\end{comment}

Score building proceeds by first fitting the permitted meters against the
timespan inventory and calculating their meter boundaries -- the offsets of
each downbeat as well as the virtual downbeat after the final meter. Then the
timespans in the timespan inventory are grouped into a dictionary of separate
inventories according to their associated voice names. A score is produced by
the score template in order to be populated, and the voice components in this
score are iterated over. For each iterated voice, an inventory of timespans is
retrieved from the \texttt{all\_voicewise\_timespans} dictionary. If no
inventory exists, an empty one is created. The associated performed timespans
are partitioned into contiguous groups in order to facilitate rhythm
generation. Each partitioned group is passed, along with the input rhythm
maker, the fitted meter boundaries, and a seed value -- the number of performed
timespan groups encountered so far -- to a rhythm generation subroutine, with
the resulting phrase container appended into the current voice. If a gap is
encountered between two partitioned groups, between the beginning of the first
partitioned group and the beginning of the score -- the offset 0, or between
the end of the last partitioned group and the final meter boundary, "silent
music" will be created in the form of rests grouped into a container, with that
container then inserted into the current voice.

\begin{comment}
<abjadextract dissertation.py.time_tools:build_score />[strip_prompt]
\end{comment}

\noindent A meter sequence of equal or greater duration to the input timespan
inventory can be produced through fitting a collection of permitted meters
against that same input timespan inventory. The sequence of offsets found at
the boundaries of each fitted meter can then be determined by computing the
cumulative sums of the durations of the fitted meters. These boundary offsets
will be used to split timespans before they are fed to rhythm-makers for rhythm
generation in order to ensure that no generated rhythm crosses any barlines.

\begin{comment}
<abjadextract dissertation.py.time_tools:get_meters_and_meter_boundaries />[strip_prompt]
\end{comment}

\noindent Each of the performed timespans in the input timespan inventory was
configured with a voice name, allowing that timespan to be associated with a
voice context in the score hierarchy produced by the input score template. As
demonstrated earlier, Abjad components can be indexed by context name
regardlesss of the depth of the named context in the score hierarchy.

\begin{comment}
<abjad>
timespan = timespan_inventory[0]
print(format(timespan))
score = score_template()
voice = score[timespan.voice_name]
for component in inspect_(voice).get_parentage():
    component

</abjad>
\end{comment}

\noindent In order to populate each voice in the score, the timespans in the
timespan inventory need to be separated into \emph{voice-wise} timespan
inventories, each only containing timespans associated with the same voice.
This can be accomplished by building a dictionary whose keys are voice names
and whose values are timespan inventories.

\begin{comment}
<abjadextract dissertation.py.time_tools:get_all_voicewise_timespans />[strip_prompt]
\end{comment}

\noindent Creating \emph{performed} music requires first splitting a contiguous
inventory of performed timespans by meter boundaries, collecting the shards
together into a new inventory and then calculating the durations of those
timespans. The resulting sequence of durations, along with an input
rhythm-maker and an optional seed value can be sent to another function for
rhythm generation.

\begin{comment}
<abjadextract dissertation.py.time_tools:make_performed_music />[strip_prompt]
\end{comment}

\noindent Similarly, \emph{silent} music -- rests between groups of performed
timespans in each voice -- can be created by constructing a timespan which
outlines the gap between other performed timespans, splitting that timespan by
meter boundaries, collecting the durations of the split shards, and finally
passing those durations along with a rest-generating rhythm-maker to another
function for rhythm generation.

\begin{comment}
<abjadextract dissertation.py.time_tools:make_silent_music />[strip_prompt]
\end{comment}

\noindent Both silent and performed music generation relies on the same core
rhythm generating function. This function calls its input rhythm-maker with a
sequence of durations and an optional seed value, which may be interpreted
variably depending on what kind of rhythm-maker was used, but which generally
results in the rotation of any sequence-like configured value in that
rhythm-maker, such as talea. The product of this first operation is a sequence
of component selections. Some massaging converts this selections into a
sequence of trivially-prolated containers and non-trivially prolated tuplets
which can then be wrapped inside a larger container representing a complete
phrase.

\begin{comment}
<abjadextract dissertation.py.time_tools:make_music />[strip_prompt]
\end{comment}

\noindent After all phrases for a voice have been generated, their meters are
rewritten. This process involves simultaneously iterating through both the
divisions in each phrase along with pairs of meters and meter downbeat
offsets -- that is, the offset from the origin of the score where each meter
begins.\footnote{More optimizations to this joint container / meter iteration
are obviously possible. Some have even been implemented in Consort's source.
Such optimization include associating meters with their own timespans, and
storing these meter-timespans in an optimized interval-tree datastructure
allowing rapid retrieval by both offset and timespan intersection. For the sake
of pedagogical clarity, a more naive approach is used here.} Un-prolated
division containers are rewritten according to the meter active when they
begin. Because a division may start \emph{after} a meter has begun it is
necessary to calculate the difference between each un-prolated division's start
offset and each meter's start offset. This difference is passed to the
\texttt{MutationAgent}'s \texttt{rewrite\_meter()} method via the
\texttt{initial\_offset} keyword, allowing the division to be properly aligned
against the desired meter. Prolated divisions -- tuplets -- are rewritten
solely with respect to the duration of their contents, not to the prevailing
meter. That is, a 5:4 tuplet in a 4/8 measure is rewritten with a meter of 5/8,
not of 4/8.

\begin{comment}
<abjadextract dissertation.py.time_tools:rewrite_meters />[strip_prompt]
\end{comment}

\noindent The final step in this score building process adds a \enquote{floating time
signature context} to the score, filled with typographic spacer skips and time
signature commands, one for each of the fitted meters. This context appears as
a row of time signatures floating above the topmost staff in the score,
allowing time signatures to be omitted from every staff in the score and
thereby improving proportional notation spacing. The time signature context's
\texttt{context\_name} property instructs LilyPond to look for a context
definition with that name and apply any typographic overrides found there
during the typesetting process. While LilyPond does not come packaged with a
\texttt{TimeSignatureContext} definition, examples of what such a definition
looks like can be found in the various \texttt{stylesheet} sections of the
source code appendices to this document.

\begin{comment}
<abjadextract dissertation.py.time_tools:add_time_signature_context />[strip_prompt]
\end{comment}

\noindent Calling the \texttt{build\_score()} function generates a score as
described above. In this example, the function's arguments comprise a talea
rhythm-maker, an inventory of meters, as well as the previously defined score
template and timespan inventory.

\begin{comment}
<abjad>
permitted_meters = metertools.MeterInventory([
    (2, 4), (4, 8), (3, 4), (6, 8), (7, 8), (4, 4),
    ])
performed_rhythm_maker = rhythmmakertools.TaleaRhythmMaker(
    beam_specifier=rhythmmakertools.BeamSpecifier(
        beam_each_division=True,
        beam_divisions_together=True,
        ),
    extra_counts_per_division=(0, 1),
    talea=rhythmmakertools.Talea([1, 2, 3, 4, 5], 16),
    )
show(performed_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

\noindent For clarity, the phrases and their internal divisions have been
annotated via Consort's \texttt{annotate} function. This function draws thick
brackets underneath each staff, with the lower bracket indicating the overall
phrase grouping and the inner brackets indicating divisions within each phrase.
Entirely silent phrasing brackets are drawn with dashed rather than solid
lines.

\begin{comment}
<abjad>[stylesheet=../consort-small.ily]
score = build_score(
    performed_rhythm_maker=performed_rhythm_maker,
    permitted_meters=permitted_meters,
    score_template=score_template,
    timespan_inventory=timespan_inventory,
    )
consort.annotate(score)
show(score)
</abjad>
\end{comment}

\noindent Large-scale variations are possible simply by altering the arguments
to the \texttt{build\_score()} function. For example, the timespan inventory
can be reflected around its axis and stretched from a duration of 19/4 to 25/4.
This will change the overall duration and phrase density of the resulting score
while maintaining the character of its surface rhythms.

\begin{comment}
<abjad>[stylesheet=../consort-small.ily]
multiplier = Duration(24, 4) / Duration(19, 4)
timespan_inventory = timespan_inventory.reflect()
timespan_inventory = timespan_inventory.stretch(multiplier)
timespan_inventory = timespan_inventory.round_offsets(Duration(1, 8))
score = build_score(
    performed_rhythm_maker=performed_rhythm_maker,
    permitted_meters=permitted_meters,
    score_template=score_template,
    timespan_inventory=timespan_inventory,
    )
consort.annotate(score)
show(score)
</abjad>
\end{comment}

\noindent Other variations and extensions are possible. The input rhythm-maker
could be varied or replaced by a composite rhythm-maker. The score generation
process could be extended so that rhythm-makers could be stored on the
performed timespans themselves, allowing each performed timespan to specify its
local rhythmic language. Multiple timespan inventories could be combined
together using the various logical operations to implement masking or fusing
when timespans from one inventory overlap those from another. In fact, all of
these extensions and variations are employed in Consort's own score generation
process.

Timespans allow for large scale phrasing and density structures. Timespan
annotations allow for maquette-like composition techniques, or working in a way
that conceptually mirrors working with a DAW, even though there is no real
graphic output except for notation itself. Annotations can act as a description
of what sort of material should appear in what locations -- both horizontally
in time and vertically in the score hierarchy. Timespans also allow for
overlap, and have affordances for masking. This allows timespans to be created
by a factories in layers, and those layers resolved down to a single
non-overlapping layer via masking.