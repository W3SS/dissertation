%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Modeling time, rhythm and meter}
\label{chap:time-tools}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{comment}
<abjad>[hide=true]
import collections
import consort
</abjad>
\end{comment}

\eblettrinedbl{C}{onsort is an open-source Python package} extending Abjad and
implementing a model of composition which relies on a number of interrelated
but distinct approaches to working with musical time. For example, Abjad's
\emph{timespans} suggests a \enquote{coarse} approach to musical time. These
objects represent arbitrary durated events on a timeline, without respect for
score hierarchy or meter. They are well-suited for modeling large-scale
phrasing and gestural density structures and can be transformed through
splitting, scaling, stretching, and translation among various other
manipulations. Because they have no notational reality, they can model temporal
concepts unsuited to notated music -- without introducing additional
complexity--, such as arbitrarily overlapping events. Timespans may also be
annotated, allowing composers to position metadata anywhere on a timeline, much
like arranging audio regions in a DAW.\cite{curtis1996computer} Moreover, every
durated object in a score hierarchy can be described as a timespan, allowing
score components to engage in abstract time relations. In contrast, notated
rhythms, composed of note, rest, tie and tuplet objects -- among others--,
provide the most \enquote{fine-grained} approach to musical time. While
incredibly expressive, fully notated rhythms are potentially complex to create,
and must ultimately be anchored in a score hierarchy. Highly-configurable
\emph{rhythm-maker} objects ameliorate the complexity of creating notated
rhythms by providing a high-level interface to the process of rhythm
generation. Abjad's hierarchical model of \emph{meter} coordinates time and
rhythm vertically across different levels of depth in the score tree, and
bridges Consort's coarse and fine stages of rhythmic interpretation. Meter
sequences can be generated from timespan-based phrase structures, and those
meter sequences used to transform notated rhythms in turn. A thorough
discussion of the implementation of these time models and their implications
will clarify an analysis in \autoref{chap:a-model-of-composition} of Consort's
\emph{score interpretation stage}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Timespans}
\label{sec:timespans}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\emph{Timespans} model left-closed / right-open intervals of time positioned
absolutely along a timeline. Every timespan describes a range
of offsets $x$ starting with -- and including -- some start offset $A$ and
leading up to -- but \emph{not} including -- some stop offset $B$:

\begin{equation}
A \leq x < B
\end{equation}

Note that all leaves in a score describe such half-bounded intervals of time.
Adjacent notes in a score do not overlap but rather abut one another because
their timespans do not overlap. In fact, every durated object in a score --
every note, chord, rest, measure, staff, and even the score itself -- can be
described in terms of timespans. Yet, while score objects can always be
expressed as timespans, those timespans themselves do not -- by definition
-- refer to any score objects. Abjad implements timespans as immutable
constants, much like Abjad's \texttt{Pitch} and \texttt{Duration} objects, and
similarly to Python's implementation of numbers and strings. Constancy allows
timespans to avoid a variety of computational reference problems. For example,
multiple objects can reference the same timespan without fear of that timespan
changing state, much as multiple objects can reference the integer 11 without
fear that that same integer will change into the integer 5.

%\todo[inline]{\textbf{TODO:} Emphasize and clarify set-theoretic definition of
%timespans in terms of offsets.}

Abjad implements timespans via the \texttt{Timespan} class in its
\texttt{timespantools} library. The following code shows the definition of a
timespan object beginning at the offset \sfrac[big]{1}{4} and continues up until the
offset \sfrac[big]{3}{2}:

\begin{comment}
<abjad>
timespan = timespantools.Timespan(
    start_offset=Offset(1, 4),
    stop_offset=Offset(3, 2),
    )
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> timespan = timespantools.Timespan(
...     start_offset=Offset(1, 4),
...     stop_offset=Offset(3, 2),
...     )
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Like many objects in Abjad, timespan can be formatted for
human-readable textual inspection, or displayed as a graphic illustration:

\begin{comment}
<abjad>
print(format(timespan))
show(timespan)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> print(format(timespan))
timespantools.Timespan(
    start_offset=durationtools.Offset(1, 4),
    stop_offset=durationtools.Offset(3, 2),
    )
\end{minted}
\begin{minted}{pycon}
>>> show(timespan)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-de7556a2817f1c5982b6b5e8d10f5be8.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent The \texttt{Timespan} class provides a large number of methods and
properties for inspecting timespans, comparing them to other timespans or
offsets, and for operating on timespans to generate new timespans. Once
instantiated, a timespan can be examined for its start offset, stop offset
and duration. Because of the \texttt{Timespan} class' immutability, these
properties are read-only and therefore can only be accessed, but not changed:

\begin{comment}
<abjad>
timespan.start_offset
timespan.stop_offset
timespan.duration
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> timespan.start_offset
Offset(1, 4)
\end{minted}
\begin{minted}{pycon}
>>> timespan.stop_offset
Offset(3, 2)
\end{minted}
\begin{minted}{pycon}
>>> timespan.duration
Duration(5, 4)
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent A timespan's start offset must be equal to or less than its stop
offset. Timespans with identical start and stop offsets have a duration of 0
and effectively model a single time-point. Such timespans are considered not
\enquote{well-formed}:

\begin{comment}
<abjad>
timepoint_timespan = timespantools.Timespan(1, 1)
timepoint_timespan.duration
timepoint_timespan.is_well_formed
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> timepoint_timespan = timespantools.Timespan(1, 1)
>>> timepoint_timespan.duration
Duration(0, 1)
\end{minted}
\begin{minted}{pycon}
>>> timepoint_timespan.is_well_formed
False
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Both the \texttt{start\_offset} and \texttt{stop\_offset} keywords to
the \texttt{Timespan} class' initializer are optional, and default to Abjad's
built-in rational constants \texttt{NegativeInfinity} and \texttt{Infinity}
respectively. A timespan created without specifying either a start or stop
offset effectively describes the timespan which encompasses all possible
offsets in time:

\begin{comment}
<abjad>
infinite_timespan = timespantools.Timespan()
infinite_timespan.start_offset
infinite_timespan.stop_offset
infinite_timespan.duration
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> infinite_timespan = timespantools.Timespan()
>>> infinite_timespan.start_offset
NegativeInfinity
\end{minted}
\begin{minted}{pycon}
>>> infinite_timespan.stop_offset
Infinity
\end{minted}
\begin{minted}{pycon}
>>> infinite_timespan.duration
Infinity
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent By specifying only a start or stop offset, timespans can also be
created which encompass the infinite set of offsets up until some stop offset,
or the infinite set of offsets starting at and following some start-offset:

\begin{comment}
<abjad>
timespantools.Timespan(stop_offset=0)
timespantools.Timespan(start_offset=0)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> timespantools.Timespan(stop_offset=0)
Timespan(start_offset=NegativeInfinity, stop_offset=Offset(0, 1))
\end{minted}
\begin{minted}{pycon}
>>> timespantools.Timespan(start_offset=0)
Timespan(start_offset=Offset(0, 1), stop_offset=Infinity)
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent \texttt{Timespan} objects also partake in Abjad's templating regime.
New timespans can be created from old ones through the use of the top-level
\texttt{new()} function:

\begin{comment}
<abjad>
new(timespan, stop_offset=(5, 16))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> new(timespan, stop_offset=(5, 16))
Timespan(start_offset=Offset(1, 4), stop_offset=Offset(5, 16))
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Note that the above timespans have been configured from input in
various formats, such as explicit \texttt{Offset} objects, integers, and even
numerator/denominator pairs. Timespans always coerce arguments given for their
\texttt{start\_offset} and \texttt{stop\_offset} properties into explicit
\texttt{Offset} instances. Abjad's other classes and functions implement
similar offset, duration, and even pitch-coercion behavior pervasively.

\subsection{Annotated timespans} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{ssec:annotated-timespans}

While the \texttt{Timespan} class only has two configurable properties -- its
start offset and stop offset --, subclassing allows for the creation of new
classes with the same core functionality as \texttt{Timespan} but extended to
support new behaviors and configurations. As an example, Abjad's
\texttt{timespantools} library provides an \texttt{AnnotatedTimespan} class
which subclasses \texttt{Timespan} but adds a third read-only
\texttt{annotation} property, which can be configured with any arbitrary
object:

\begin{comment}
<abjad>
annotated_timespan = timespantools.AnnotatedTimespan(
    start_offset=(1, 8),
    stop_offset=(7, 8),
    annotation='Any arbitrary object can act as an annotation.'
    )
annotated_timespan.annotation
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> annotated_timespan = timespantools.AnnotatedTimespan(
...     start_offset=(1, 8),
...     stop_offset=(7, 8),
...     annotation='Any arbitrary object can act as an annotation.'
...     )
>>> annotated_timespan.annotation
'Any arbitrary object can act as an annotation.'
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Annotated timespans allow composers to position annotations or any
other metadata along a timeline. If the annotation object is itself a mutable
data structure such as a Python list or dictionary, that annotation can be used
to store increasing amounts of information during the compositional process.
Additionally, Abjad's top-level \texttt{new()} function can be used to template
new annotated timespans from old ones, replacing one annotation with another
while preserving temporal information. If that same annotation object supports
templating, nested reconfiguration can be performed:

\begin{comment}
<abjad>
metadata_timespan = new(annotated_timespan,
    stop_offset=(3, 2),
    annotation={
        'durations': ((1, 8), (1, 8), (3, 16)),
        'dynamic': indicatortools.Dynamic('ppp'),
        'pitch_segment': pitchtools.PitchSegment([0, 1, 4, 7]),
        },
    )
metadata_timespan.annotation['bow_contact_point'] = Multiplier(1, 3)
print(format(metadata_timespan))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> metadata_timespan = new(annotated_timespan,
...     stop_offset=(3, 2),
...     annotation={
...         'durations': ((1, 8), (1, 8), (3, 16)),
...         'dynamic': indicatortools.Dynamic('ppp'),
...         'pitch_segment': pitchtools.PitchSegment([0, 1, 4, 7]),
...         },
...     )
>>> metadata_timespan.annotation['bow_contact_point'] = Multiplier(1, 3)
>>> print(format(metadata_timespan))
timespantools.AnnotatedTimespan(
    start_offset=durationtools.Offset(1, 8),
    stop_offset=durationtools.Offset(3, 2),
    annotation={
        'bow_contact_point': durationtools.Multiplier(1, 3),
        'durations': (
            (1, 8),
            (1, 8),
            (3, 16),
            ),
        'dynamic': indicatortools.Dynamic(
            name='ppp',
            ),
        'pitch_segment': pitchtools.PitchSegment(
            (
                pitchtools.NumberedPitch(0),
                pitchtools.NumberedPitch(1),
                pitchtools.NumberedPitch(4),
                pitchtools.NumberedPitch(7),
                ),
            item_class=pitchtools.NumberedPitch,
            ),
        },
    )
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Other \texttt{Timespan} subclasses are possible, allowing for even
more configurable properties, as well as new methods. Two \texttt{Timespan}
subclasses discussed later, \texttt{consort.PerformedTimespan} and
\texttt{consort.SilentTimespan}, are core components in Consort's score
interpretation stage.

\subsection{Time relations} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{ssec:time-relations}

\emph{Time relations} model the disposition of one timespan relative to
another timespan or offset. These relationships include intersection,
containment, simultaneous start offsets or stop offsets, and many others.
Abjad's \texttt{timespantools} library provides a \texttt{TimeRelation} class
and a collection of factory methods for configuring \texttt{TimeRelation}
instances which formalize all possible dispositions of a timespan relative
another timespan or offset\footnote{The thirty-three time relation factory
functions contained in \texttt{timespantools} are
\texttt{offset\_happens\_after\_timespan\_starts()},
\texttt{offset\_happens\_after\_timespan\_stops()},
\texttt{offset\_happens\_before\_timespan\_starts()},
\texttt{offset\_happens\_before\_timespan\_stops()},
\texttt{offset\_happens\_during\_timespan()},
\texttt{offset\_happens\_when\_timespan\_starts()},
\texttt{offset\_happens\_when\_timespan\_stops()},
\texttt{timespan\_2\_contains\_timespan\_1\_improperly()},
\texttt{timespan\_2\_curtails\_timespan\_1()},
\texttt{timespan\_2\_delays\_timespan\_1()},
\texttt{timespan\_2\_happens\_during\_timespan\_1()},
\texttt{timespan\_2\_intersects\_timespan\_1()},
\texttt{timespan\_2\_is\_congruent\_to\_timespan\_1()},
\texttt{timespan\_2\_overlaps\_all\_of\_timespan\_1()},
\texttt{timespan\_2\_overlaps\_only\_start\_of\_timespan\_1()},
\texttt{timespan\_2\_overlaps\_only\_stop\_of\_timespan\_1()},
\texttt{timespan\_2\_overlaps\_start\_of\_timespan\_1()},
\texttt{timespan\_2\_overlaps\_stop\_of\_timespan\_1()},
\texttt{timespan\_2\_starts\_after\_timespan\_1\_starts()},
\texttt{timespan\_2\_starts\_after\_timespan\_1\_stops()},
\texttt{timespan\_2\_starts\_before\_timespan\_1\_starts()},
\texttt{timespan\_2\_starts\_before\_timespan\_1\_stops()},
\texttt{timespan\_2\_starts\_during\_timespan\_1()},
\texttt{timespan\_2\_starts\_when\_timespan\_1\_starts()},
\texttt{timespan\_2\_starts\_when\_timespan\_1\_stops()},
\texttt{timespan\_2\_stops\_after\_timespan\_1\_starts()},
\texttt{timespan\_2\_stops\_after\_timespan\_1\_stops()},
\texttt{timespan\_2\_stops\_before\_timespan\_1\_starts()},
\texttt{timespan\_2\_stops\_before\_timespan\_1\_stops()},
\texttt{timespan\_2\_stops\_during\_timespan\_1()},
\texttt{timespan\_2\_stops\_when\_timespan\_1\_starts()},
\texttt{timespan\_2\_stops\_when\_timespan\_1\_stops()} and
\texttt{timespan\_2\_trisects\_timespan\_1()}. }. Time relations may be
configured with or without reference to any timespans or offsets at all,
allowing for the possibility of modeling a purely abstract time relationship:

\begin{comment}
<abjad>
time_relation_1 = timespantools.timespan_2_intersects_timespan_1()
print(format(time_relation_1))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> time_relation_1 = timespantools.timespan_2_intersects_timespan_1()
>>> print(format(time_relation_1))
timespantools.TimespanTimespanTimeRelation(
    inequality=timespantools.CompoundInequality(
        [
            timespantools.CompoundInequality(
                [
                    timespantools.SimpleInequality('timespan_1.start_offset <= timespan_2.start_offset'),
                    timespantools.SimpleInequality('timespan_2.start_offset < timespan_1.stop_offset'),
                    ],
                logical_operator='and',
                ),
            timespantools.CompoundInequality(
                [
                    timespantools.SimpleInequality('timespan_2.start_offset <= timespan_1.start_offset'),
                    timespantools.SimpleInequality('timespan_1.start_offset < timespan_2.stop_offset'),
                    ],
                logical_operator='and',
                ),
            ],
        logical_operator='or',
        ),
    )
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent The above intersection relationship between the timespans $[a, b)$
and $[c, d)$ can be described more pithily by the following predicate:

\begin{equation}
(a \leq c \land c < b) \lor (c \leq a \land a < d)
\end{equation}

\noindent A \enquote{half-configured} time relation is also possible. Such an
object acts as a kind of \enquote{frozen} predicate. Calling the time
relation as though it was a function\footnote{Any class in Python can be made
treatable as a function by implementing a \texttt{\_\_call\_\_()} method.} on
another timespan or offset returns a truth value:

\begin{comment}
<abjad>
time_relation_2 = timespantools.timespan_2_intersects_timespan_1(
    timespan_1=timespantools.Timespan(0, 10),
    )
time_relation_2(timespan_2=timespantools.Timespan(5, 15))
time_relation_2(timespan_2=timespantools.Timespan(30, 45))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> time_relation_2 = timespantools.timespan_2_intersects_timespan_1(
...     timespan_1=timespantools.Timespan(0, 10),
...     )
>>> time_relation_2(timespan_2=timespantools.Timespan(5, 15))
True
\end{minted}
\begin{minted}{pycon}
>>> time_relation_2(timespan_2=timespantools.Timespan(30, 45))
False
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Providing two timespans -- or one timespan and an offset, as required
-- to one of the various time relation factory functions found in
\texttt{timespantools} will configure and then immediately evaluate the
generated time relation object, allowing the factory function itself to behave
as a predicate:

\begin{comment}
<abjad>
timespantools.timespan_2_intersects_timespan_1(
    timespan_1=timespantools.Timespan(1, 3),
    timespan_2=timespantools.Timespan(2, 4),
    )
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> timespantools.timespan_2_intersects_timespan_1(
...     timespan_1=timespantools.Timespan(1, 3),
...     timespan_2=timespantools.Timespan(2, 4),
...     )
True
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent The time relation factory functions in \texttt{timespantools} are
mirrored as methods on the \texttt{Timespan} class itself, allowing composers
to determine the various relations of any timespan relative any other timespan
or offset in an object-oriented fashion. The \texttt{Timespan} object
automatically \enquote{fills in} the \texttt{timespan\_1} argument to the
\texttt{TimeRelation} with a reference to itself, and can pass the optional
argument to its method call as the other object in the relation, allowing for
the immediate evaluation of the relation as either true or false.

Consider the following three timespans:

\begin{comment}
<abjad>
timespan_1 = timespantools.Timespan(0, 10)
timespan_2 = timespantools.Timespan(5, 15)
timespan_3 = timespantools.Timespan(10, 20)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> timespan_1 = timespantools.Timespan(0, 10)
>>> timespan_2 = timespantools.Timespan(5, 15)
>>> timespan_3 = timespantools.Timespan(10, 20)
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent After being collected into a \emph{timespan inventory}, discussed
further in \autoref{sec:timespan-inventories}, the three timespans can be
illustrated. Note that the beginning and end of each timespan is demarcated by
a short vertical line, and that only non-intersecting timespans are shown in
each \enquote{row} in the illustration:

\begin{comment}
<abjad>[hide=true]
timespan_inventory = timespantools.TimespanInventory([
    timespan_1,
    timespan_2,
    timespan_3,
    ])
show(timespan_inventory)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-724da9131ae14b66a78d55f2434cb71d.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent We can test for intersection between these three timespans via the
\texttt{intersects\_timespan()} method. Two timespans are considered to
intersect if any part of one timespan overlaps any part of another.
\emph{Intersection} is therefore commutative. Note that \texttt{timespan\_1}
and \texttt{timespan\_3} do not overlap even though they share the offset 10.
As discussed earlier, timespans are left-closed / right-open, meaning that
while their start offset is contained in the infinite set of offsets they range
over, their stop offset is not:

\begin{comment}
<abjad>
timespan_1.intersects_timespan(timespan_2)
timespan_1.intersects_timespan(timespan_3)
timespan_2.intersects_timespan(timespan_1)
timespan_2.intersects_timespan(timespan_3)
timespan_3.intersects_timespan(timespan_1)
timespan_3.intersects_timespan(timespan_2)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> timespan_1.intersects_timespan(timespan_2)
True
\end{minted}
\begin{minted}{pycon}
>>> timespan_1.intersects_timespan(timespan_3)
False
\end{minted}
\begin{minted}{pycon}
>>> timespan_2.intersects_timespan(timespan_1)
True
\end{minted}
\begin{minted}{pycon}
>>> timespan_2.intersects_timespan(timespan_3)
True
\end{minted}
\begin{minted}{pycon}
>>> timespan_3.intersects_timespan(timespan_1)
False
\end{minted}
\begin{minted}{pycon}
>>> timespan_3.intersects_timespan(timespan_2)
True
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent \emph{Congruency} tests whether two timespans share the same start
and stop offset. Every timespan is congruent with itself:

\begin{comment}
<abjad>
timespan_1.is_congruent_to_timespan(timespan_2)
timespan_1.is_congruent_to_timespan(timespan_1)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> timespan_1.is_congruent_to_timespan(timespan_2)
False
\end{minted}
\begin{minted}{pycon}
>>> timespan_1.is_congruent_to_timespan(timespan_1)
True
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent \emph{Tangency} tests whether one timespan's stop offset is the same
as another timespan's start offset, or vice versa. Tangency can be used to
determine if a sorted collection of timespans is both entirely contiguous and
non-overlapping:

\begin{comment}
<abjad>
timespan_1.is_tangent_to_timespan(timespan_2)
timespan_1.is_tangent_to_timespan(timespan_3)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> timespan_1.is_tangent_to_timespan(timespan_2)
False
\end{minted}
\begin{minted}{pycon}
>>> timespan_1.is_tangent_to_timespan(timespan_3)
True
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent A wide variety of other time relation predicates are also possible,
such as testing if a timespan intersects with a specific offset, testing if a
timespan overlaps only the beginning or end of another timespan, or testing if
a timespan contains another timespan entirely. These predicates make possible
the many generative operations carried out on timespans.

\subsection{Operations on timespans} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{ssec:operations-on-timespans}

Many \texttt{Timespan} methods provide transformations, such as translation,
scaling or offset rounding. Because timespans are immutable, these methods
create a new timespan based on the old one and then return the new, leaving
the old exactly as it was:

\begin{comment}
<abjad>
timespan = timespantools.Timespan(0, 15)
timespan.translate(3)
timespan.scale(3)
timespan.round_offsets(2)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> timespan = timespantools.Timespan(0, 15)
>>> timespan.translate(3)
Timespan(start_offset=Offset(3, 1), stop_offset=Offset(18, 1))
\end{minted}
\begin{minted}{pycon}
>>> timespan.scale(3)
Timespan(start_offset=Offset(0, 1), stop_offset=Offset(45, 1))
\end{minted}
\begin{minted}{pycon}
>>> timespan.round_offsets(2)
Timespan(start_offset=Offset(0, 1), stop_offset=Offset(16, 1))
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent These generative methods are implemented internally in terms of
templating via \texttt{new()}, as described in \autoref{sec:timespans},
allowing annotated timespan subclasses to partake in the same generative
functionality -- reconfiguring their start and / or stop offsets, but
maintaining all other previously configured properties:

\begin{comment}
<abjad>
annotated_timespan = timespantools.AnnotatedTimespan(0, 5, 'an annotation')
scaled_annotated_timespan = annotated_timespan.translate((-1, 3))
print(format(scaled_annotated_timespan))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> annotated_timespan = timespantools.AnnotatedTimespan(0, 5, 'an annotation')
>>> scaled_annotated_timespan = annotated_timespan.translate((-1, 3))
>>> print(format(scaled_annotated_timespan))
timespantools.AnnotatedTimespan(
    start_offset=durationtools.Offset(-1, 3),
    stop_offset=durationtools.Offset(14, 3),
    annotation='an annotation',
    )
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Some generative operations may return zero or more timespans,
aggregated in a data structure called a \emph{timespan inventory}, discussed at
length in \autoref{sec:timespan-inventories}. Splitting a timespan by an offset
is one such operation. If the timespan to be split \emph{properly
contains}\footnote{\emph{Proper containment} of an offset means that the offset
is greater than the timespan's start offset and less than the timespan's stop
offset. \emph{Improper containment} would indicated the offset is greater than
or equal to the timespan's start offset and less than or equal to its stop
offset.} the splitting offset, a timespan inventory containing two new
timespans will be returned. Otherwise, the split operation will return a
timespan inventory containing a copy of the original input timespan:

\begin{comment}
<abjad>
two_shards = timespan.split_at_offset(5)
print(format(two_shards))
one_shard = timespan.split_at_offset(10000)
print(format(one_shard))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> two_shards = timespan.split_at_offset(5)
>>> print(format(two_shards))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(0, 1),
            stop_offset=durationtools.Offset(5, 1),
            ),
        timespantools.Timespan(
            start_offset=durationtools.Offset(5, 1),
            stop_offset=durationtools.Offset(15, 1),
            ),
        ]
    )
\end{minted}
\begin{minted}{pycon}
>>> one_shard = timespan.split_at_offset(10000)
>>> print(format(one_shard))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(0, 1),
            stop_offset=durationtools.Offset(15, 1),
            ),
        ]
    )
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent More complex operations between timespans resulting in timespan
inventories include subtraction and the logical operations
\texttt{AND}, \texttt{OR} and \texttt{XOR}. These generative operations are
conceptually \emph{set} operations -- union, difference, intersection,
symmetric difference, etc. -- performed on the two sets of offsets contained by
the two timespan operands. Consider these same set operations -- union,
difference, intersection, symmetric difference -- carried out on trivial sets
in Python:

\begin{comment}
<abjad>
set([1, 2, 3]) | set([2, 3, 4])  # union
set([1, 2, 3]) - set([2, 3, 4])  # difference
set([1, 2, 3]) & set([2, 3, 4])  # intersection
set([1, 2, 3]) ^ set([2, 3, 4])  # symmetric difference
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> set([1, 2, 3]) | set([2, 3, 4])  # union
set([1, 2, 3, 4])
\end{minted}
\begin{minted}{pycon}
>>> set([1, 2, 3]) - set([2, 3, 4])  # difference
set([1])
\end{minted}
\begin{minted}{pycon}
>>> set([1, 2, 3]) & set([2, 3, 4])  # intersection
set([2, 3])
\end{minted}
\begin{minted}{pycon}
>>> set([1, 2, 3]) ^ set([2, 3, 4])  # symmetric difference
set([1, 4])
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Set operations performed on timespans are conceptually identical, but
operate on infinite but bounded sets of offsets instead of discrete sets of
objects such as integers. For example, subtracting one timespan from another
computes the set difference of the offsets contained by both. This operation is
not commutative -- subtracting one timespan from another will not result in the
same output as subtracting the latter from the former. Subtracting a timespan
from itself always results in the empty set of offsets: no timespan at all:

\begin{comment}
<abjad>
result = timespantools.Timespan(0, 10) - timespantools.Timespan(0, 10)
print(format(result))
result = timespantools.Timespan(0, 10) - timespantools.Timespan(5, 15)
print(format(result))
result = timespantools.Timespan(0, 10) - timespantools.Timespan(10, 20)
print(format(result))
result = timespantools.Timespan(5, 15) - timespantools.Timespan(0, 10)
print(format(result))
result = timespantools.Timespan(5, 15) - timespantools.Timespan(5, 15)
print(format(result))
result = timespantools.Timespan(5, 15) - timespantools.Timespan(10, 20)
print(format(result))
result = timespantools.Timespan(10, 20) - timespantools.Timespan(0, 10)
print(format(result))
result = timespantools.Timespan(10, 20) - timespantools.Timespan(5, 15)
print(format(result))
result = timespantools.Timespan(10, 20) - timespantools.Timespan(10, 20)
print(format(result))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> result = timespantools.Timespan(0, 10) - timespantools.Timespan(0, 10)
>>> print(format(result))
timespantools.TimespanInventory(
    []
    )
\end{minted}
\begin{minted}{pycon}
>>> result = timespantools.Timespan(0, 10) - timespantools.Timespan(5, 15)
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(0, 1),
            stop_offset=durationtools.Offset(5, 1),
            ),
        ]
    )
\end{minted}
\begin{minted}{pycon}
>>> result = timespantools.Timespan(0, 10) - timespantools.Timespan(10, 20)
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(0, 1),
            stop_offset=durationtools.Offset(10, 1),
            ),
        ]
    )
\end{minted}
\begin{minted}{pycon}
>>> result = timespantools.Timespan(5, 15) - timespantools.Timespan(0, 10)
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(10, 1),
            stop_offset=durationtools.Offset(15, 1),
            ),
        ]
    )
\end{minted}
\begin{minted}{pycon}
>>> result = timespantools.Timespan(5, 15) - timespantools.Timespan(5, 15)
>>> print(format(result))
timespantools.TimespanInventory(
    []
    )
\end{minted}
\begin{minted}{pycon}
>>> result = timespantools.Timespan(5, 15) - timespantools.Timespan(10, 20)
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(5, 1),
            stop_offset=durationtools.Offset(10, 1),
            ),
        ]
    )
\end{minted}
\begin{minted}{pycon}
>>> result = timespantools.Timespan(10, 20) - timespantools.Timespan(0, 10)
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(10, 1),
            stop_offset=durationtools.Offset(20, 1),
            ),
        ]
    )
\end{minted}
\begin{minted}{pycon}
>>> result = timespantools.Timespan(10, 20) - timespantools.Timespan(5, 15)
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(15, 1),
            stop_offset=durationtools.Offset(20, 1),
            ),
        ]
    )
\end{minted}
\begin{minted}{pycon}
>>> result = timespantools.Timespan(10, 20) - timespantools.Timespan(10, 20)
>>> print(format(result))
timespantools.TimespanInventory(
    []
    )
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Computing the logical \texttt{OR} of two timespans results in an
offset set union -- a commutative operation, effectively fusing the timespans
together if they overlap:

\begin{comment}
<abjad>
result = timespantools.Timespan(0, 10) | timespantools.Timespan(5, 15)
print(format(result))
result = timespantools.Timespan(0, 10) | timespantools.Timespan(10, 20)
print(format(result))
result = timespantools.Timespan(5, 15) | timespantools.Timespan(10, 20)
print(format(result))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> result = timespantools.Timespan(0, 10) | timespantools.Timespan(5, 15)
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(0, 1),
            stop_offset=durationtools.Offset(15, 1),
            ),
        ]
    )
\end{minted}
\begin{minted}{pycon}
>>> result = timespantools.Timespan(0, 10) | timespantools.Timespan(10, 20)
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(0, 1),
            stop_offset=durationtools.Offset(20, 1),
            ),
        ]
    )
\end{minted}
\begin{minted}{pycon}
>>> result = timespantools.Timespan(5, 15) | timespantools.Timespan(10, 20)
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(5, 1),
            stop_offset=durationtools.Offset(20, 1),
            ),
        ]
    )
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Unioning guarantees that all of the offsets contained in the two
input timespans will appear in the output timespan or timespans, whether or not
any overlap occurred:

\begin{comment}
<abjad>
result = timespantools.Timespan(10, 20) | timespantools.Timespan(25, 50)
print(format(result))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> result = timespantools.Timespan(10, 20) | timespantools.Timespan(25, 50)
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(10, 1),
            stop_offset=durationtools.Offset(20, 1),
            ),
        timespantools.Timespan(
            start_offset=durationtools.Offset(25, 1),
            stop_offset=durationtools.Offset(50, 1),
            ),
        ]
    )
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent The logical \texttt{AND} -- set intersection -- results in the
intersection of the two input timespans. Only those offsets which occur in both
timespan operands will occur in the output timespan, if any:

\begin{comment}
<abjad>
result = timespantools.Timespan(0, 10) & timespantools.Timespan(5, 15)
print(format(result))
result = timespantools.Timespan(0, 10) & timespantools.Timespan(10, 20)
print(format(result))
result = timespantools.Timespan(5, 15) & timespantools.Timespan(10, 20)
print(format(result))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> result = timespantools.Timespan(0, 10) & timespantools.Timespan(5, 15)
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(5, 1),
            stop_offset=durationtools.Offset(10, 1),
            ),
        ]
    )
\end{minted}
\begin{minted}{pycon}
>>> result = timespantools.Timespan(0, 10) & timespantools.Timespan(10, 20)
>>> print(format(result))
timespantools.TimespanInventory(
    []
    )
\end{minted}
\begin{minted}{pycon}
>>> result = timespantools.Timespan(5, 15) & timespantools.Timespan(10, 20)
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(10, 1),
            stop_offset=durationtools.Offset(15, 1),
            ),
        ]
    )
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Logical \texttt{XOR} -- also known as exclusive \texttt{OR} --
results in the symmetric difference of the two input timespans. Only those
offsets which are contained by only one of the two input timespans will occur
in the output:

\begin{comment}
<abjad>
result = timespantools.Timespan(0, 10) ^ timespantools.Timespan(5, 15)
print(format(result))
result = timespantools.Timespan(0, 10) ^ timespantools.Timespan(10, 20)
print(format(result))
result = timespantools.Timespan(5, 15) ^ timespantools.Timespan(10, 20)
print(format(result))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> result = timespantools.Timespan(0, 10) ^ timespantools.Timespan(5, 15)
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(0, 1),
            stop_offset=durationtools.Offset(5, 1),
            ),
        timespantools.Timespan(
            start_offset=durationtools.Offset(10, 1),
            stop_offset=durationtools.Offset(15, 1),
            ),
        ]
    )
\end{minted}
\begin{minted}{pycon}
>>> result = timespantools.Timespan(0, 10) ^ timespantools.Timespan(10, 20)
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(0, 1),
            stop_offset=durationtools.Offset(10, 1),
            ),
        timespantools.Timespan(
            start_offset=durationtools.Offset(10, 1),
            stop_offset=durationtools.Offset(20, 1),
            ),
        ]
    )
\end{minted}
\begin{minted}{pycon}
>>> result = timespantools.Timespan(5, 15) ^ timespantools.Timespan(10, 20)
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(5, 1),
            stop_offset=durationtools.Offset(10, 1),
            ),
        timespantools.Timespan(
            start_offset=durationtools.Offset(15, 1),
            stop_offset=durationtools.Offset(20, 1),
            ),
        ]
    )
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent These operations, while perhaps initially rather abstract, are
incredibly powerful and artistically useful. They afford composers with the
procedural building blocks to mask temporal objects with one another, fuse them
together, or create lacunae. When extended to operate on many timespans at
once, wholesale transformations on massed timespans becomes practical.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Timespan inventories}
\label{sec:timespan-inventories}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Abjad provides a \texttt{TimespanInventory} class specifically for aggregating
together a collection of \texttt{Timespan} objects.\footnote{ Consort provides
its own timespan collection class -- the \texttt{TimespanCollection}. This
class stores timespans internally not in a list, but in a balanced
\emph{interval tree}.\cite{cormen2009introduction} An interval tree is an
augmented, self-balancing binary tree which stores start offsets and stop
offsets. Such a data structure guarantees its contents are always sorted, and
allows for highly optimized lookups for timespan matching various search
criteria. The \texttt{TimespanCollection} class is used at crucial points
during Consort's interpretation stage simply for purposes of speed, and should
be considered an implementation detail. It provides only a few methods,
specifically for affording rapid search and retrieval of timespans intersecting
other timespans or offsets. With work, its internal data structure may
eventually be merged into Abjad's own \texttt{TimespanInventory} class.}
Timespan inventories implement Python's \emph{mutable sequence protocol} which
allow them to behave exactly like lists, supporting appension, extension,
insertion, indexing, sorting, iteration and other procedures pertinent to
list-like objects. They also provide a wide variety of properties and methods
for interacting with massed groups of timespans such as searching for timespans
matching a time relation, splitting all timespans which intersect with a given
offset, mapping a logical operation against all timespans in the inventory, or
partitioning an inventory containing overlapping timespans into multiple
separate inventories containing non-overlapping timespans.

Like a Python list, a timespan inventory can be created with an iterable of
zero or more timespans as an instantiation argument, be appended to, or
extended into:

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(0, 16),
    ])
timespan_inventory.append(timespantools.Timespan(5, 12))
timespan_inventory.extend([
    timespantools.Timespan(-2, 8),
    timespantools.Timespan(15, 20),
    ])
print(format(timespan_inventory))
show(timespan_inventory)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> timespan_inventory = timespantools.TimespanInventory([
...     timespantools.Timespan(0, 16),
...     ])
>>> timespan_inventory.append(timespantools.Timespan(5, 12))
>>> timespan_inventory.extend([
...     timespantools.Timespan(-2, 8),
...     timespantools.Timespan(15, 20),
...     ])
>>> print(format(timespan_inventory))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(0, 1),
            stop_offset=durationtools.Offset(16, 1),
            ),
        timespantools.Timespan(
            start_offset=durationtools.Offset(5, 1),
            stop_offset=durationtools.Offset(12, 1),
            ),
        timespantools.Timespan(
            start_offset=durationtools.Offset(-2, 1),
            stop_offset=durationtools.Offset(8, 1),
            ),
        timespantools.Timespan(
            start_offset=durationtools.Offset(15, 1),
            stop_offset=durationtools.Offset(20, 1),
            ),
        ]
    )
\end{minted}
\begin{minted}{pycon}
>>> show(timespan_inventory)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-e7a68b07301b5dde7c04a3097b11b500.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Timespan inventories can also be queried for their length, be indexed
into, or iterated over like any other sequence-like object in Python:

\begin{comment}
<abjad>
len(timespan_inventory)
timespan_inventory[1]
for timespan in timespan_inventory:
    timespan

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> len(timespan_inventory)
4
\end{minted}
\begin{minted}{pycon}
>>> timespan_inventory[1]
Timespan(start_offset=Offset(5, 1), stop_offset=Offset(12, 1))
\end{minted}
\begin{minted}{pycon}
>>> for timespan in timespan_inventory:
...     timespan
...
Timespan(start_offset=Offset(0, 1), stop_offset=Offset(16, 1))
Timespan(start_offset=Offset(5, 1), stop_offset=Offset(12, 1))
Timespan(start_offset=Offset(-2, 1), stop_offset=Offset(8, 1))
Timespan(start_offset=Offset(15, 1), stop_offset=Offset(20, 1))
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent One timespan inventory can be created from another by passing the
first timespan inventory as an instantiation argument to the second, just like
one can create a Python list simply by calling \texttt{list()} on another
iterable object, including another list. Unlike timespans, timespan inventories
are mutable. As many of the operations implemented on timespan inventories
mutate the inventory \emph{in-place}, this instantiation pattern provides a
simple means of \enquote{copying}, allowing composers to duplicate a timespan
structure before operating on it, thereby preserving the original:

\begin{comment}
<abjad>
duplicate = timespantools.TimespanInventory(timespan_inventory)
duplicate == timespan_inventory
duplicate is timespan_inventory
print(format(duplicate))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> duplicate = timespantools.TimespanInventory(timespan_inventory)
>>> duplicate == timespan_inventory
True
\end{minted}
\begin{minted}{pycon}
>>> duplicate is timespan_inventory
False
\end{minted}
\begin{minted}{pycon}
>>> print(format(duplicate))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(0, 1),
            stop_offset=durationtools.Offset(16, 1),
            ),
        timespantools.Timespan(
            start_offset=durationtools.Offset(5, 1),
            stop_offset=durationtools.Offset(12, 1),
            ),
        timespantools.Timespan(
            start_offset=durationtools.Offset(-2, 1),
            stop_offset=durationtools.Offset(8, 1),
            ),
        timespantools.Timespan(
            start_offset=durationtools.Offset(15, 1),
            stop_offset=durationtools.Offset(20, 1),
            ),
        ]
    )
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Timespan inventories can be treated as timespans themselves, having a
start offset equal to the minimum start offset of any of their contained
timespans, and a stop offset equal to the maximum stop offset of any of their
contained timespans. Their start and stop offset properties allow them to
express a duration, as well as provide a concrete timespan representation.
Because timespan inventories can be modeled as timespans, they can even be
inserted into other timespan inventories, effectively masquerading as
timespans:

\begin{comment}
<abjad>
timespan_inventory.start_offset
timespan_inventory.stop_offset
timespan_inventory.duration
timespan_inventory.timespan
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> timespan_inventory.start_offset
Offset(-2, 1)
\end{minted}
\begin{minted}{pycon}
>>> timespan_inventory.stop_offset
Offset(20, 1)
\end{minted}
\begin{minted}{pycon}
>>> timespan_inventory.duration
Duration(22, 1)
\end{minted}
\begin{minted}{pycon}
>>> timespan_inventory.timespan
Timespan(start_offset=Offset(-2, 1), stop_offset=Offset(20, 1))
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Because timespan inventories aggregate multiple timespans together,
they also provide properties for describing collective qualities of those
timespans. \emph{Contiguity} tests if every timespan in the inventory is
tangent to another timespan and also does not overlap any other timespan.
\emph{Overlap} tests if any timespan intersects any other timespan.
\emph{Well-formedness} tests that all timespans' durations are greater than 0.
A timespan inventory whose timespans are contiguous is necessarily also
non-overlapping:

\begin{comment}
<abjad>
timespan_inventory.all_are_contiguous
timespan_inventory.all_are_nonoverlapping
timespan_inventory.all_are_well_formed
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> timespan_inventory.all_are_contiguous
False
\end{minted}
\begin{minted}{pycon}
>>> timespan_inventory.all_are_nonoverlapping
False
\end{minted}
\begin{minted}{pycon}
>>> timespan_inventory.all_are_well_formed
True
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent The following timespan inventory's timespans are non-overlapping but
also non-contiguous:

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(0, 10),
    timespantools.Timespan(10, 20),
    timespantools.Timespan(30, 40),
    ])
show(timespan_inventory)
timespan_inventory.all_are_contiguous
timespan_inventory.all_are_nonoverlapping
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> timespan_inventory = timespantools.TimespanInventory([
...     timespantools.Timespan(0, 10),
...     timespantools.Timespan(10, 20),
...     timespantools.Timespan(30, 40),
...     ])
>>> show(timespan_inventory)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-d9997d65e5d0afdad301e936638868bb.pdf}
\begin{minted}{pycon}
>>> timespan_inventory.all_are_contiguous
False
\end{minted}
\begin{minted}{pycon}
>>> timespan_inventory.all_are_nonoverlapping
True
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent In contrast, this timespan inventory's timespans are both
non-overlapping and contiguous:

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(0, 10),
    timespantools.Timespan(10, 20),
    timespantools.Timespan(20, 30),
    ])
show(timespan_inventory)
timespan_inventory.all_are_contiguous
timespan_inventory.all_are_nonoverlapping
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> timespan_inventory = timespantools.TimespanInventory([
...     timespantools.Timespan(0, 10),
...     timespantools.Timespan(10, 20),
...     timespantools.Timespan(20, 30),
...     ])
>>> show(timespan_inventory)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-7f455919c0b05a5992d29848880d082d.pdf}
\begin{minted}{pycon}
>>> timespan_inventory.all_are_contiguous
True
\end{minted}
\begin{minted}{pycon}
>>> timespan_inventory.all_are_nonoverlapping
True
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\subsection{Operations on timespan inventories}
\label{ssec:operations-on-timespan-inventories}

Timespan inventories implement unioning, differencing and splitting methods
which parallel those implemented on timespans themselves. These methods map the
desired operation onto the contents of the inventory by, for example, splitting
every timespan contained in a given inventory by some offset. All of these
operations act in place. The intersection of all of the timespans in a timespan
inventory relative another timespan can be computed with the Python \texttt{\&}
operator, the same syntax used when operating on individual timespans, as
demonstrated in \autoref{ssec:operations-on-timespans}:\footnote{ The call to
\texttt{show()} in the code example here contains the keyword argument
\texttt{range\_}. This argument controls the horizontal scaling and spacing of
the timespan illustration, allowing different illustrations to be aligned
against one another in a document even if the timespan inventories they
illustrate have different start and stop offsets. The name \texttt{range\_} --
with a trailing underscore -- is used instead of \texttt{range}, a
commonly-used built-in Python function. It is common practice in the Python
community to append underscores to names when they would otherwise conflict
with reserved words in Python's grammar or global built-in namespace. For
example, one would use the names \texttt{break\_}, \texttt{object\_},
\texttt{set\_} and \texttt{type\_} instead of the reserved word \texttt{break},
or the built-in names \texttt{object}, \texttt{set} and \texttt{type}.}

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(0, 16),
    timespantools.Timespan(5, 12),
    timespantools.Timespan(-2, 8),
    ])
show(timespan_inventory)
timespan_operand = timespantools.Timespan(6, 10)
result = timespan_inventory & timespan_operand
show(result, range_=(-2, 16))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> timespan_inventory = timespantools.TimespanInventory([
...     timespantools.Timespan(0, 16),
...     timespantools.Timespan(5, 12),
...     timespantools.Timespan(-2, 8),
...     ])
>>> show(timespan_inventory)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-bcf796c336338d7e1ec4cae1ae8f81d0.pdf}
\begin{minted}{pycon}
>>> timespan_operand = timespantools.Timespan(6, 10)
>>> result = timespan_inventory & timespan_operand
>>> show(result, range_=(-2, 16))
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-ce48ef61ef19d2eebb23f7e0225b51ab.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Likewise, the offsets bound by a given timespan can be subtracted
from all of the timespans in a timespan inventory, effectively cutting a hole
in that inventory's timeline:

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(0, 16),
    timespantools.Timespan(5, 12),
    timespantools.Timespan(-2, 8),
    ])
show(timespan_inventory)
timespan_operand = timespantools.Timespan(6, 10)
result = timespan_inventory - timespan_operand
show(result)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> timespan_inventory = timespantools.TimespanInventory([
...     timespantools.Timespan(0, 16),
...     timespantools.Timespan(5, 12),
...     timespantools.Timespan(-2, 8),
...     ])
>>> show(timespan_inventory)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-bcf796c336338d7e1ec4cae1ae8f81d0.pdf}
\begin{minted}{pycon}
>>> timespan_operand = timespantools.Timespan(6, 10)
>>> result = timespan_inventory - timespan_operand
>>> show(result)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-e0be179ab07637a0c401b146e449b7fb.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent As with a single timespan and an offset, an entire timespan inventory
can be split into two separate inventories via the \texttt{split\_at\_offset()}
method:

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(0, 3),
    timespantools.Timespan(3, 6),
    timespantools.Timespan(6, 10),
    ])
show(timespan_inventory)
left, right = timespan_inventory.split_at_offset(4)
show(left, range_=(0, 10))
show(right, range_=(0, 10))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> timespan_inventory = timespantools.TimespanInventory([
...     timespantools.Timespan(0, 3),
...     timespantools.Timespan(3, 6),
...     timespantools.Timespan(6, 10),
...     ])
>>> show(timespan_inventory)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-c6ac00c33bae7c092839e0d9eed14364.pdf}
\begin{minted}{pycon}
>>> left, right = timespan_inventory.split_at_offset(4)
>>> show(left, range_=(0, 10))
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-4bbf9f0b62b3d6b64b454b9357f558b1.pdf}
\begin{minted}{pycon}
>>> show(right, range_=(0, 10))
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-c0711ccb491c38828100bbc6c0c7bb4a.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent The \texttt{TimespanInventory} class also provides the convenience
method \texttt{split\_at\_offsets()} for splitting an inventory by an arbitrary
number of offsets at once:

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(0, 3),
    timespantools.Timespan(3, 6),
    timespantools.Timespan(6, 10),
    ])
show(timespan_inventory)
shards = timespan_inventory.split_at_offsets((2, 4, 7))
for shard in shards:
    show(shard, range_=(0, 10))

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> timespan_inventory = timespantools.TimespanInventory([
...     timespantools.Timespan(0, 3),
...     timespantools.Timespan(3, 6),
...     timespantools.Timespan(6, 10),
...     ])
>>> show(timespan_inventory)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-c6ac00c33bae7c092839e0d9eed14364.pdf}
\begin{minted}{pycon}
>>> shards = timespan_inventory.split_at_offsets((2, 4, 7))
>>> for shard in shards:
...     show(shard, range_=(0, 10))
...
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-3f55390af95e17294a09c5bd6d4c3e05.pdf}\\
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-2c8e8b094dc7ab417cebd715d4c03cc6.pdf}\\
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-c9baa4d4c9d713a089e3d17740e84e91.pdf}\\
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-7b1f526a22be1869691cd9382e3e88ce.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent The mutating methods described above modify a timespan inventory
by mapping some procedure against its contents and some outside timespan or
offset. However, timespan inventories may also be modified by applying a
procedure solely against the contents of the inventory itself, mapping each
timespan in the collection against each other timespan in that collection.
For example, a timespan inventory can be modified by computing the logical
\texttt{OR} -- the set union -- of every timespan in the inventory relative
every other timespan, effectively fusing all overlapping timespans together:

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(-2, 2),
    timespantools.Timespan(0, 10),
    timespantools.Timespan(5, 12),
    ])
show(timespan_inventory)
result = timespan_inventory.compute_logical_or()
print(format(result))
show(result)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> timespan_inventory = timespantools.TimespanInventory([
...     timespantools.Timespan(-2, 2),
...     timespantools.Timespan(0, 10),
...     timespantools.Timespan(5, 12),
...     ])
>>> show(timespan_inventory)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-f47513d85ce7bf4288cae06c0b09b27b.pdf}
\begin{minted}{pycon}
>>> result = timespan_inventory.compute_logical_or()
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(-2, 1),
            stop_offset=durationtools.Offset(12, 1),
            ),
        ]
    )
\end{minted}
\begin{minted}{pycon}
>>> show(result)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-aeff7e8a66f50bd1174d694e5d2e765d.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent A timespan inventory can also be modified by computing the logical
\texttt{AND} of every timespan in the inventory relative every other timespan.
This procedure leaves only those offsets where every single timespan
overlaps:

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(-2, 8),
    timespantools.Timespan(0, 10),
    timespantools.Timespan(5, 12),
    ])
show(timespan_inventory)
result = timespan_inventory.compute_logical_and()
print(format(result))
show(result, range_=(-2, 12))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> timespan_inventory = timespantools.TimespanInventory([
...     timespantools.Timespan(-2, 8),
...     timespantools.Timespan(0, 10),
...     timespantools.Timespan(5, 12),
...     ])
>>> show(timespan_inventory)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-1ebe2aa9d873ea15eb614d26e44806f4.pdf}
\begin{minted}{pycon}
>>> result = timespan_inventory.compute_logical_and()
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(5, 1),
            stop_offset=durationtools.Offset(8, 1),
            ),
        ]
    )
\end{minted}
\begin{minted}{pycon}
>>> show(result, range_=(-2, 12))
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-fc22fe0268233e8b05264e17f65d30ae.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Lastly, computing the in-place logical \texttt{XOR} removes all
overlap from the timespan inventory, leaving only those offsets occupied by
only one timespan:

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(-2, 2),
    timespantools.Timespan(0, 10),
    timespantools.Timespan(5, 12),
    ])
show(timespan_inventory)
result = timespan_inventory.compute_logical_xor()
print(format(result))
show(result, range_=(-2, 12))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> timespan_inventory = timespantools.TimespanInventory([
...     timespantools.Timespan(-2, 2),
...     timespantools.Timespan(0, 10),
...     timespantools.Timespan(5, 12),
...     ])
>>> show(timespan_inventory)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-f47513d85ce7bf4288cae06c0b09b27b.pdf}
\begin{minted}{pycon}
>>> result = timespan_inventory.compute_logical_xor()
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(-2, 1),
            stop_offset=durationtools.Offset(0, 1),
            ),
        timespantools.Timespan(
            start_offset=durationtools.Offset(2, 1),
            stop_offset=durationtools.Offset(5, 1),
            ),
        timespantools.Timespan(
            start_offset=durationtools.Offset(10, 1),
            stop_offset=durationtools.Offset(12, 1),
            ),
        ]
    )
\end{minted}
\begin{minted}{pycon}
>>> show(result, range_=(-2, 12))
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-ca294e3ef0d4de3ddfb5aefb754d65cc.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Timespan \emph{partitioning} separates a timespan inventory into
groups of overlapping and optionally tangent timespans, aggregated into new
timespan inventories. This procedure allows composers to isolate contiguous
blocks of activity:

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(0, 10),
    timespantools.Timespan(5, 15),
    timespantools.Timespan(15, 20),
    timespantools.Timespan(25, 30),
    ])
show(timespan_inventory)
for shard in timespan_inventory.partition():
    show(shard, range_=(0, 30))

for shard in timespan_inventory.partition(include_tangent_timespans=True):
    show(shard, range_=(0, 30))

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> timespan_inventory = timespantools.TimespanInventory([
...     timespantools.Timespan(0, 10),
...     timespantools.Timespan(5, 15),
...     timespantools.Timespan(15, 20),
...     timespantools.Timespan(25, 30),
...     ])
>>> show(timespan_inventory)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-61fb7454778b585d9f76905bca1160f4.pdf}
\begin{minted}{pycon}
>>> for shard in timespan_inventory.partition():
...     show(shard, range_=(0, 30))
...
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-7e33ff9b4eeaf127851126920ba458b2.pdf}\\
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-45c0b016f184f5dc84905bb8c9399d48.pdf}\\
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-02ef5b67d81d13adcb22081715689189.pdf}
\begin{minted}{pycon}
>>> for shard in timespan_inventory.partition(include_tangent_timespans=True):
...     show(shard, range_=(0, 30))
...
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-e5361d3928bd62f3358ece98ca4f51cb.pdf}\\
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-02ef5b67d81d13adcb22081715689189.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Conversely, \emph{explosion} separates a timespan inventory into one
or more new inventories in an attempt to limit the amount of overlap in each
resulting inventory. The number of output inventories can be left unspecified,
in which case explosion will generate as many inventories as necessary to
prevent overlap entirely in every resulting inventory:\footnote{ Explosion is
one of the techniques used to create timespan inventory illustrations,
providing the mechanism by which arbitrary collections of timespans are
automatically separated into non-overlapping inventories, which can then be
rendered graphically as \enquote{rows} of line segments.}

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(-2, 8),
    timespantools.Timespan(-2, 1),
    timespantools.Timespan(0, 16),
    timespantools.Timespan(4, 7),
    timespantools.Timespan(4, 11),
    timespantools.Timespan(5, 12),
    timespantools.Timespan(11, 13),
    timespantools.Timespan(14, 17),
    timespantools.Timespan(15, 20),
    ])
show(timespan_inventory)
for shard in timespan_inventory.explode():
    show(shard, range_=(-2, 20))

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> timespan_inventory = timespantools.TimespanInventory([
...     timespantools.Timespan(-2, 8),
...     timespantools.Timespan(-2, 1),
...     timespantools.Timespan(0, 16),
...     timespantools.Timespan(4, 7),
...     timespantools.Timespan(4, 11),
...     timespantools.Timespan(5, 12),
...     timespantools.Timespan(11, 13),
...     timespantools.Timespan(14, 17),
...     timespantools.Timespan(15, 20),
...     ])
>>> show(timespan_inventory)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-22bfaffe6b95a47e8102d265ddaf3962.pdf}
\begin{minted}{pycon}
>>> for shard in timespan_inventory.explode():
...     show(shard, range_=(-2, 20))
...
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-09c15ac0b3fd17e54f75ab7325b0a20f.pdf}\\
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-2bd53acb303ec5e77fa89424a679eb00.pdf}\\
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-d01b8f21f709917bcab98157d9c80fd9.pdf}\\
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-aff2fbf34581223d8877557340f0000e.pdf}\\
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-a1e140898828c6b0029b0281b00682a7.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent The number of output inventories can also be set explicitly, in which
case explosion will attempt to limit the amount of overlap as much as possible,
while maintaining a similar level of density across each resulting inventory:

\begin{comment}
<abjad>
for shard in timespan_inventory.explode(inventory_count=2):
    show(shard, range_=(-2, 20))

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> for shard in timespan_inventory.explode(inventory_count=2):
...     show(shard, range_=(-2, 20))
...
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-1a2fa111f187bebddecc9df7c4dbcc10.pdf}\\
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-41e126088fa2923f327876da8490ec0f.pdf}
\end{singlespacing}
\end{abjadbookoutput}

The procedures outlined above provide high-level tools for interacting with
large numbers of timespans at once. All of the techniques described in
\autoref{chap:a-model-of-composition} with regards to Consort's score
interpretation stage -- timespan consolidation, cascading overlap
resolution, multiplexing multiple inventories into one, demultiplexing one
inventory into many, and so forth -- build on and extend these techniques.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Annotated timespans in Consort}
\label{sec:annotated-timespans-in-consort}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

While timespans and timespan inventories provide a very general model for
modeling the disposition of durated events in time, a larger question remains:
how can composers create enough timespans, and in various patterns, to be
musically interesting? Consort approaches this problem by providing a
collection of factory classes -- \emph{timespan-makers} -- which can be
configured and called to create arbitrarily large amounts of timespans.
However, before turning to a detailed discussion of timespan-makers, we must
first discuss the products of the timespan themselves.

Consort provides two separate timespan subclasses which are integral, if
transient, components of its score interpretation stage: the
\texttt{PerformedTimespan} and \texttt{SilentTimespan} classes. These classes
are never created \enquote{by hand} during Consort's specification stage --
this is, explicitly instantiated by a composer while specifying a score segment
--, but are instead generated as transitory objects during interpretation.
Consort uses \texttt{PerformedTimespan} objects to indicate locations in the
score timeline where some active musical material should appear, while
\texttt{SilentTimespan} objects indicate tacet passages.

As will be described in more detail in \autoref{chap:a-model-of-composition},
Consort requires composers to specify musical materials in \emph{layers}, and
to specify specifically in which voice contexts in the score -- vertically --
that material should occur. During the course of interpretation, Consort
organizes generated timespans by voice name and layer into separate timespan
inventories, and then progressively masks out timespans in timespan inventories
with lower layer numbers by those timespans with higher layer numbers. One can
imagine this process as analogous to the use of opaque overlapping layers in
image editing software. Both the \texttt{PerformedTimespan} and
\texttt{SilentTimespan} classes provide configurable properties for layer and
voice name, in addition to the start offset and stop offset properties provided
by their parent \texttt{Timespan} class. These properties allow the processes
that generate them to record \emph{when} they were created, as well as
\emph{where} the should appear in the score, should they survive the masking
process:

\begin{comment}
<abjad>
performed_timespan = consort.PerformedTimespan(
    layer=1,
    start_offset=(1, 2),
    stop_offset=(7, 8),
    voice_name='Clarinet Voice',
    )
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> performed_timespan = consort.PerformedTimespan(
...     layer=1,
...     start_offset=(1, 2),
...     stop_offset=(7, 8),
...     voice_name='Clarinet Voice',
...     )
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Performed timespans possess a number of other configurable properties
used during score interpretation. These include \texttt{minimum\_duration} --
used to force erasure of timespans considered too short, often because they
have been partially masked, \texttt{music\_specifier} -- used to attach
information about how to generate notation from a timespan, \texttt{divisions}
-- a memento of the original duration structure of a contiguous sequence of
performed timespans which have been consolidated into a single performed
timespan after the masking process ends, and \texttt{music} -- used to attach
any generated notation prior to maquetting:

\begin{comment}
<abjad>
performed_timespan = consort.PerformedTimespan(
    layer=1,
    minimum_duration=Duration(1, 8),
    music_specifier=consort.MusicSpecifier(),
    start_offset=Offset(1, 4),
    stop_offset=Offset(2, 1),
    voice_name='Violin 1 LH Voice',
    )
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> performed_timespan = consort.PerformedTimespan(
...     layer=1,
...     minimum_duration=Duration(1, 8),
...     music_specifier=consort.MusicSpecifier(),
...     start_offset=Offset(1, 4),
...     stop_offset=Offset(2, 1),
...     voice_name='Violin 1 LH Voice',
...     )
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Unlike performed timespans, silent timespans have no explicit reality
in score, but can still be created for a particular voice context and layer.
They act to simply erase any timespan in a lower layer through masking. This
allows timespan-making processes to demand not only when a musical event should
happen, but also when musical events should \emph{not}. For example, silent
timespans make it possible to demand silence before music events involving
instrument or mallet changes:

\begin{comment}
<abjad>
silent_timespan = consort.SilentTimespan(
    layer=2,
    start_offset=Offset(0, 1),
    stop_offset=Offset(1, 4),
    voice_name='Oboe Voice',
    )
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> silent_timespan = consort.SilentTimespan(
...     layer=2,
...     start_offset=Offset(0, 1),
...     stop_offset=Offset(1, 4),
...     voice_name='Oboe Voice',
...     )
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent All of the above properties are explained in more depth in
\autoref{chap:a-model-of-composition}, in context of Consort's interpretation
process. For the sake of demonstrating timespan-creation principles pithily,
the \texttt{music\_specifier} property of any performed timespan can be set to
an arbitrary object such as Python's \texttt{None} rather than a
\texttt{MusicSpecifier} instance as actually done in practice.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Timespan-makers}
\label{sec:timespan-makers}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Consort provides a family of factory classes for producing timespans, each
implementing a different strategy for populating timespan inventories, but all
unified via the same callable interface. Timespan-makers take as input a
mapping of voice-names to \emph{music specifiers} -- arbitrary objects
specifying how a given timespan might be rendered as notation --, a
\emph{target} timespan indicating the minimum and maximum permitted start
offsets of any timespan created by the timespan-maker, an optional timespan
inventory to modify in-place, and an optional \emph{layer} identifier
indicating in which pass a particular timespan was created.\footnote{Layer
identifiers allow timespans to be sorted not only by their position in time or
by their associated voice name, but also by at which point -- which
\emph{layer} -- during some compositional process they were created. Layer
ordering allows masking processes to mask \enquote{earlier} timespans with
\enquote{later} ones.} All timespan-makers produce timespan inventories as
output.

Timespan-makers fall into two broad categories: independent and dependent.
Independent timespan-makers create timespans without regard for any
pre-existing timespans, and therefore do not require being called with a
timespan inventory instance. Dependent timespan-makers create their timespans
based on the contents of a pre-existing timespan inventory, basing their output
on various aspects of the structure of their input.

Additionally, all timespan-makers can be configured with \texttt{padding} and
\texttt{timespan\_specifier} keywords. Padding allows the timespan-maker to
force \enquote{silence} -- in the form of \texttt{SilentTimespan} objects --
around the beginnings and ends of contiguous groups of timespans it creates.
Timespan specifiers provide templates for some of the configurable properties
specific to performed timespans, such as \texttt{minimum\_duration} and
\texttt{forbid\_splitting}, allowing the timespan-maker to apply the
configuration defined in the timespan specifier to each of the timespans it
creates.

\subsection{Flooded timespan-makers}
\label{ssec:flooded-timespan-makers}

%\todo[inline]{\textbf{TODO:} Find a citation for flood fill. MacPaint?}

\emph{Flooded} timespan-makers implement the most trivial timespan-creation
strategy in the timespan-maker class family. Their name derives from the
ubiquitous graphic-design \enquote{flood fill} tool, which fills an entire
connected area with the same color or texture. Flooded timespan-makers create
one timespan for each voice in the input voice-name-to-music-specifier mapping,
filling the entirety of the provided target timespan from beginning to end.

For example, the following flooded timespan-maker will create a timespan
inventory populated by a single performed timespan associated with a
\enquote{Violin Voice} context, completely filling the span of its target
timespan, from \sfrac[big]{1}{4} to \sfrac[big]{11}{8}:

\begin{comment}
<abjad>
music_specifiers = {'Violin Voice': 'violin music'}
target_timespan = timespantools.Timespan((1, 4), (11, 8))
flooded_timespan_maker = consort.FloodedTimespanMaker()
timespan_inventory = flooded_timespan_maker(
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
print(format(timespan_inventory))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> music_specifiers = {'Violin Voice': 'violin music'}
>>> target_timespan = timespantools.Timespan((1, 4), (11, 8))
>>> flooded_timespan_maker = consort.FloodedTimespanMaker()
>>> timespan_inventory = flooded_timespan_maker(
...     music_specifiers=music_specifiers,
...     target_timespan=target_timespan,
...     )
>>> print(format(timespan_inventory))
timespantools.TimespanInventory(
    [
        consort.tools.PerformedTimespan(
            start_offset=durationtools.Offset(1, 4),
            stop_offset=durationtools.Offset(11, 8),
            music_specifier='violin music',
            voice_name='Violin Voice',
            ),
        ]
    )
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Adding a second entry to the music specifier mapping results in two
timespans in the output. Likewise, calling the timespan-maker with a
\texttt{layer} keyword configures the output timespans with that layer number.
The layer is indicated in the illustration just above and to the right of the
beginning of each timespan:

\begin{comment}
<abjad>
music_specifiers = {
    'Violin Voice': 'violin music',
    'Cello Voice': 'cello music',
    }
timespan_inventory = flooded_timespan_maker(
    layer=3,
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
print(format(timespan_inventory))
show(timespan_inventory, key='voice_name')
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> music_specifiers = {
...     'Violin Voice': 'violin music',
...     'Cello Voice': 'cello music',
...     }
>>> timespan_inventory = flooded_timespan_maker(
...     layer=3,
...     music_specifiers=music_specifiers,
...     target_timespan=target_timespan,
...     )
>>> print(format(timespan_inventory))
timespantools.TimespanInventory(
    [
        consort.tools.PerformedTimespan(
            start_offset=durationtools.Offset(1, 4),
            stop_offset=durationtools.Offset(11, 8),
            layer=3,
            music_specifier='cello music',
            voice_name='Cello Voice',
            ),
        consort.tools.PerformedTimespan(
            start_offset=durationtools.Offset(1, 4),
            stop_offset=durationtools.Offset(11, 8),
            layer=3,
            music_specifier='violin music',
            voice_name='Violin Voice',
            ),
        ]
    )
\end{minted}
\begin{minted}{pycon}
>>> show(timespan_inventory, key='voice_name')
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-2ff86337118b328e4c105e83561b98c3.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Configuring the timespan-maker with padding creates silent timespans
around the beginning and end of each group of output timespans on a per-voice
basis. The timespan-maker will also configure these silent timespans with any
specified layer number, allowing them to be sorted along with performed
timespans from the same timespan-creation pass. Silent timespans are
illustrated with dashed line to distinguish them from performed timespans:

\begin{comment}
<abjad>
flooded_timespan_maker = consort.FloodedTimespanMaker(
    padding=Duration(1, 4),
    timespan_specifier=consort.TimespanSpecifier(
        minimum_duration=Duration(1, 8),
        ),
    )
timespan_inventory = flooded_timespan_maker(
    layer=5,
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
print(format(timespan_inventory))
show(timespan_inventory, key='voice_name')
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> flooded_timespan_maker = consort.FloodedTimespanMaker(
...     padding=Duration(1, 4),
...     timespan_specifier=consort.TimespanSpecifier(
...         minimum_duration=Duration(1, 8),
...         ),
...     )
>>> timespan_inventory = flooded_timespan_maker(
...     layer=5,
...     music_specifiers=music_specifiers,
...     target_timespan=target_timespan,
...     )
>>> print(format(timespan_inventory))
timespantools.TimespanInventory(
    [
        consort.tools.SilentTimespan(
            start_offset=durationtools.Offset(0, 1),
            stop_offset=durationtools.Offset(1, 4),
            layer=5,
            voice_name='Violin Voice',
            ),
        consort.tools.SilentTimespan(
            start_offset=durationtools.Offset(0, 1),
            stop_offset=durationtools.Offset(1, 4),
            layer=5,
            voice_name='Cello Voice',
            ),
        consort.tools.PerformedTimespan(
            start_offset=durationtools.Offset(1, 4),
            stop_offset=durationtools.Offset(11, 8),
            layer=5,
            minimum_duration=durationtools.Duration(1, 8),
            music_specifier='cello music',
            voice_name='Cello Voice',
            ),
        consort.tools.PerformedTimespan(
            start_offset=durationtools.Offset(1, 4),
            stop_offset=durationtools.Offset(11, 8),
            layer=5,
            minimum_duration=durationtools.Duration(1, 8),
            music_specifier='violin music',
            voice_name='Violin Voice',
            ),
        consort.tools.SilentTimespan(
            start_offset=durationtools.Offset(11, 8),
            stop_offset=durationtools.Offset(13, 8),
            layer=5,
            voice_name='Violin Voice',
            ),
        consort.tools.SilentTimespan(
            start_offset=durationtools.Offset(11, 8),
            stop_offset=durationtools.Offset(13, 8),
            layer=5,
            voice_name='Cello Voice',
            ),
        ]
    )
\end{minted}
\begin{minted}{pycon}
>>> show(timespan_inventory, key='voice_name')
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-17087858a1aa81c89c499e41f283c263.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\subsection{Talea timespan-makers} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{ssec:talea-timespan-makers}

Consort's \texttt{TaleaTimespanMaker} class creates rich timespan textures
through the use of \emph{talea} -- infinitely cyclic duration patterns. Abjad
implements the concept of talea via the \texttt{Talea} class in its
\texttt{rhythmmakertools} library, which is discussed at length in
\autoref{sec:rhythm-makers}. \texttt{Talea} objects define their infinitely
cyclic sequence of durations in terms of a finite sequence of numerators paired
with a single denominator. Once defined, they can be iterated over and indexed
like an infinite sequence, simplifying the process of generating looped
patterns of durations of arbitrary lengths:

\begin{comment}
<abjad>
talea = rhythmmakertools.Talea(
    counts=[1, 2, 3, 4],
    denominator=16,
    )
for index in range(10):
    talea[index]

talea[99999]
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> talea = rhythmmakertools.Talea(
...     counts=[1, 2, 3, 4],
...     denominator=16,
...     )
>>> for index in range(10):
...     talea[index]
...
NonreducedFraction(1, 16)
NonreducedFraction(2, 16)
NonreducedFraction(3, 16)
NonreducedFraction(4, 16)
NonreducedFraction(1, 16)
NonreducedFraction(2, 16)
NonreducedFraction(3, 16)
NonreducedFraction(4, 16)
NonreducedFraction(1, 16)
NonreducedFraction(2, 16)
\end{minted}
\begin{minted}{pycon}
>>> talea[99999]
NonreducedFraction(4, 16)
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent \emph{Talea} timespan-makers make use of talea to control patterns of
performed durations and silences. These timespan-makers can create timespans in
\emph{synchronized} or \emph{unsynchronized} fashions. Unsynchronized timespan
generation proceeds voice-by-voice through the input
voice-name-to-music-specifier mapping, creating timespans from the start of the
target timespan until its stop, then wrapping around to the next voice. Such
unsynchronized timespan creation is ideal for creating massed textures of
seemingly-unrelated timespans. Careful management of silence patterns and
contiguous timespan group lengths during unsynchronized creation can create
dense, overlapping textures or sparse, pointillistic ones. Contrastingly,
synchronized creation provides a mechanism for creating moments of shared
attack across voices, followed by shared silences:

\begin{comment}
<abjad>
talea_timespan_maker = consort.TaleaTimespanMaker()
print(format(talea_timespan_maker))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> talea_timespan_maker = consort.TaleaTimespanMaker()
>>> print(format(talea_timespan_maker))
consort.tools.TaleaTimespanMaker(
    playing_talea=rhythmmakertools.Talea(
        counts=(4,),
        denominator=16,
        ),
    playing_groupings=(1,),
    repeat=True,
    silence_talea=rhythmmakertools.Talea(
        counts=(4,),
        denominator=16,
        ),
    step_anchor=Right,
    synchronize_groupings=False,
    synchronize_step=False,
    )
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

All of the timespan inventories created in the following talea timespan-maker
examples make use of the same music specifier mapping and target timespan. An
ordered dictionary from Python's \texttt{collections} module guarantees that
the timespan-makers process the music specifier entries in the same order, from
\enquote{Voice 1} through \enquote{Voice 4}:\footnote{ The hash implementation
used by Python's dictionary class does not guarantee any particular ordering of
keys, and may differ from one version of Python to the next, or even from one
machine architecture to the next. While the timespan inventory illustrations
shown with voice-name labels appear ordered, that is because of explicit
lexical sorting of the voice-names in the illustration algorithm, not because
of any particular ordering in the timespan-maker's
voice-name-to-music-specifier mapping. Timespan-makers iterate over the keys in
that mapping when creating timespans, and plain dictionaries may lead to
unexpected results. For that reason, these examples -- and Consort itself --
make use of the \texttt{OrderedDict} class from Python's \texttt{collections}
module, which guarantees that keys be ordered by when they were inserted. }

\begin{comment}
<abjad>
import collections
music_specifiers = collections.OrderedDict([
    ('Voice 1', None),
    ('Voice 2', None),
    ('Voice 3', None),
    ('Voice 4', None),
    ])
target_timespan = timespantools.Timespan(0, (19, 4))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> import collections
>>> music_specifiers = collections.OrderedDict([
...     ('Voice 1', None),
...     ('Voice 2', None),
...     ('Voice 3', None),
...     ('Voice 4', None),
...     ])
>>> target_timespan = timespantools.Timespan(0, (19, 4))
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Without any manual configuration, talea timespan-makers generate
unsynchronized 1-length groups of \sfrac[big]{1}{4}-duration timespans, separated by
\sfrac[big]{1}{4}-duration silences, creating the appearance of synchronization
across voices:

\begin{comment}
<abjad>
result = talea_timespan_maker(
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
show(result, key='voice_name')
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> result = talea_timespan_maker(
...     music_specifiers=music_specifiers,
...     target_timespan=target_timespan,
...     )
>>> show(result, key='voice_name')
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-1c04143efb6b51f2f1f9ea1aed11f6de.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Changing the talea timespan-maker's \texttt{playing\_talea} property
from a series of \sfrac[big]{1}{4}-durations to \sfrac[big]{1}{4}, \sfrac[big]{2}{4},
\sfrac[big]{3}{4}, \sfrac[big]{4}{4} reveals the timespan-maker's voice-wrapping
behavior. Note how \enquote{Voice 1}'s timespans receive the durations
\sfrac[big]{1}{4}, \sfrac[big]{2}{4}, \sfrac[big]{3}{4}, \sfrac[big]{4}{4}, \sfrac[big]{1}{4} and
\sfrac[big]{2}{4}. \enquote{Voice 2} continues the duration sequence with
\sfrac[big]{3}{4}, \sfrac[big]{4}{4} and so forth. The playing-duration talea continues
to wrap around the end of each voice's timespans to the beginning of the next
voice's:

\begin{comment}
<abjad>
talea_timespan_maker = new(
    talea_timespan_maker,
    playing_talea=rhythmmakertools.Talea(
        counts=(1, 2, 3, 4),
        denominator=4,
        )
    )
result = talea_timespan_maker(
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
show(result, key='voice_name')
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> talea_timespan_maker = new(
...     talea_timespan_maker,
...     playing_talea=rhythmmakertools.Talea(
...         counts=(1, 2, 3, 4),
...         denominator=4,
...         )
...     )
>>> result = talea_timespan_maker(
...     music_specifiers=music_specifiers,
...     target_timespan=target_timespan,
...     )
>>> show(result, key='voice_name')
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-6cc02f83610a8d59e044f434461cd804.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent The talea timespan-maker's \texttt{playing\_groupings} property
controls how many timespans are created together as contiguous groups. When a
grouping would run beyond the stop offset provided by the target timespan, that
grouping's length is chosen again for the first timespan group of the next
voice's timespans. Note how \enquote{Voice 2}'s final timespan, from
\sfrac[big]{13}{4} to \sfrac[big]{4}{1}, should -- according to the following talea
timespan-maker's groupings pattern -- begin a group of length 2. Because that
grouping would run beyond the target timespan's \sfrac[big]{19}{4} stop offset, the
following voice's first timespan group receives the 2-length grouping instead:

\begin{comment}
<abjad>
talea_timespan_maker = new(
    talea_timespan_maker,
    playing_groupings=(1, 2),
    )
result = talea_timespan_maker(
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
show(result, key='voice_name')
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> talea_timespan_maker = new(
...     talea_timespan_maker,
...     playing_groupings=(1, 2),
...     )
>>> result = talea_timespan_maker(
...     music_specifiers=music_specifiers,
...     target_timespan=target_timespan,
...     )
>>> show(result, key='voice_name')
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-a54d4d094d4077509025de5ef97b94b9.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Reconfiguring the above talea timespan-maker with a different
\texttt{silence\_talea} produces patterned variations in the durations of
silences between timespan groups:

\begin{comment}
<abjad>
talea_timespan_maker = new(
    talea_timespan_maker,
    silence_talea=rhythmmakertools.Talea(
        counts=(3, 1, 1),
        denominator=8,
        ),
    )
result = talea_timespan_maker(
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
show(result, key='voice_name')
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> talea_timespan_maker = new(
...     talea_timespan_maker,
...     silence_talea=rhythmmakertools.Talea(
...         counts=(3, 1, 1),
...         denominator=8,
...         ),
...     )
>>> result = talea_timespan_maker(
...     music_specifiers=music_specifiers,
...     target_timespan=target_timespan,
...     )
>>> show(result, key='voice_name')
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-77be478ebf36606b6c530aa8dff599af.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Likewise, changing the \texttt{initial\_silence\_talea} produces
varying amounts of silence at the beginning of each voice:

\begin{comment}
<abjad>
talea_timespan_maker = new(
    talea_timespan_maker,
    initial_silence_talea=rhythmmakertools.Talea(
        counts=(0, 1, 3),
        denominator=8,
        ),
    )
result = talea_timespan_maker(
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
show(result, key='voice_name')
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> talea_timespan_maker = new(
...     talea_timespan_maker,
...     initial_silence_talea=rhythmmakertools.Talea(
...         counts=(0, 1, 3),
...         denominator=8,
...         ),
...     )
>>> result = talea_timespan_maker(
...     music_specifiers=music_specifiers,
...     target_timespan=target_timespan,
...     )
>>> show(result, key='voice_name')
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-6bb8e0c691dbc4e279b6a8eb1281127e.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Talea timespan-makers also provide for transformations derived from
the timespan inventory class itself. The \texttt{reflect} keyword configures
the timespan-maker to reflect its output timespan inventory around its own
axis, creating a \enquote{mirror image}:

\begin{comment}
<abjad>
talea_timespan_maker = new(
    talea_timespan_maker,
    reflect=True,
    )
result = talea_timespan_maker(
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
show(result, key='voice_name')
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> talea_timespan_maker = new(
...     talea_timespan_maker,
...     reflect=True,
...     )
>>> result = talea_timespan_maker(
...     music_specifiers=music_specifiers,
...     target_timespan=target_timespan,
...     )
>>> show(result, key='voice_name')
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-c8add88d2445d1747bd8b6e8fad82e97.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Synchronized talea timespan-makers can be created simply by
configuring a new timespan-maker with its \texttt{synchronize\_step} flag set
to true. This option causes the timespan-maker to create all of the timespans
in every voice at once, then select some amount of silence between the end of
that vertically-synchronized group and the beginning of the next. Note here how
the duration of each timespan follows the timespan-maker's \sfrac[big]{1}{4},
\sfrac[big]{2}{4}, \sfrac[big]{3}{4}, \sfrac[big]{4}{4}, \sfrac[big]{5}{4} pattern not from
left-to-right by voice, but top-to-bottom by voice and then left-to-right:

\begin{comment}
<abjad>
synchronized_talea_timespan_maker = consort.TaleaTimespanMaker(
    playing_talea=rhythmmakertools.Talea(
        counts=(1, 2, 3, 4, 5),
        denominator=8,
        ),
    silence_talea=rhythmmakertools.Talea(
        counts=(4, 7),
        denominator=8,
        ),
    synchronize_step=True,
    )
result = synchronized_talea_timespan_maker(
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
show(result, key='voice_name')
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> synchronized_talea_timespan_maker = consort.TaleaTimespanMaker(
...     playing_talea=rhythmmakertools.Talea(
...         counts=(1, 2, 3, 4, 5),
...         denominator=8,
...         ),
...     silence_talea=rhythmmakertools.Talea(
...         counts=(4, 7),
...         denominator=8,
...         ),
...     synchronize_step=True,
...     )
>>> result = synchronized_talea_timespan_maker(
...     music_specifiers=music_specifiers,
...     target_timespan=target_timespan,
...     )
>>> show(result, key='voice_name')
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-6f7eb9fb117ee8c7785e0de93249cf4c.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent The silence durations between these synchronized groups are
calculated from the end of the longest timespan in each group to the beginning
of the next group. Therefore the second group starts at \sfrac[big]{1}{1} because
the first silence duration is \sfrac[big]{4}{8} and the first group stops at
\sfrac[big]{1}{2}. Similarly, the third group starts at \sfrac[big]{5}{2} (\sfrac[big]{20}{8})
because the second silence duration is \sfrac[big]{7}{8} and the second group ended
at \sfrac[big]{13}{8}. This silence \emph{stepping} can also be calculated from the
beginning of one group to the next, rather than from the end of one to the
beginning of the next, by changing the timespan-maker's \texttt{step\_anchor}
property from \texttt{Right} to \texttt{Left}. Such a change helps guarantee
the timing of initial attacks across synchronized groups.

Initial silences behave differently in synchronized talea timespan-makers than
with unsynchronized talea timespan-makers. Rather than adding silences only at
the very beginning of each voice's timespans, silences are determined for each
voice at the beginning of each synchronized group. Note how \enquote{Voice 3}
is missing a fourth timespan. That timespan, with a duration of \sfrac[big]{5}{8},
and an initial silence of \sfrac[big]{2}{8} measured from the offset \sfrac[big]{4}{1},
would have extended to \sfrac[big]{39}{8} -- \sfrac[big]{1}{8} more than the target
timespan's \sfrac[big]{19}{4} stop offset:

\begin{comment}
<abjad>
synchronized_talea_timespan_maker = new(
    synchronized_talea_timespan_maker,
    initial_silence_talea=rhythmmakertools.Talea(
        counts=(0, 1, 2),
        denominator=8,
        ),
    )
result = synchronized_talea_timespan_maker(
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
show(result, key='voice_name')
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> synchronized_talea_timespan_maker = new(
...     synchronized_talea_timespan_maker,
...     initial_silence_talea=rhythmmakertools.Talea(
...         counts=(0, 1, 2),
...         denominator=8,
...         ),
...     )
>>> result = synchronized_talea_timespan_maker(
...     music_specifiers=music_specifiers,
...     target_timespan=target_timespan,
...     )
>>> show(result, key='voice_name')
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-6fa91e7efcb006c0b9cb5c5888225957.pdf}
\end{singlespacing}
\end{abjadbookoutput}

%\todo[inline]{\textbf{TODO:} Correct this padding explanation.}

\noindent Unlike flooded timespan-makers, padding durations are included in the
start offset and step duration calculations for talea timespan-makers:

\begin{comment}
<abjad>
synchronized_talea_timespan_maker = new(
    synchronized_talea_timespan_maker,
    padding=(1, 8),
    )
result = synchronized_talea_timespan_maker(
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
show(result, key='voice_name')
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> synchronized_talea_timespan_maker = new(
...     synchronized_talea_timespan_maker,
...     padding=(1, 8),
...     )
>>> result = synchronized_talea_timespan_maker(
...     music_specifiers=music_specifiers,
...     target_timespan=target_timespan,
...     )
>>> show(result, key='voice_name')
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-374386692db230f3f27cfbf7885d0d75.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\subsection{Dependent timespan-makers} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{ssec:dependent-timespan-makers}

\emph{Dependent} timespan-makers create timespans based on the disposition of
timespans in an input timespan inventory, selecting the start and stop offsets
of their generated timespans by filtering and inspecting timespans from their
input with respect to their voice name or music specifier label. This behavior
helps model how timespans used to generate phrasing for a pianist's pedaling
voice can be derived by selecting only those timespans in a timespan inventory
for entire ensemble which pertain to the pianists right and left-hand voices,
ignoring all others.

Consider the following timespan inventory, comprised of both overlapping and
non-overlapping timespans created for the contexts \enquote{Voice 1},
\enquote{Voice 2} and \enquote{Ignored Voice}:

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    consort.PerformedTimespan(0, 10, voice_name='Voice 1'),
    consort.PerformedTimespan(0, 10, voice_name='Voice 2'),
    consort.PerformedTimespan(5, 20, voice_name='Ignored Voice'),
    consort.PerformedTimespan(10, 20, voice_name='Voice 1'),
    consort.PerformedTimespan(15, 35, voice_name='Voice 2'),
    consort.PerformedTimespan(25, 30, voice_name='Voice 1'),
    consort.PerformedTimespan(30, 45, voice_name='Ignored Voice'),
    consort.PerformedTimespan(40, 45, voice_name='Voice 2'),
    consort.PerformedTimespan(45, 75, voice_name='Voice 2'),
    consort.PerformedTimespan(50, 80, voice_name='Ignored Voice'),
    consort.PerformedTimespan(50, 60, voice_name='Voice 1'),
    ])
show(timespan_inventory, key='voice_name')
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> timespan_inventory = timespantools.TimespanInventory([
...     consort.PerformedTimespan(0, 10, voice_name='Voice 1'),
...     consort.PerformedTimespan(0, 10, voice_name='Voice 2'),
...     consort.PerformedTimespan(5, 20, voice_name='Ignored Voice'),
...     consort.PerformedTimespan(10, 20, voice_name='Voice 1'),
...     consort.PerformedTimespan(15, 35, voice_name='Voice 2'),
...     consort.PerformedTimespan(25, 30, voice_name='Voice 1'),
...     consort.PerformedTimespan(30, 45, voice_name='Ignored Voice'),
...     consort.PerformedTimespan(40, 45, voice_name='Voice 2'),
...     consort.PerformedTimespan(45, 75, voice_name='Voice 2'),
...     consort.PerformedTimespan(50, 80, voice_name='Ignored Voice'),
...     consort.PerformedTimespan(50, 60, voice_name='Voice 1'),
...     ])
>>> show(timespan_inventory, key='voice_name')
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-223cf90addfb88a368c32ce75c60582b.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent A dependent timespan-maker can be configured to depend on timespans
created for the \enquote{Voice 1} and \enquote{Voice 2} contexts by specifying
a tuple of voice names during instantiation. Passing the previously defined
timespan inventory as an argument when calling the dependent timespan-maker
adds the newly-created dependent timespans to it. For the sake of brevity, and
because timespan-makers modify any timespan inventory passed as an argument to
\texttt{\_\_call\_\_()} in-place, we pass a copy of this timespan inventory,
created via a call to \texttt{new()}, instead of the original:

\begin{comment}
<abjad>
music_specifiers = {'Dependent Voice': None}
dependent_timespan_maker = consort.DependentTimespanMaker(
    voice_names=(
        'Voice 1',
        'Voice 2',
        )
    )
result = dependent_timespan_maker(
    music_specifiers=music_specifiers,
    timespan_inventory=new(timespan_inventory),
    )
show(result, key='voice_name')
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> music_specifiers = {'Dependent Voice': None}
>>> dependent_timespan_maker = consort.DependentTimespanMaker(
...     voice_names=(
...         'Voice 1',
...         'Voice 2',
...         )
...     )
>>> result = dependent_timespan_maker(
...     music_specifiers=music_specifiers,
...     timespan_inventory=new(timespan_inventory),
...     )
>>> show(result, key='voice_name')
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-5ef2fd7dc873c2046847f508e4313b47.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Note how the above timespan inventory shows the timespans for
\enquote{Dependent Voice} outlining the start and stop offset for partitioned
shards of the timespans for \enquote{Voice 1} and \enquote{Voice 2}, but
ignoring the boundaries outlined by the timespans for the \enquote{Ignored
Voice} context. Dependent timespans first select all timespans from their input
timespan inventory matching their voice-names criteria, then partition them
into shards in order to determine which offsets to use for timespan creation.
Partitioning guarantees that the created dependent timespans do not exceed the
bounds of the timespans they depend upon.

Configuring the dependent timespan-maker with its
\texttt{include\_inner\_starts} flag set to true causes it to create contiguous
groups of dependent timespans, as though splitting at every moment when a
timespan it depends upon starts. Note that new dependent timespans begin at the
offsets \sfrac[big]{10}{1}, \sfrac[big]{15}{1} and \sfrac[big]{25}{1}, for example. This is
because a new timespan begins in \enquote{Voice 1} at both \sfrac[big]{10}{1} and
\sfrac[big]{25}{1}, and another new timespan begins in \enquote{Voice 2} at
\sfrac[big]{15}{1}:

\begin{comment}
<abjad>
new_dependent_timespan_maker = new(
    dependent_timespan_maker,
    include_inner_starts=True,
    )
result = new_dependent_timespan_maker(
    music_specifiers=music_specifiers,
    timespan_inventory=new(timespan_inventory),
    )
show(result, key='voice_name')
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> new_dependent_timespan_maker = new(
...     dependent_timespan_maker,
...     include_inner_starts=True,
...     )
>>> result = new_dependent_timespan_maker(
...     music_specifiers=music_specifiers,
...     timespan_inventory=new(timespan_inventory),
...     )
>>> show(result, key='voice_name')
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-009c82c4d26cf6651fd9df23540f25c3.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Likewise, the \texttt{include\_inner\_stops} flag causes the
dependent timespan-maker to take into account the stop offsets of any timespan
it depends upon:

\begin{comment}
<abjad>
new_dependent_timespan_maker = new(
    dependent_timespan_maker,
    include_inner_stops=True,
    )
result = new_dependent_timespan_maker(
    music_specifiers=music_specifiers,
    timespan_inventory=new(timespan_inventory),
    )
show(result, key='voice_name')
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> new_dependent_timespan_maker = new(
...     dependent_timespan_maker,
...     include_inner_stops=True,
...     )
>>> result = new_dependent_timespan_maker(
...     music_specifiers=music_specifiers,
...     timespan_inventory=new(timespan_inventory),
...     )
>>> show(result, key='voice_name')
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-fac98143a63f0b56c79cd9c5ad885b99.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Both options can be combined together, resulting in dependent
timespans outlining all offsets from the collection of timespans they depend
upon:

\begin{comment}
<abjad>
new_dependent_timespan_maker = new(
    dependent_timespan_maker,
    include_inner_starts=True,
    include_inner_stops=True,
    )
result = new_dependent_timespan_maker(
    music_specifiers=music_specifiers,
    timespan_inventory=new(timespan_inventory),
    )
show(result, key='voice_name')
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> new_dependent_timespan_maker = new(
...     dependent_timespan_maker,
...     include_inner_starts=True,
...     include_inner_stops=True,
...     )
>>> result = new_dependent_timespan_maker(
...     music_specifiers=music_specifiers,
...     timespan_inventory=new(timespan_inventory),
...     )
>>> show(result, key='voice_name')
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-6ce9d6e9a18b7e9abbc734b71cfeaaac.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Dependent timespan-makers are capable of performing simple
transformations on the offsets they extract from their input timespan
inventory. Rotation allows the timespan-maker to rotate the durations outlined
by the offsets extracted from the timespans they select. Specifying a rotation
index of 1 causes each created group of dependent timespans to rotate its
internal durations by that index. The 10-duration dependent timespan which
previously occurred first in the \enquote{Dependent Voice} now occurs second,
following a \sfrac[big]{5}{1}-duration timespan:

\begin{comment}
<abjad>
rotated_dependent_timespan_maker = new(
    new_dependent_timespan_maker,
    rotation_indices=(1,),
    )
result = rotated_dependent_timespan_maker(
    music_specifiers=music_specifiers,
    timespan_inventory=new(timespan_inventory),
    )
show(result, key='voice_name', range_=(0, 75))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> rotated_dependent_timespan_maker = new(
...     new_dependent_timespan_maker,
...     rotation_indices=(1,),
...     )
>>> result = rotated_dependent_timespan_maker(
...     music_specifiers=music_specifiers,
...     timespan_inventory=new(timespan_inventory),
...     )
>>> show(result, key='voice_name', range_=(0, 75))
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-46ba4c64e8a395852c66feae54905466.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent More than one rotation index can be specified, allowing for each
group of dependent timespans -- as created from each shard of the partitioned
selected timespans -- to be rotated independently:

\begin{comment}
<abjad>
rotated_dependent_timespan_maker = new(
    new_dependent_timespan_maker,
    rotation_indices=(1, -1),
    )
result = rotated_dependent_timespan_maker(
    music_specifiers=music_specifiers,
    timespan_inventory=new(timespan_inventory),
    )
show(result, key='voice_name', range_=(0, 75))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> rotated_dependent_timespan_maker = new(
...     new_dependent_timespan_maker,
...     rotation_indices=(1, -1),
...     )
>>> result = rotated_dependent_timespan_maker(
...     music_specifiers=music_specifiers,
...     timespan_inventory=new(timespan_inventory),
...     )
>>> show(result, key='voice_name', range_=(0, 75))
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-60fafcaeeaa43b48cadecde76a2aff66.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Note that in the previous dependent timespan-maker examples no target
timespan was specified. When passed a non-empty timespan inventory during
calling, timespan-makers can treat that inventory's timespan as their target
timespan if no target timespan was specified explicitly. However, passing a
target timespan to a dependent timespan-maker causes that timespan-maker to
perform a logical \texttt{AND} of the target timespan with any selected
timespans in the input inventory. Here the dependent timespans are constrained
between the offsets \sfrac[big]{17}{1} and \sfrac[big]{58}{1}:

\begin{comment}
<abjad>
result = new_dependent_timespan_maker(
    music_specifiers=music_specifiers,
    target_timespan=timespantools.Timespan(17, 58),
    timespan_inventory=new(timespan_inventory),
    )
show(result, key='voice_name', range_=(0, 75))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> result = new_dependent_timespan_maker(
...     music_specifiers=music_specifiers,
...     target_timespan=timespantools.Timespan(17, 58),
...     timespan_inventory=new(timespan_inventory),
...     )
>>> show(result, key='voice_name', range_=(0, 75))
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-eaffd2d83a50505a9469454270eda374.pdf}
\end{singlespacing}
\end{abjadbookoutput}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Rhythm-makers}
\label{sec:rhythm-makers}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Abjad's rhythm-makers, like Consort's timespan-makers, are highly-configurable
factory classes which behave like partially evaluated functions, taking as
input sequences of \emph{divisions} -- positive, non-reduced fraction
tokens\footnote{Rather than coercing input into sequences of \texttt{Duration}
objects, which reduce their denominators as much as possible, rhythm-makers
treat all input as \emph{non-reduced fractions}, allowing them to disambiguate
\sfrac[big]{4}{16} from \sfrac[big]{2}{8} or \sfrac[big]{6}{8} from \sfrac[big]{3}{4} and to
therefore treat those division tokens as distinct.} representing the divisions
in some phrase of music -- and producing selections of score components as
output. Abjad's \texttt{rhythmmakertools} library contains a variety of such
classes, each providing a different strategy for rhythm generation, but unified
by the same callable interface. Additionally, \texttt{rhythmmakertools}
provides a collection of \emph{specifier} classes which group related
configuration values together for controlling the behavior of ties, beams,
duration spelling and other notational aspects of each rhythm-maker's output.
Like many other classes in Abjad -- timespans, for example -- both these
specifiers and the rhythm-makers themselves can be templated via calls to
\texttt{new()}. A tour of these rhythm-maker classes demonstrates how a wide
range of rhythmic textures can be produced.

\subsection{Note rhythm-makers}
\label{ssec:note-rhythm-makers}

\emph{Note} rhythm-makers, arguably the simplest class of rhythm-maker, take a
sequence of input divisions and \enquote{fill} them with notes, tied as
necessary, such that the duration of each logical tie in each output division
equals the duration of each input division:

\begin{comment}
<abjad>
note_rhythm_maker = rhythmmakertools.NoteRhythmMaker()
divisions = [(3, 8), (4, 8), (3, 16), (4, 16), (5, 8), (2, 4)]
show(note_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> note_rhythm_maker = rhythmmakertools.NoteRhythmMaker()
>>> divisions = [(3, 8), (4, 8), (3, 16), (4, 16), (5, 8), (2, 4)]
>>> show(note_rhythm_maker, divisions=divisions)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-d0f66021e4860194d32ee0fa226ed174.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Like many objects implemented in Abjad and its extensions,
rhythm-makers can be illustrated via a call to \texttt{show()}. Rhythm-maker
illustrations take an optional \texttt{divisions} argument, specifying what
durations should be used for the generated rhythmic output, grouping each of
those divisions into measures for ease of visualization.

Rhythm-makers can be configured with a variety of specifiers, allowing for
optional customization of their rhythm-generating behavior. For example, a
\texttt{TieSpecifier} can be used to force a rhythm-maker to tie the last note
of each output division to the first note of the next output division. When
used with a note rhythm-maker, this effectively ties all notes in the output
together:

\begin{comment}
<abjad>
note_rhythm_maker = new(
    note_rhythm_maker,
    tie_specifier=rhythmmakertools.TieSpecifier(
        tie_across_divisions=True,
        ),
    )
show(note_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> note_rhythm_maker = new(
...     note_rhythm_maker,
...     tie_specifier=rhythmmakertools.TieSpecifier(
...         tie_across_divisions=True,
...         ),
...     )
>>> show(note_rhythm_maker, divisions=divisions)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-1c2192761535f741178fd5fc2ed22ed7.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Other rhythm-maker specifiers influence beaming, tuplet spelling, or
can cause a rhythm-maker to convert patterned groups of leaves in its output
from notes to rests or vice versa. Rhythm-makers configured with \emph{output
masks} replace the contents of their output divisions with rests in a patterned
per-division basis. A sequence of one or more \texttt{BooleanPattern} instances
control the masking pattern. These patterns partition the rhythm-maker's output
divisions into segments of a given period, and then mask out divisions
specified by indices within that period. For example, a note rhythm-maker
configured with a single output mask of a period of length 2 and a masking
index 0 will cause the first of every two divisions to be silenced:

\begin{comment}
<abjad>
mask = rhythmmakertools.BooleanPattern(indices=[0], period=2)
note_rhythm_maker = rhythmmakertools.NoteRhythmMaker(output_masks=[mask])
show(note_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> mask = rhythmmakertools.BooleanPattern(indices=[0], period=2)
>>> note_rhythm_maker = rhythmmakertools.NoteRhythmMaker(output_masks=[mask])
>>> show(note_rhythm_maker, divisions=divisions)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-fb60261fce39a6a8bed29c6bc1a39b14.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Reducing the period of the boolean pattern from 2 to 1 silences every
output division, effectively turning a note-generating rhythm-maker into a
rest-generating rhythm-maker:

\begin{comment}
<abjad>
mask = rhythmmakertools.BooleanPattern(indices=[0], period=1)
note_rhythm_maker = rhythmmakertools.NoteRhythmMaker(output_masks=[mask])
show(note_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> mask = rhythmmakertools.BooleanPattern(indices=[0], period=1)
>>> note_rhythm_maker = rhythmmakertools.NoteRhythmMaker(output_masks=[mask])
>>> show(note_rhythm_maker, divisions=divisions)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-b8d4d2abe1d0cabd1dba685a0e5a2bcc.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\subsection{Talea rhythm-makers}
\label{ssec:talea-rhythm-makers}

\emph{Talea} rhythm-makers, like talea timespan-makers, create rhythmic output through
the use of a talea -- an infinitely cyclic pattern of durations. Talea
rhythm-makers fill their output divisions with durations from their talea,
splitting those durations across division boundaries when the divisions are
over-full. The following trivial talea rhythm-maker uses a length-1 talea
comprised of a single \sfrac[big]{1}{16} duration:

\begin{comment}
<abjad>
talea_rhythm_maker = rhythmmakertools.TaleaRhythmMaker(
    talea=rhythmmakertools.Talea(
        counts=[1],
        denominator=16,
        ),
    )
show(talea_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> talea_rhythm_maker = rhythmmakertools.TaleaRhythmMaker(
...     talea=rhythmmakertools.Talea(
...         counts=[1],
...         denominator=16,
...         ),
...     )
>>> show(talea_rhythm_maker, divisions=divisions)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-a8d7d6245553b2c4f5d2e404e62ae27b.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Extending the talea counts to a sequence of alternating \sfrac[big]{1}{16}
and \sfrac[big]{1}{8} notes produces more complex results. Note how the \sfrac[big]{1}{8}
durations break over the boundaries of the \sfrac[big]{3}{16} measure, but remain
tied together. Talea rhythm-makers handle talea splitting and tying
transparently:

\begin{comment}
<abjad>
talea_rhythm_maker = new(
    talea_rhythm_maker,
    talea__counts=[1, 2],
    )
show(talea_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> talea_rhythm_maker = new(
...     talea_rhythm_maker,
...     talea__counts=[1, 2],
...     )
>>> show(talea_rhythm_maker, divisions=divisions)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-a91e80c7459af113e517ef98d44608db.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent With the talea counts changed to a descending sequence of durations,
the pattern of split and tied durations also changes:

\begin{comment}
<abjad>
talea_rhythm_maker = new(
    talea_rhythm_maker,
    talea__counts=[4, 3, 2, 1],
    )
show(talea_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> talea_rhythm_maker = new(
...     talea_rhythm_maker,
...     talea__counts=[4, 3, 2, 1],
...     )
>>> show(talea_rhythm_maker, divisions=divisions)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-8d6fdf555decf2c32991c6d1f43307af.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Talea rhythm-makers can be configured to treat input divisions as
though they had more counts than they actually do via their
\texttt{extra\_counts\_per\_division} property, causing tuplets to appear in
the output. The following talea, reconfigured from the previous, adds an extra
count to every second and third input division. This causes the \sfrac[big]{4}{8}
and \sfrac[big]{3}{16} as well as the \sfrac[big]{5}{8} and \sfrac[big]{2}{4} divisions to
become tuplets, each with a pre-prolated contents duration \sfrac[big]{1}{16} longer
than their prolated duration. In other words, the \sfrac[big]{4}{8} division
contains a tuplet whose contents sum to \sfrac[big]{9}{16}, but scaled into a
duration of \sfrac[big]{8}{16}. Likewise, the \sfrac[big]{3}{16} division contains a
tuplet whose contents sum to \sfrac[big]{4}{16}, but scaled into a duration of
\sfrac[big]{3}{16}. Note how this tupletting causes the pattern of split and tied
talea durations to shift. In the previous example, the second instance of the
talea's \sfrac[big]{3}{16} duration occurred entirely during the \sfrac[big]{3}{16}
division. Here, that same \sfrac[big]{3}{16} talea duration begins on the final
\sfrac[big]{1}{16} of the \sfrac[big]{4}{8} division's 9:8 tuplet, tied into the 4:3
tuplet in the following division:

\begin{comment}
<abjad>
talea_rhythm_maker = new(
    talea_rhythm_maker,
    extra_counts_per_division=[0, 1, 1],
    )
show(talea_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> talea_rhythm_maker = new(
...     talea_rhythm_maker,
...     extra_counts_per_division=[0, 1, 1],
...     )
>>> show(talea_rhythm_maker, divisions=divisions)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-f868ef7342d21df2f091666e876b44e7.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Like note rhythm-makers, talea rhythm-makers can be configured with a
tie specifier, causing the last note of each division to be tied to the first
note of the next division. In note rhythm-makers, the contents of each
non-masked division is guaranteed to be a single logical tie. Therefore, tying
across divisions results in the entire output of the note rhythm-maker merging
into the same logical tie. The output divisions of talea rhythm-makers
generally contain more than one logical tie, and therefore tying across
divisions tends to produce the effect of elided downbeats with intermittent
attacks:

\begin{comment}
<abjad>
talea_rhythm_maker = new(
    talea_rhythm_maker,
    tie_specifier=rhythmmakertools.TieSpecifier(
        tie_across_divisions=True,
        ),
    )
show(talea_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> talea_rhythm_maker = new(
...     talea_rhythm_maker,
...     tie_specifier=rhythmmakertools.TieSpecifier(
...         tie_across_divisions=True,
...         ),
...     )
>>> show(talea_rhythm_maker, divisions=divisions)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-0aa7f18c24b9676851fc7ace0fbb408e.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Talea rhythm-makers can also be configured to produce intermittent
silences, either by specifying negative count values in the rhythm-maker's
talea, or by configuring the rhythm-maker with a special \emph{burnish}
specifier which casts logical ties generated by the rhythm-maker as either
notes or rests, in a patterned way. Here, the 3-count in the talea
rhythm-maker's talea is changed to -3, resulting in the production of
\sfrac[big]{3}{16}-duration silences:

\begin{comment}
<abjad>
talea_rhythm_maker_with_rests = new(
    talea_rhythm_maker,
    talea__counts=[4, -3, 2, 1],
    )
show(talea_rhythm_maker_with_rests, divisions=divisions)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> talea_rhythm_maker_with_rests = new(
...     talea_rhythm_maker,
...     talea__counts=[4, -3, 2, 1],
...     )
>>> show(talea_rhythm_maker_with_rests, divisions=divisions)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-f4acf8cc0f640f8afb7dbc701a8bbc82.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Alternatively, configuring the rhythm-maker with the following
\texttt{BurnishSpecifier} allows the first logical tie of every other division
to be converted to rests:

\begin{comment}
<abjad>
talea_rhythm_maker_with_rests = new(
    talea_rhythm_maker,
    burnish_specifier=rhythmmakertools.BurnishSpecifier(
        left_classes=[Rest],
        left_counts=[1, 0],
        ),
    )
show(talea_rhythm_maker_with_rests, divisions=divisions)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> talea_rhythm_maker_with_rests = new(
...     talea_rhythm_maker,
...     burnish_specifier=rhythmmakertools.BurnishSpecifier(
...         left_classes=[Rest],
...         left_counts=[1, 0],
...         ),
...     )
>>> show(talea_rhythm_maker_with_rests, divisions=divisions)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-56c4a8d2c9d313021bf1f182ccb3a96e.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\subsection{Incised rhythm-makers}
\label{ssec:incised-rhythm-makers}

\emph{Incised} rhythm-makers behave similarly to note rhythm-makers, but allow
for \emph{incising} patterned sequences of notes and rests from the beginnings
and ends of each output division, or even from the beginning and end of the
entire sequence of divisions -- the rhythm-maker \emph{output}. Configuring an
incised rhythm-maker to perform incision requires an \texttt{InciseSpecifier}
instance. An unconfigured incised rhythm-maker behaves identically to an
unconfigured note rhythm-maker:

\begin{comment}
<abjad>
incised_rhythm_maker = rhythmmakertools.IncisedRhythmMaker()
show(incised_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> incised_rhythm_maker = rhythmmakertools.IncisedRhythmMaker()
>>> show(incised_rhythm_maker, divisions=divisions)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-d0f66021e4860194d32ee0fa226ed174.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Incise specifiers define talea and group counts for prefix and suffix
incision. The talea -- as determined by the numerators given in the
\texttt{prefix\_talea} and \texttt{suffix\_talea} sequences combined with the
\texttt{talea\_denominator} -- define the durations to be selected from, as
well as the \emph{sign} of the component to be incised. Negative talea items
indicate rests, while positive talea items indicate notes. The count properties
-- \texttt{suffix\_counts} and \texttt{prefix\_counts} -- indicate how many
talea durations should be selected at each pass. The following incised
rhythm-maker incises a single \sfrac[big]{1}{16} rest at the end of each division:

\begin{comment}
<abjad>
incised_rhythm_maker = rhythmmakertools.IncisedRhythmMaker(
    incise_specifier=rhythmmakertools.InciseSpecifier(
        suffix_counts=[1],
        suffix_talea=[-1],
        talea_denominator=16,
        ),
    )
show(incised_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> incised_rhythm_maker = rhythmmakertools.IncisedRhythmMaker(
...     incise_specifier=rhythmmakertools.InciseSpecifier(
...         suffix_counts=[1],
...         suffix_talea=[-1],
...         talea_denominator=16,
...         ),
...     )
>>> show(incised_rhythm_maker, divisions=divisions)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-f21215b14c3e76d687060a020bdca52a.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Extending the suffix talea results in a more complex incision
pattern:

\begin{comment}
<abjad>
incised_rhythm_maker = new(
    incised_rhythm_maker,
    incise_specifier__suffix_talea=[-1, -2, -3],
    )
show(incised_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> incised_rhythm_maker = new(
...     incised_rhythm_maker,
...     incise_specifier__suffix_talea=[-1, -2, -3],
...     )
>>> show(incised_rhythm_maker, divisions=divisions)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-fafb95028809a8071ef2a59e4da26ec9.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Prefix incision occurs in an identical fashion, by specifying
sequences of group counts and talea numerators. Here, alternating groups of
notes of length-1 and length-2 are incised from the beginning of each division:

\begin{comment}
<abjad>
incised_rhythm_maker = rhythmmakertools.IncisedRhythmMaker(
    incise_specifier=rhythmmakertools.InciseSpecifier(
        prefix_counts=[2, 1],
        prefix_talea=[2, 1],
        talea_denominator=16,
        ),
    )
show(incised_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> incised_rhythm_maker = rhythmmakertools.IncisedRhythmMaker(
...     incise_specifier=rhythmmakertools.InciseSpecifier(
...         prefix_counts=[2, 1],
...         prefix_talea=[2, 1],
...         talea_denominator=16,
...         ),
...     )
>>> show(incised_rhythm_maker, divisions=divisions)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-c2461da064af411639e8a2608af00305.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Setting the incise specifier's \texttt{fill\_with\_notes} property to
false causes the rhythm-maker to fill the unincised portions of its output
divisions with rests rather notes. Filled mainly with silence, the incision
pattern becomes much clearer:

\begin{comment}
<abjad>
incised_rhythm_maker = new(
    incised_rhythm_maker,
    incise_specifier__fill_with_notes=False,
    )
show(incised_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> incised_rhythm_maker = new(
...     incised_rhythm_maker,
...     incise_specifier__fill_with_notes=False,
...     )
>>> show(incised_rhythm_maker, divisions=divisions)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-25581a22cd4059e8966b0ff386bbbcc6.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Incised rhythm-makers can be configured to only incise the outer
divisions of their output. The following rhythm-maker cuts \sfrac[big]{1}{8} rests
from the beginning of the first division in its output, and the end of the last
division:

\begin{comment}
<abjad>
incised_rhythm_maker = rhythmmakertools.IncisedRhythmMaker(
    incise_specifier=rhythmmakertools.InciseSpecifier(
        outer_divisions_only=True,
        prefix_counts=[1],
        prefix_talea=[-1],
        suffix_counts=[1],
        suffix_talea=[-1],
        talea_denominator=8,
        ),
    )
show(incised_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> incised_rhythm_maker = rhythmmakertools.IncisedRhythmMaker(
...     incise_specifier=rhythmmakertools.InciseSpecifier(
...         outer_divisions_only=True,
...         prefix_counts=[1],
...         prefix_talea=[-1],
...         suffix_counts=[1],
...         suffix_talea=[-1],
...         talea_denominator=8,
...         ),
...     )
>>> show(incised_rhythm_maker, divisions=divisions)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-8245f754d4c0b647786ba2c3e22988f3.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Incised rhythm-makers also respect many of the same rhythm-maker
specifiers as the other rhythm-maker classes defined in Abjad's
\texttt{rhythmmakertools} library. Like note rhythm-makers, they can be
configured to tie the last note of each output division to the first note of
the next output division via an instance of the \texttt{TieSpecifier} class:

\begin{comment}
<abjad>
incised_rhythm_maker = new(
    incised_rhythm_maker,
    tie_specifier=rhythmmakertools.TieSpecifier(
        tie_across_divisions=True,
        ),
    )
show(incised_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> incised_rhythm_maker = new(
...     incised_rhythm_maker,
...     tie_specifier=rhythmmakertools.TieSpecifier(
...         tie_across_divisions=True,
...         ),
...     )
>>> show(incised_rhythm_maker, divisions=divisions)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-9890ffbc1115862a9479f6a97bf677e3.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\subsection{Even-division rhythm-makers}
\label{ssec:even-division-rhythm-makers}

\emph{Even-division} rhythm-makers attempt to divide each input division into
runs of notes with a basic duration \texttt{1/denominator}, where the
\texttt{denominator} is specified on a per-division basis by the rhythm-maker's
configurable \texttt{denominator} sequence property. When an input division
does not exactly fit some multiple of this basic duration, some combination of
augmentation or tupletting will be used to produce notes with durations as
close to that basic duration as possible:

\begin{comment}
<abjad>
even_division_rhythm_maker = rhythmmakertools.EvenDivisionRhythmMaker()
show(even_division_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> even_division_rhythm_maker = rhythmmakertools.EvenDivisionRhythmMaker()
>>> show(even_division_rhythm_maker, divisions=divisions)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-2bcea48859d1e8378a750341c3315103.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Extending the even-division rhythm-maker's denominator sequence to a
2-length pattern produces divisions filled alternatingly with \sfrac[big]{1}{8} and
\sfrac[big]{1}{16} notes. Note that the \sfrac[big]{3}{16} measure is filled with a
dotted \sfrac[big]{1}{8} note:

\begin{comment}
<abjad>
even_division_rhythm_maker = new(
    even_division_rhythm_maker,
    denominators=[8, 16],
    )
show(even_division_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> even_division_rhythm_maker = new(
...     even_division_rhythm_maker,
...     denominators=[8, 16],
...     )
>>> show(even_division_rhythm_maker, divisions=divisions)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-042a232c8ba3c9adb624c404980efe18.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Extending the denominator sequence even further results in more
complex output. Note here how the \sfrac[big]{5}{8} division is rendered as a
tuplet:

\begin{comment}
<abjad>
even_division_rhythm_maker = new(
    even_division_rhythm_maker,
    denominators=[8, 4, 16],
    )
show(even_division_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> even_division_rhythm_maker = new(
...     even_division_rhythm_maker,
...     denominators=[8, 4, 16],
...     )
>>> show(even_division_rhythm_maker, divisions=divisions)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-18b3464ab66c7d829de5417e6e668687.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Like the talea rhythm-maker, even-division rhythm-makers can be
configured to add extra counts to each output division, forcing the
rhythm-maker to treat input divisions as longer than they actually are.
Artificially lengthened divisions are rendered as tuplets. With the following
rhythm-maker which attempts to fill each output division with a run of
\sfrac[big]{1}{8} notes, every other division is extended by one count, causing the
\sfrac[big]{4}{8} and \sfrac[big]{2}{4} divisions to be rendered as 5:4 tuplets, and the
\sfrac[big]{4}{16} division to be rendered as a 3:2 tuplet:

\begin{comment}
<abjad>
even_division_rhythm_maker = new(
    even_division_rhythm_maker,
    denominators=[8],
    extra_counts_per_division=(0, 1),
    )
show(even_division_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> even_division_rhythm_maker = new(
...     even_division_rhythm_maker,
...     denominators=[8],
...     extra_counts_per_division=(0, 1),
...     )
>>> show(even_division_rhythm_maker, divisions=divisions)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-7bd6867c75e18e48ebf2c898a35a53b9.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent When configured with a tie specifier, the even-division rhythm-maker
obscures the downbeat of every output division:

\begin{comment}
<abjad>
even_division_rhythm_maker = new(
    even_division_rhythm_maker,
    tie_specifier=rhythmmakertools.TieSpecifier(
        tie_across_divisions=True,
        ),
    )
show(even_division_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> even_division_rhythm_maker = new(
...     even_division_rhythm_maker,
...     tie_specifier=rhythmmakertools.TieSpecifier(
...         tie_across_divisions=True,
...         ),
...     )
>>> show(even_division_rhythm_maker, divisions=divisions)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-4cc7ba58b448cb7add8a0024b1e90f9b.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent And when reconfigured with the earlier 8-4-16 denominator pattern,
the even-division rhythm-maker produces rich tupletted rhythmic output:

\begin{comment}
<abjad>
even_division_rhythm_maker = new(
    even_division_rhythm_maker,
    denominators=[8, 4, 16],
    )
show(even_division_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> even_division_rhythm_maker = new(
...     even_division_rhythm_maker,
...     denominators=[8, 4, 16],
...     )
>>> show(even_division_rhythm_maker, divisions=divisions)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-af43995b8651db6fd08d7d3e42ff809b.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\subsection{Composite rhythm-makers}
\label{ssec:composite-rhythm-makers}

Consort provides a class for aggregating multiple rhythm-maker instances
together into a \emph{composite} rhythm-maker, which applies its aggregated
rhythm-makers conditionally against input divisions to generate rhythmic
output. The following contrived composite rhythm-maker uses the previously note
rhythm-maker -- which only generates rests -- for the last of any sequence of
input divisions, the previously defined incised rhythm-maker for the first of
any sequence of input divisions, and the previously defined talea rhythm-maker
for all other input divisions:

\begin{comment}
<abjad>
composite_rhythm_maker = consort.CompositeRhythmMaker(
    default=talea_rhythm_maker,
    last=note_rhythm_maker,
    first=incised_rhythm_maker,
    )
show(composite_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> composite_rhythm_maker = consort.CompositeRhythmMaker(
...     default=talea_rhythm_maker,
...     last=note_rhythm_maker,
...     first=incised_rhythm_maker,
...     )
>>> show(composite_rhythm_maker, divisions=divisions)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-b1e38a72e659f0b2878d87c5401d2cd5.pdf}
\end{singlespacing}
\end{abjadbookoutput}

%\todo[inline]{\textbf{TODO:} Conclude composite rhythm-maker discussion with a
%motivating example.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Meter}
\label{sec:meter}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\todo[inline]{\textbf{TODO:} Provide a definition of meter. Cite Lerdahl.}

Abjad models meter as a \emph{rhythm-tree} of nested, durated nodes which
outline a series of strongly and weakly accented offsets. The accent strength
of a particular offset found in a meter's rhythm-tree derives from the number
of nodes in that tree sharing that offset as a start or stop. The more nodes in
the rhythm-tree which share an offset, the greater the weight -- the
accentedness -- of that offset is taken to be. Abjad can construct the rhythm
tree for any meter from a numerator / denominator pair such as a rational
duration or time signature. Meter construction involves the progressive
division of the numerator of the input pair into groups of two and
threes\footnote{The factors 4 and 5 are also used in meter rhythm-tree
generation as they provide better typical results during meter rewriting.}, and
the decomposition of any other prime factors into groups of threes and twos.
Division by two always occurs before division by three, giving preference to
even metrical structures above odd or otherwise prime divisions. Constructing
rhythm-trees in this fashion gives results which generally align with common
practice expectations.

Consider the following \sfrac[big]{6}{8} meter and its graph representation:

\begin{comment}
<abjad>
six_eight_meter = metertools.Meter((6, 8))
graph(six_eight_meter)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> six_eight_meter = metertools.Meter((6, 8))
>>> graph(six_eight_meter)
\end{minted}
\noindent\includegraphics[scale=0.4,max width=\textwidth,]{assets/graphviz-def059788733b2da292c28ae106a47f5.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent The triangular and rectangular boxes indicate nodes in the
rhythm-tree itself. Rectangular boxes represent \enquote{beats} -- the leaves
of the rhythm-tree -- while triangular boxes indicate larger metrical
groupings. The ovals at the bottom of the graph indicate -- at their top -- the
start or stop offset of the nodes connected to them from above and -- at their
bottom -- the relative weight of their accent. The final oval on the right
indicates the offset and accent weight of the \enquote{next} downbeat.

The topmost triangle in the above graph represent the \enquote{highest}
metrical grouping in a \sfrac[big]{6}{8} meter. Tracing the leftmost and rightmost
arrows down through the topmost node's children gives the offsets 0 and
\sfrac[big]{3}{4}: the first downbeat and next downbeat in a \sfrac[big]{6}{8} meter.
Offsets 0 and \sfrac[big]{3}{4} also have the strongest accent weights as they occur
as either the start offset or stop offset of nodes at three levels of hierarchy
in the rhythm tree. At the second level the \sfrac[big]{6}{8} grouping divides into
two \sfrac[big]{3}{8} groupings, following common practice expectations: metrical
groupings tend to subdivide into groups of two before they subdivide into
groups of three.\footnote{Consider a \sfrac[big]{12}{8} meter. Western musicians
tend to subdivide twelve into either two groups of six or four groups of three
rather than into three groups of four.} Both second-level nodes share the
offset of \sfrac[big]{3}{8}, which also occurs in the third level, giving
\sfrac[big]{3}{8} a weight of two. The third level contains the \sfrac[big]{1}{8}
duration beats, grouped by their parents in the second level into two groups
three \sfrac[big]{1}{8} duration nodes. The offsets \sfrac[big]{1}{8}, \sfrac[big]{1}{4},
\sfrac[big]{1}{2} and \sfrac[big]{5}{8} are not shared by any nodes except at the lowest
metrical level and therefore all receive an accent weight of one.

Consider the following other examples of meters modeled in Abjad. A
\sfrac[big]{3}{4} meter consists of a top-level \sfrac[big]{3}{4} metrical grouping
divided into three \sfrac[big]{1}{4} duration beats:

\begin{comment}
<abjad>
three_four_meter = metertools.Meter((3, 4))
graph(three_four_meter)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> three_four_meter = metertools.Meter((3, 4))
>>> graph(three_four_meter)
\end{minted}
\noindent\includegraphics[scale=0.4,max width=\textwidth,]{assets/graphviz-7e2283286be19b5809bee13cf64d83ee.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent By default, a \sfrac[big]{7}{8} meter subdivides its top-level metrical
grouping into \sfrac[big]{3}{8}+\sfrac[big]{2}{8}+\sfrac[big]{2}{8} groupings:

\begin{comment}
<abjad>
seven_eight_meter = metertools.Meter((7, 8))
graph(seven_eight_meter)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> seven_eight_meter = metertools.Meter((7, 8))
>>> graph(seven_eight_meter)
\end{minted}
\noindent\includegraphics[scale=0.4,max width=\textwidth,]{assets/graphviz-471b95516a5478acd802a75bc0f152fc.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent A \sfrac[big]{12}{8} meter subdivides into four \sfrac[big]{3}{8} duration
groupings, each containing three \sfrac[big]{1}{8} duration beats:

\begin{comment}
<abjad>
twelve_eight_meter = metertools.Meter((12, 8))
graph(twelve_eight_meter)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> twelve_eight_meter = metertools.Meter((12, 8))
>>> graph(twelve_eight_meter)
\end{minted}
\noindent\includegraphics[scale=0.4,max width=\textwidth,]{assets/graphviz-58c5711f30ce38a0be0ec2aad3b65181.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Abjad also permits alternate representations of meters which
ostensibly share the same numerator and denominator. The default interpretation
of \sfrac[big]{4}{4} generates a top-level rhythmic grouping with a duration of
\sfrac[big]{4}{4} and four \sfrac[big]{1}{4} beats as children:\footnote{A \enquote{flat}
\sfrac[big]{4}{4} metrical structure is useful for meter rewriting as it allows the
meter rewriting algorithm to ignore many common rhythmic idioms like
\sfrac[big]{1}{4}+\sfrac[big]{1}{2}+\sfrac[big]{1}{4} and \sfrac[big]{1}{4}+\sfrac[big]{3}{4}.}

\begin{comment}
<abjad>
four_four_meter = metertools.Meter((4, 4))
graph(four_four_meter)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> four_four_meter = metertools.Meter((4, 4))
>>> graph(four_four_meter)
\end{minted}
\noindent\includegraphics[scale=0.4,max width=\textwidth,]{assets/graphviz-12601707db5ddc467e3296e8c680ba43.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent While meter objects are usually instantiated from numerator /
denominator pairs, with their rhythm-tree structure determined programmatically
from that input pair, they can also be instantiated from strings parsable as
rhythm-trees, or from rhythm-tree objects themselves. All meters, because they
are implemented in terms of rhythm-trees, can be represented by a Lisp-like
rhythm-tree syntax:

\begin{comment}
<abjad>
print(four_four_meter.pretty_rtm_format)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> print(four_four_meter.pretty_rtm_format)
(4/4 (
	1/4
	1/4
	1/4
	1/4))
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Instantiating meters from explicit rhythm tree syntax allows
composers to choose alternate representations of metrical structures. For
example, a \sfrac[big]{4}{4} meter which strongly emphasizes beat three is possible
by subdividing the top-level \sfrac[big]{4}{4} metrical grouping into two
\sfrac[big]{2}{4} duration groupings, which are then subdivided each into two
\sfrac[big]{1}{4} duration beats. Such a metrical structure effectively treats
\sfrac[big]{4}{4} as identical to \sfrac[big]{2}{2}:

\begin{comment}
<abjad>
arbitrary_meter_1 = metertools.Meter('(4/4 ((2/4 (1/4 1/4)) (2/4 (1/4 1/4))))')
graph(arbitrary_meter_1)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> arbitrary_meter_1 = metertools.Meter('(4/4 ((2/4 (1/4 1/4)) (2/4 (1/4 1/4))))')
>>> graph(arbitrary_meter_1)
\end{minted}
\noindent\includegraphics[scale=0.4,max width=\textwidth,]{assets/graphviz-24dec0c4fa2e028c1bffb9c05dbc48a3.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Unusual metrical structures are also possible, such as the following
\sfrac[big]{4}{4} meter which divides into two parts, with the first part dividing
into two again, and the second grouping of that divided into two again:

\begin{comment}
<abjad>
arbitrary_meter_2 = metertools.Meter('(4/4 ((2/4 (1/4 (1/4 (1/8 1/8)))) 1/2))')
graph(arbitrary_meter_2)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> arbitrary_meter_2 = metertools.Meter('(4/4 ((2/4 (1/4 (1/4 (1/8 1/8)))) 1/2))')
>>> graph(arbitrary_meter_2)
\end{minted}
\noindent\includegraphics[scale=0.4,max width=\textwidth,]{assets/graphviz-dd9099ec3dbba4936095eec5d635cc0d.pdf}
\end{singlespacing}
\end{abjadbookoutput}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Rewriting meters}
\label{sec:rewriting-meters}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\todo[inline]{\textbf{TODO:} Remove subscripts in rewrite\_meter() calls.}

Notated rhythms can be expressed in multiple ways while maintaining the same
attack-point and duration structure. \emph{Meter rewriting} formalizes the
process of re-notating a rhythm according to the offset structure inherent to
some meter while maintaining the original attack-points and durations by fusing
and splitting logical ties according to their \emph{validity}. In the context
of meter rewriting, validity expresses whether any logical tie -- trivial or
not -- \emph{aligns} to offsets found in nodes at a particular depth in a
meter's rhythm-tree. Alignment requires that a given logical tie either starts
or stops at offsets found in the collection of offsets defined by a subtree of
nodes in a meter's rhythm-tree. Meter rewriting proceeds by testing logical
ties against offsets outlined first by the root node of a meter and, if found
invalid, against those offsets found in nodes progressively deeper in the
meter's rhythm-tree.

For example, the offsets outlined by the root node of a \sfrac[big]{6}{8} meter can
be found by examining its depth-wise offset inventory:

\begin{comment}
<abjad>
six_eight_meter = metertools.Meter((6, 8))
six_eight_meter.depthwise_offset_inventory[0]
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> six_eight_meter = metertools.Meter((6, 8))
>>> six_eight_meter.depthwise_offset_inventory[0]
(Offset(0, 1), Offset(3, 4))
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent A logical tie three-quarters in duration starting at the offset 0
would be considered valid in the context of \sfrac[big]{6}{8} because it aligns to
the offsets outlined at depth-0 of the meter's rhythm-tree. In contrast, a
logical tie two quarters in duration starting at \sfrac[big]{1}{8} -- therefore
outlining the timespan of \sfrac[big]{1}{8}:\sfrac[big]{5}{8} -- would be considered
invalid due to misalignment:

\begin{comment}
<abjad>
six_eight_measure = Measure((6, 8), "r8 c'2 r8")
show(six_eight_measure)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> six_eight_measure = Measure((6, 8), "r8 c'2 r8")
>>> show(six_eight_measure)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-2dd583c36ffd0a13968eee4ac11dcfb5.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Meter rewriting splits misaligned logical ties at any possible offset
found in the currently considered depth. If no offsets at that depth intersect
with the misaligned tie, the depth is increased and the process repeats. At a
depth of 1 in a \sfrac[big]{6}{8} meter we finally find an offset intersecting the
timespan of the misaligned \sfrac[big]{1}{8}:\sfrac[big]{5}{8} logical tie at the offset
\sfrac[big]{3}{8}:

\begin{comment}
<abjad>
six_eight_meter.depthwise_offset_inventory[1]
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> six_eight_meter.depthwise_offset_inventory[1]
(Offset(0, 1), Offset(3, 8), Offset(3, 4))
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Rewriting the contents of the \sfrac[big]{6}{8} measure against a
\sfrac[big]{6}{8} meter splits the inner half-note at the \sfrac[big]{3}{8} offset
boundary:

\begin{comment}
<abjad>
mutate(six_eight_measure).rewrite_meter(six_eight_meter)
show(six_eight_measure)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> mutate(six_eight_measure).rewrite_meter(six_eight_meter)
>>> show(six_eight_measure)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-c0edb6ffb12fe0ee5fb467e0bfefecdd.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent As another example, consider the following rhythm:

\begin{comment}
<abjad>
parseable = "abj: | 2/4 c'2 ~ |"
parseable += "| 4/4 c'32 d'2.. ~ d'16 e'32 ~ |"
parseable += "| 2/4 e'2 |"
staff = Staff(parseable)
show(staff)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> parseable = "abj: | 2/4 c'2 ~ |"
>>> parseable += "| 4/4 c'32 d'2.. ~ d'16 e'32 ~ |"
>>> parseable += "| 2/4 e'2 |"
>>> staff = Staff(parseable)
>>> show(staff)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-329490b244b088f012cb5146859cdab0.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent The middle measure is notated in a perfectly valid manner. However,
the double-dotted D does not align with or break against any of the offsets of
a \sfrac[big]{4}{4} metrical structure: \sfrac[big]{0}{4}, \sfrac[big]{1}{4}, \sfrac[big]{2}{4},
\sfrac[big]{3}{4} or \sfrac[big]{4}{4}:

\begin{comment}
<abjad>
four_four_meter = metertools.Meter((4, 4))
graph(four_four_meter)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> four_four_meter = metertools.Meter((4, 4))
>>> graph(four_four_meter)
\end{minted}
\noindent\includegraphics[scale=0.4,max width=\textwidth,]{assets/graphviz-12601707db5ddc467e3296e8c680ba43.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Rewriting the inner measure against a \sfrac[big]{4}{4} meter breaks the
inner logical tie at \sfrac[big]{1}{4} and \sfrac[big]{3}{4}, slightly improving
readability:

\begin{comment}
<abjad>
mutate(staff[1]).rewrite_meter(four_four_meter)
show(staff)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> mutate(staff[1]).rewrite_meter(four_four_meter)
>>> show(staff)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-52ed3c73b623b7b0d9a2c6230084a264.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Rewriting the same measure against a \sfrac[big]{2}{2} meter breaks the
inner logical tie at the offset \sfrac[big]{1}{2}, as two double-dotted quarter
notes. While identical to \sfrac[big]{4}{4} in duration, \sfrac[big]{2}{2} strongly
emphasizes this duple division:

\begin{comment}
<abjad>
two_two_meter = metertools.Meter((2, 2))
staff = Staff(parseable)
mutate(staff[1]).rewrite_meter(two_two_meter)
show(staff)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> two_two_meter = metertools.Meter((2, 2))
>>> staff = Staff(parseable)
>>> mutate(staff[1]).rewrite_meter(two_two_meter)
>>> show(staff)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-467c7a453dd4de93da0cc1c7acbe0a87.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\subsection{Dot count} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{ssec:dot-count}

Meter rewriting can control for various qualities of how rhythms are notated.
For example, the maximum number of dots allowed for any notated rhythmic value
can be constrained. Logical ties encountered during the rewriting process whose
individual notes exceed the maximum number of permitted dots will be rewritten,
if a maximum dot count has been specified.

Consider this series of progressively rewritten rhythms, beginning with the
following unrewritten \sfrac[big]{3}{4} measure:

\begin{comment}
<abjad>
measure = Measure((3, 4), "c'32 d'8 e'8 fs'4...")
show(measure)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> measure = Measure((3, 4), "c'32 d'8 e'8 fs'4...")
>>> show(measure)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-8d4bc784b86bdade27d371532ab358a2.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent After meter rewriting, the final F-sharp is still notated as a
triple-dotted quarter-note, valid because its stop offset aligns perfectly with
the containing measure's stop offset:

\begin{comment}
<abjad>
mutate(measure).rewrite_meter((3, 4))
show(measure)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> mutate(measure).rewrite_meter((3, 4))
>>> show(measure)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-d4d52cf91b08080c4067643d24faaf2a.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Capping the maximum number of dots to 2 causes the F-sharp to be
rewritten as a double-dotted eighth-note tied to a quarter-note:

\begin{comment}
<abjad>
measure = Measure((3, 4), "c'32 d'8 e'8 fs'4...")
mutate(measure).rewrite_meter((3, 4), maximum_dot_count=2)
show(measure)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> measure = Measure((3, 4), "c'32 d'8 e'8 fs'4...")
>>> mutate(measure).rewrite_meter((3, 4), maximum_dot_count=2)
>>> show(measure)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-40b68312fd44f949b40de163b21588c3.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Constraining the maximum number of dots to 1 further subdivides the
F-sharp logical tie:

\begin{comment}
<abjad>
measure = Measure((3, 4), "c'32 d'8 e'8 fs'4...")
mutate(measure).rewrite_meter((3, 4), maximum_dot_count=1)
show(measure)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> measure = Measure((3, 4), "c'32 d'8 e'8 fs'4...")
>>> mutate(measure).rewrite_meter((3, 4), maximum_dot_count=1)
>>> show(measure)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-5fba6e827130a27fefae4843d2b21248.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Finally, with no dots permitted at all, the rhythmic presentation of
the measure changes considerably. Every dotted rhythm has been subdivided:

\begin{comment}
<abjad>
measure = Measure((3, 4), "c'32 d'8 e'8 fs'4...")
mutate(measure).rewrite_meter((3, 4), maximum_dot_count=0)
show(measure)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> measure = Measure((3, 4), "c'32 d'8 e'8 fs'4...")
>>> mutate(measure).rewrite_meter((3, 4), maximum_dot_count=0)
>>> show(measure)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-2ca50ee6f27ae56bae476fb9dc1faafa.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Prudent application of dot count constraints can clarify awkward
rhythmic spellings by forcing the appearance of offsets in logical ties
inherent to the rewriting meter.

\subsection{Boundary depth} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{ssec:boundary-depth}

In meter rewriting, \emph{boundary depth} forces emphasis of offsets found at
different \emph{depths} in a meter's rhythm-tree by marking as invalid logical
ties which do not immediately align to those offsets on the very first pass of
the recursive meter rewriting process. Use of boundary depth often clarifies
distinctive groupings in more deeply nested meters, such as the
\enquote{3-ness} inherent to a \sfrac[big]{9}{8} meter. The nodes with a depth of 1
in the following \sfrac[big]{9}{8} meter's rhythm-tree -- the three \sfrac[big]{3}{8}
inner nodes marked by triangles -- outline the offsets \sfrac[big]{0}{8},
\sfrac[big]{3}{8}, \sfrac[big]{6}{8} and \sfrac[big]{9}{8}. When rewriting a \sfrac[big]{9}{8}
rhythm with a boundary depth of 1, any logical ties not aligning with -- either
starting or stopping at -- those offsets would be marked as invalid and
therefore rewritten:

\begin{comment}
<abjad>
nine_eight_meter = metertools.Meter((9, 8))
graph(nine_eight_meter)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> nine_eight_meter = metertools.Meter((9, 8))
>>> graph(nine_eight_meter)
\end{minted}
\noindent\includegraphics[scale=0.4,max width=\textwidth,]{assets/graphviz-18bdc18e7331fb0ae5a23dce68bb4246.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\begin{comment}
<abjad>
measure = Measure((9, 8), "c'2 d'2 e'8")
show(measure)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> measure = Measure((9, 8), "c'2 d'2 e'8")
>>> show(measure)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-f459f8c64dd96ba762e4bdebba6f4680.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\begin{comment}
<abjad>
mutate(measure).rewrite_meter(nine_eight_meter)
show(measure)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> mutate(measure).rewrite_meter(nine_eight_meter)
>>> show(measure)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-63f30ee6e2e244440af9d6f1e0f84a02.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent After rewriting, without any boundary depth specified, the D
half-note in the above \sfrac[big]{9}{8} measure has been split into two
quarter-notes, tied together. The second of these quarter-notes begins at
\sfrac[big]{6}{8}, therefore aligning with the start of the third \sfrac[big]{3}{8} node
at depth 1 in the \sfrac[big]{9}{8} meter's rhythm tree. Likewise, the first half of
the split half-note ends at the same \sfrac[big]{6}{8} offset. However, the initial
C half-note, while aligning with the beginning of the meter and therefore
treated as valid, does not emphasize any of the meter's inner offsets as
outlined by the offsets \sfrac[big]{3}{8} and \sfrac[big]{6}{8}:

\begin{comment}
<abjad>
measure = Measure((9, 8), "c'2 d'2 e'8")
mutate(measure).rewrite_meter(
    nine_eight_meter,
    boundary_depth=1,
    )
show(measure)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> measure = Measure((9, 8), "c'2 d'2 e'8")
>>> mutate(measure).rewrite_meter(
...     nine_eight_meter,
...     boundary_depth=1,
...     )
>>> show(measure)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-93c0260083a9ae2ad25a3c7c064e3024.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent After rewriting with boundary depth set to 1, not only has the D
half-note been split in half, but the initial C half-note has been split at its
\sfrac[big]{3}{8} offset. Because the initial half note aligned at the \sfrac[big]{0}{8}
offset -- as outlined by the root node in the \sfrac[big]{9}{8} meter's rhythm tree
--, but not at the \sfrac[big]{3}{8} offset -- as outlined by the first and second
\sfrac[big]{3}{8}-duration nodes at depth 1 of the same meter's rhythm tree --, it
was marked invalid and therefor split at the first available offset:
\sfrac[big]{3}{8}.

\subsection{Recursive meter rewriting} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{ssec:recursive-meter-rewriting}

Meter rewriting treats the contents of tuplets with non-trivial prolation as
existing within their own metrical scope, isolated from any other meter. The
numerator and denominator of the tuplet's pre-prolated contents duration act as
the numerator and denominator of their \enquote{virtual} meter. Thus, a 6:5
tuplet encountered in any context will be rewritten as though under some
6-numerator meter:

\begin{comment}
<abjad>
parseable = "abj: | 4/4 c'16 ~ c'4 d'8. ~ "
parseable += "2/3 { d'8. ~ 3/5 { d'16 e'8 ~ e'16 f'16 ~ } } "
parseable += "f'4 |"
measure = parse(parseable)
show(measure)
mutate(measure).rewrite_meter(
    measure,
    boundary_depth=1,
    )
show(measure)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> parseable = "abj: | 4/4 c'16 ~ c'4 d'8. ~ "
>>> parseable += "2/3 { d'8. ~ 3/5 { d'16 e'8 ~ e'16 f'16 ~ } } "
>>> parseable += "f'4 |"
>>> measure = parse(parseable)
>>> show(measure)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-270f471c0052391c9bf1a5df2ccc4474.pdf}
\begin{minted}{pycon}
>>> mutate(measure).rewrite_meter(
...     measure,
...     boundary_depth=1,
...     )
>>> show(measure)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-f9d044a4106c8869b71b8035d108035f.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent If, while rewriting the contents of one tuplet, a second tuplet is
encountered as a child of that first tuplet, the meter rewriting algorithm will
recursively descend into that second tuplet -- and any further tuplet children
at any depth. This recursive descent allows any encountered component to be
rewritten in a relevant metrical context.

\subsection{Examples}
\label{ssec:meter-rewriting-examples}

Meter rewriting can clarify structural differences between meters with
identical durations, such as \sfrac[big]{3}{4} and \sfrac[big]{6}{8}, or between various
possible representations of other prime-numerator meters like \sfrac[big]{5}{4},
\sfrac[big]{7}{8} and so forth. The following series of \sfrac[big]{3}{4} measures
contain rhythms which emphasize \sfrac[big]{3}{4}-ness or \sfrac[big]{6}{8}-ness to
different degrees. While perfectly valid and totally legible, they can still be
rewritten to more strongly express one meter over the other:

\begin{comment}
<abjad>
staff = Staff(context_name='RhythmicStaff')
staff.extend("{ c'2 c'4 } { c'4. c'4. } { c'2 ~ c'8 c'8 }")
attach(TimeSignature((3, 4)), staff)
show(staff)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> staff = Staff(context_name='RhythmicStaff')
>>> staff.extend("{ c'2 c'4 } { c'4. c'4. } { c'2 ~ c'8 c'8 }")
>>> attach(TimeSignature((3, 4)), staff)
>>> show(staff)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-b4a2116ab0031b6068b1112932629bac.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Rewriting under a \sfrac[big]{3}{4} meter with a boundary depth of 1
forces emphasis of the offsets found in the \sfrac[big]{3}{4} meter's depth-1 group
of three quarter-duration nodes: \sfrac[big]{0}{4}, \sfrac[big]{1}{4}, \sfrac[big]{2}{4} and
\sfrac[big]{3}{4}. Both the outer measures' contents align to these offsets, but the
inner measure's hemiola contents do not, and are rewritten:

\begin{comment}
<abjad>
for container in staff:
    mutate(container).rewrite_meter((3, 4), boundary_depth=1)

show(staff)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> for container in staff:
...     mutate(container).rewrite_meter((3, 4), boundary_depth=1)
...
>>> show(staff)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-0cef77f45f31e31ad271d15c9c32edf8.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Conversely, rewriting with a \sfrac[big]{6}{8} meter -- again with a
boundary depth of 1 -- forces emphasis of the offsets outlined by
\sfrac[big]{6}{8}'s two depth-1 \sfrac[big]{3}{8}-duration nodes: \sfrac[big]{0}{8},
\sfrac[big]{3}{8} and \sfrac[big]{6}{8}. Only the inner measure's contents align
perfectly these offsets, so the outer measures are rewritten, better
demonstrating \sfrac[big]{6}{8}'s duple-ness:

\begin{comment}
<abjad>
staff = Staff(context_name='RhythmicStaff')
staff.extend("{ c'2 c'4 } { c'4. c'4. } { c'2 ~ c'8 c'8 }")
attach(TimeSignature((6, 8)), staff)
for container in staff:
    mutate(container).rewrite_meter((6, 8), boundary_depth=1)

show(staff)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> staff = Staff(context_name='RhythmicStaff')
>>> staff.extend("{ c'2 c'4 } { c'4. c'4. } { c'2 ~ c'8 c'8 }")
>>> attach(TimeSignature((6, 8)), staff)
>>> for container in staff:
...     mutate(container).rewrite_meter((6, 8), boundary_depth=1)
...
>>> show(staff)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-58a85c4734fd2a15643aa2409cbff0e5.pdf}
\end{singlespacing}
\end{abjadbookoutput}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Finding meters}
\label{sec:finding-meters}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Not only can meters be used to alter rhythmic structures, they can also be
derived from them. A meter's weighted-offset pattern can be used as
one-dimensional kernel, or convolution matrix, to determine how strongly an
arbitrary collection of offsets appears to express that meter. Given a
collection of meters to choose from, each meter can be matched against those
offsets and the meter most closely aligning selected as the winner. This
process is called \emph{meter fitting}.

\subsection{Offset counters} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{ssec:offset-counters}

Before convolving a meter with a collection of offsets, those offsets need to
be extracted and counted. Abjad's \texttt{metertools} provides an
\texttt{OffsetCounter} class which maps offsets against counts. Offset counters
can be instantiated from any expression containing offsets or whose elements
can be expressed as timespans and therefore possess both start and stop
offsets. Offsets which appear multiple times in the input expression will
result in a higher count in the offset counter, and will in turn have a greater
influence during meter fitting.

Consider the following score example:

\begin{comment}
<abjad>
upper_staff = Staff("c'8 d'4. e'8 f'4.")
lower_staff = Staff(r'\clef bass c4 b,4 a,2')
piano_staff = scoretools.StaffGroup(
    [upper_staff, lower_staff],
    context_name='PianoStaff',
    )
show(piano_staff)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> upper_staff = Staff("c'8 d'4. e'8 f'4.")
>>> lower_staff = Staff(r'\clef bass c4 b,4 a,2')
>>> piano_staff = scoretools.StaffGroup(
...     [upper_staff, lower_staff],
...     context_name='PianoStaff',
...     )
>>> show(piano_staff)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-bf3a249e2b4eac93b1884bab1a122a10.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent The start and stop offsets of all of the leaves of this score can be
counted by selecting the score's leaves and instantiating an offset counter
from them. Because all score components can be expressed as timespans via
\texttt{inspect\_(some\_component).get\_timespan()} the offset counter can
retrieve both their start and stop offsets within the score:

\begin{comment}
<abjad>
leaves = piano_staff.select_leaves(allow_discontiguous_leaves=True)
piano_staff_counter = metertools.OffsetCounter(leaves)
print(format(piano_staff_counter))
show(piano_staff_counter)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> leaves = piano_staff.select_leaves(allow_discontiguous_leaves=True)
>>> piano_staff_counter = metertools.OffsetCounter(leaves)
>>> print(format(piano_staff_counter))
metertools.OffsetCounter(
    {
        durationtools.Offset(0, 1): 2,
        durationtools.Offset(1, 8): 2,
        durationtools.Offset(1, 4): 2,
        durationtools.Offset(1, 2): 4,
        durationtools.Offset(5, 8): 2,
        durationtools.Offset(1, 1): 2,
        }
    )
\end{minted}
\begin{minted}{pycon}
>>> show(piano_staff_counter)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-b2c45afc4a29ecdf622c76195f1251ae.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Note that the offset \sfrac[big]{1}{2} shows a count of 4. This is because
\sfrac[big]{1}{2} acts as both the start or stop offset for four separate leaves in
the score.

Offset counters can also be generated from timespan inventories, allowing meter
convolution to be used without reference to any score objects at all:

\begin{comment}
<abjad>
timespans = timespantools.TimespanInventory([
    timespantools.Timespan(-1, 10),
    timespantools.Timespan(5, 15),
    timespantools.Timespan(15, 20),
    timespantools.Timespan(10, 15),
    ])
timespan_counter = metertools.OffsetCounter(timespans)
show(timespan_counter)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> timespans = timespantools.TimespanInventory([
...     timespantools.Timespan(-1, 10),
...     timespantools.Timespan(5, 15),
...     timespantools.Timespan(15, 20),
...     timespantools.Timespan(10, 15),
...     ])
>>> timespan_counter = metertools.OffsetCounter(timespans)
>>> show(timespan_counter)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-92e87e63b34df27878f535ac2f8e07ac.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\subsection{Metric accent kernels} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{ssec:metric-accent-kernels}

As demonstrated earlier, Abjad's model of meter describes a sequence of offsets
with varying degrees of weight -- accentedness -- attributed to each offset, as
determined by the hierarchical tree structure of that meter. This model allows
us to explain how downbeats have a stronger weight than upbeats, and how the
\sfrac[big]{3}{8} offset in a \sfrac[big]{6}{8} measure is less strong than its downbeat
but still stronger than the offsets at \sfrac[big]{1}{8}, \sfrac[big]{2}{8}, \sfrac[big]{4}{8}
or \sfrac[big]{5}{8}. However, the default model of a \sfrac[big]{6}{8} meter makes no
explicit reference to offsets such as \sfrac[big]{1}{16} or \sfrac[big]{3}{16}. A common
practice understanding of meter tells us that these offsets should be taken as
less accented than those at \sfrac[big]{1}{8}, \sfrac[big]{2}{8}, \sfrac[big]{3}{8} and so
forth. They effectively represent an even lower level of leaves on the
rhythm-tree for \sfrac[big]{6}{8}. Likewise, offsets with a denominator of 32 or 64
should be explainable in an identical fashion.

Abjad's \texttt{MetricAccentKernel} class provides an object model for both the
act of progressively subdividing the weighted offsets of a meter down to some
arbitrary denominator, and for the process of convolving those offsets as a
one-dimensional convolution kernel against an offset counter. Metric accent
kernels allow meters to be fitted against offset counters containing offsets
not explicitly modeled by the rhythm-trees of those same meters.

Here a metric accent kernel is generated from a \sfrac[big]{4}{4} meter, extending
its denominator to a \emph{limit} of \sfrac[big]{1}{16}. The weights at each offset
are normalized such that they sum to 1. Normalization prevents very long meters
from having undue influence during meter fitting:

\begin{comment}
<abjad>
meter = metertools.Meter((4, 4))
kernel_44 = metertools.MetricAccentKernel.from_meter(meter, denominator=16)
for offset, weight in sorted(kernel_44.kernel.items()):
    print('{!s}\t{!s}'.format(offset, weight))

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> meter = metertools.Meter((4, 4))
>>> kernel_44 = metertools.MetricAccentKernel.from_meter(meter, denominator=16)
>>> for offset, weight in sorted(kernel_44.kernel.items()):
...     print('{!s}\t{!s}'.format(offset, weight))
...
0	4/33
1/16	1/33
1/8	2/33
3/16	1/33
1/4	1/11
5/16	1/33
3/8	2/33
7/16	1/33
1/2	1/11
9/16	1/33
5/8	2/33
11/16	1/33
3/4	1/11
13/16	1/33
7/8	2/33
15/16	1/33
1	4/33
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent The \sfrac[big]{4}{4} metric accent kernel can be called against an offset
counter -- as though it were a function -- to generate the convolution
response. The count at each offset in the input offset counter is multiplied
against the weight at the corresponding offset in the metric accent kernel. If
no corresponding offset exists in the kernel, the weight is taken as 0. The
weighted counts are then added together and returned:

\begin{comment}
<abjad>
response = kernel_44(piano_staff_counter)
float(response)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> response = kernel_44(piano_staff_counter)
>>> float(response)
0.5454545454545454
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent The following loop demonstrates the logic underlying the above meter
convolution process example:

\begin{comment}
<abjad>
total = Multiplier(0, 1)
for offset, count in sorted(piano_staff_counter.items()):
    weight = Multiplier(0, 1)
    if offset in kernel_44.kernel:
        weight = kernel_44.kernel[offset]
    weighted_count = weight * count
    total += weighted_count
    message = '{!s}:\tcount: {}, weight: {!s}, multiplied: {!s}, total: {!s}'
    message = message.format(offset, count, weight, weighted_count, total)
    print(message)

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> total = Multiplier(0, 1)
>>> for offset, count in sorted(piano_staff_counter.items()):
...     weight = Multiplier(0, 1)
...     if offset in kernel_44.kernel:
...         weight = kernel_44.kernel[offset]
...     weighted_count = weight * count
...     total += weighted_count
...     message = '{!s}:\tcount: {}, weight: {!s}, multiplied: {!s}, total: {!s}'
...     message = message.format(offset, count, weight, weighted_count, total)
...     print(message)
...
0:	count: 2, weight: 4/33, multiplied: 8/33, total: 8/33
1/8:	count: 2, weight: 2/33, multiplied: 4/33, total: 4/11
1/4:	count: 2, weight: 1/11, multiplied: 2/11, total: 6/11
1/2:	count: 4, weight: 1/11, multiplied: 4/11, total: 10/11
5/8:	count: 2, weight: 2/33, multiplied: 4/33, total: 34/33
1:	count: 2, weight: 4/33, multiplied: 8/33, total: 14/11
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Now consider the metric accent kernels for \sfrac[big]{3}{4}, \sfrac[big]{7}{8}
and \sfrac[big]{5}{4} meters:

\begin{comment}
<abjad>
kernel_34 = metertools.MetricAccentKernel.from_meter((3, 4), denominator=16)
kernel_78 = metertools.MetricAccentKernel.from_meter((7, 8), denominator=16)
kernel_54 = metertools.MetricAccentKernel.from_meter((5, 4), denominator=16)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> kernel_34 = metertools.MetricAccentKernel.from_meter((3, 4), denominator=16)
>>> kernel_78 = metertools.MetricAccentKernel.from_meter((7, 8), denominator=16)
>>> kernel_54 = metertools.MetricAccentKernel.from_meter((5, 4), denominator=16)
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent A convolution response can be generated for each of these kernels
against the piano staff offset counter:

\begin{comment}
<abjad>
float(kernel_34(piano_staff_counter))
float(kernel_78(piano_staff_counter))
float(kernel_54(piano_staff_counter))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> float(kernel_34(piano_staff_counter))
0.5384615384615384
\end{minted}
\begin{minted}{pycon}
>>> float(kernel_78(piano_staff_counter))
0.4482758620689655
\end{minted}
\begin{minted}{pycon}
>>> float(kernel_54(piano_staff_counter))
0.4186046511627907
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Note that the previously recorded response for a 4/4 meter is still
higher than any of these three responses.

\subsection{Meter fitting} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{ssec:meter-fitting}

Meter fitting involves the progressive comparison of a collection of permitted
meters against the offsets and counts in an offset counter. Starting from the
lowest offset, the metric accent kernel for each meter is convolved with all
those offsets in the offset counter with which it overlaps. The response from
each convolution is recorded and the meter with the highest associated response
is selected to represent those offsets. The process repeats, starting at the
right-most offset of the last meter selected, until no more offsets remain to
compare against.

Consider the following offsets, which are separated from one another by the
duration of a whole note, outlining the start and stop offsets of a series of
\sfrac[big]{4}{4} meters:

\begin{comment}
<abjad>
offset_counter = metertools.OffsetCounter([
    (0, 4), (4, 4), (8, 4), (12, 4), (16, 4),
    ])
show(offset_counter, range_=(0, 5))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> offset_counter = metertools.OffsetCounter([
...     (0, 4), (4, 4), (8, 4), (12, 4), (16, 4),
...     ])
>>> show(offset_counter, range_=(0, 5))
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-c74006582b28efb1d61d9a6f219c91c8.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Given the following collection of meters, after meter fitting is
performed only \sfrac[big]{4}{4} meters should be selected as they perfectly align
with the previously defined collection of offsets:

\begin{comment}
<abjad>
permitted_meters = metertools.MeterInventory([(3, 4), (4, 4), (5, 4)])
show(permitted_meters, range_=(0, 5))
fitted_meters = metertools.Meter.fit_meters_to_expr(
    expr=offset_counter,
    meters=permitted_meters,
    )
show(fitted_meters, range_=(0, 5))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> permitted_meters = metertools.MeterInventory([(3, 4), (4, 4), (5, 4)])
>>> show(permitted_meters, range_=(0, 5))
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-903f91432f62df75348b48cdb9d7be3d.pdf}
\begin{minted}{pycon}
>>> fitted_meters = metertools.Meter.fit_meters_to_expr(
...     expr=offset_counter,
...     meters=permitted_meters,
...     )
>>> show(fitted_meters, range_=(0, 5))
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-96511fa6cd9448347d5f584042ff653c.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent If we change the input offsets to no longer outline only \sfrac[big]{4}{4}
meters, the meter fitting process will arrive at a different solution. Note how
the following fitted meters emphasize the \sfrac[big]{3}{4} and \sfrac[big]{5}{4}
durations inherent to the new input offsets. The initial \sfrac[big]{3}{4} fitted
meter perfectly matches the offsets \sfrac[big]{0}{1} and \sfrac[big]{3}{4}, while the
\sfrac[big]{4}{4} meter after it matches the \sfrac[big]{5}{4} offset against its third
beat. The next meter's end-beat offset aligns against the offset counter's
\sfrac[big]{5}{2} offset allowing the meter fitting process to perfectly match the
remaining offsets against a pair of \sfrac[big]{5}{4} meters:

\begin{comment}
<abjad>
offset_counter = metertools.OffsetCounter([
    (0, 4), (3, 4), (5, 4), (10, 4), (15, 4), (20, 4),
    ])
fitted_meters = metertools.Meter.fit_meters_to_expr(
    expr=offset_counter,
    meters=permitted_meters,
    )
show(offset_counter, range_=(0, 5))
show(fitted_meters, range_=(0, 5))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> offset_counter = metertools.OffsetCounter([
...     (0, 4), (3, 4), (5, 4), (10, 4), (15, 4), (20, 4),
...     ])
>>> fitted_meters = metertools.Meter.fit_meters_to_expr(
...     expr=offset_counter,
...     meters=permitted_meters,
...     )
>>> show(offset_counter, range_=(0, 5))
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-51cf25a6929362a969d24f3932cb3e52.pdf}
\begin{minted}{pycon}
>>> show(fitted_meters, range_=(0, 5))
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-5f06675a8d3349cae1b5fb107c86bb48.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Meter fitting can also control for how many times meters are
permitted to immediately repeat. The above example ends with two \sfrac[big]{5}{4}
meters in a row. If desired, this repetition can be prevented entirely by the
\texttt{maximum\_run\_length} keyword to
\texttt{Meter.fit\_meters\_to\_expr()}. With \texttt{maximum\_run\_length} set
to 1, the meter fitting process can no longer select two \sfrac[big]{5}{4} meters
for the end of the fitted meter sequence. Instead, a pair of \sfrac[big]{3}{4} and
\sfrac[big]{4}{4} meters replace the previously final \sfrac[big]{5}{4} meter:

\begin{comment}
<abjad>
fitted_meters = metertools.Meter.fit_meters_to_expr(
    expr=offset_counter,
    meters=permitted_meters,
    maximum_run_length=1,
    )
show(fitted_meters, range_=(0, 5))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> fitted_meters = metertools.Meter.fit_meters_to_expr(
...     expr=offset_counter,
...     meters=permitted_meters,
...     maximum_run_length=1,
...     )
>>> show(fitted_meters, range_=(0, 5))
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-2e3a1aefb733123cb0dd4a38b692380f.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\subsection{Examples}
\label{ssec:meter-fitting-examples}

The output of timespan-makers motivates meter fitting more forcefully than the
above trivial examples. Densely layered timespan textures often involve
hundreds or even thousands of offsets with many points of simultaneity or
overlap. Careful management of meter fitting can result in convincing metrical
solutions to such textures.

Recall the quartet timespan texture from earlier in this chapter:

\begin{comment}
<abjad>
music_specifiers = collections.OrderedDict([
    ('Voice 1', None),
    ('Voice 2', None),
    ('Voice 3', None),
    ('Voice 4', None),
    ])
target_timespan = timespantools.Timespan(0, (19, 4))
timespan_inventory = talea_timespan_maker(
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
show(timespan_inventory, key='voice_name')
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> music_specifiers = collections.OrderedDict([
...     ('Voice 1', None),
...     ('Voice 2', None),
...     ('Voice 3', None),
...     ('Voice 4', None),
...     ])
>>> target_timespan = timespantools.Timespan(0, (19, 4))
>>> timespan_inventory = talea_timespan_maker(
...     music_specifiers=music_specifiers,
...     target_timespan=target_timespan,
...     )
>>> show(timespan_inventory, key='voice_name')
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-c8add88d2445d1747bd8b6e8fad82e97.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Constructing an offset counter from this timespan inventory shows
several offsets with strong simultaneities, notably at \sfrac[big]{11}{8},
\sfrac[big]{13}{8}, \sfrac[big]{17}{8} and \sfrac[big]{25}{8}:

\begin{comment}
<abjad>
offset_counter = metertools.OffsetCounter(timespan_inventory)
show(offset_counter, range_=(0, (19, 4)))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> offset_counter = metertools.OffsetCounter(timespan_inventory)
>>> show(offset_counter, range_=(0, (19, 4)))
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-0be2900a4872bf90fe9bfb22c1e66b72.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent As before, a collection of permitted meters are fit against the
offset counter. Compare the weights in the counter to the meter sequence below
it. Offsets in the counter with weights greater than 1 tend to have been fitted
against strong beats in each meter. The initial \sfrac[big]{6}{8} meter receive a
2-count accent on its half-way \sfrac[big]{3}{8} offset. The second \sfrac[big]{6}{8}
meter is matches strong accents on both its downbeat, its half-beat and on its
end-beat. Likewise, the \sfrac[big]{7}{8} meter matches strong accents on its
down-beat and end-beat, as well as its inner 2-count groupings:

\begin{comment}
<abjad>
permitted_meters = metertools.MeterInventory([
    (5, 8), (3, 4), (6, 8), (7, 8), (4, 4),
    ])
fitted_meters = metertools.Meter.fit_meters_to_expr(
    expr=offset_counter,
    meters=permitted_meters,
    maximum_run_length=1,
    )
show(offset_counter, range_=(0, (19, 4)))
show(fitted_meters, range_=(0, (19, 4)))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> permitted_meters = metertools.MeterInventory([
...     (5, 8), (3, 4), (6, 8), (7, 8), (4, 4),
...     ])
>>> fitted_meters = metertools.Meter.fit_meters_to_expr(
...     expr=offset_counter,
...     meters=permitted_meters,
...     maximum_run_length=1,
...     )
>>> show(offset_counter, range_=(0, (19, 4)))
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-0be2900a4872bf90fe9bfb22c1e66b72.pdf}
\begin{minted}{pycon}
>>> show(fitted_meters, range_=(0, (19, 4)))
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-a67d2be37f9d9ec06d5edda3e3e7f244.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Removing the \sfrac[big]{5}{8} meter from the permitted meters inventory
gives less convincing results. Notably, the strong simultaneities at offsets
\sfrac[big]{11}{8} and \sfrac[big]{17}{8} no longer align with any downbeats in the
fitted meters:

\begin{comment}
<abjad>
permitted_meters = metertools.MeterInventory([
    (3, 4), (6, 8), (7, 8), (4, 4),
    ])
fitted_meters = metertools.Meter.fit_meters_to_expr(
    expr=offset_counter,
    maximum_run_length=1,
    meters=permitted_meters,
    )
show(offset_counter, range_=(0, (19, 4)))
show(fitted_meters, range_=(0, (19, 4)))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> permitted_meters = metertools.MeterInventory([
...     (3, 4), (6, 8), (7, 8), (4, 4),
...     ])
>>> fitted_meters = metertools.Meter.fit_meters_to_expr(
...     expr=offset_counter,
...     maximum_run_length=1,
...     meters=permitted_meters,
...     )
>>> show(offset_counter, range_=(0, (19, 4)))
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-0be2900a4872bf90fe9bfb22c1e66b72.pdf}
\begin{minted}{pycon}
>>> show(fitted_meters, range_=(0, (19, 4)))
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-9a5158818ad5fbad7bdb5f19fd966315.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Lifting the constraint on meter repetition does not improve the
results. Both the \sfrac[big]{11}{8} and \sfrac[big]{17}{8} offsets still align with weak
beats in the fitted meters. The only real change is the swapping of
\sfrac[big]{6}{8} and \sfrac[big]{3}{4} meters in the first and last pairs of fitted
meters:

\begin{comment}
<abjad>
fitted_meters = metertools.Meter.fit_meters_to_expr(
    expr=offset_counter,
    meters=permitted_meters,
    )
show(offset_counter, range_=(0, (19, 4)))
show(fitted_meters, range_=(0, (19, 4)))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> fitted_meters = metertools.Meter.fit_meters_to_expr(
...     expr=offset_counter,
...     meters=permitted_meters,
...     )
>>> show(offset_counter, range_=(0, (19, 4)))
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-0be2900a4872bf90fe9bfb22c1e66b72.pdf}
\begin{minted}{pycon}
>>> show(fitted_meters, range_=(0, (19, 4)))
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-4dea6222540afc3cf0b84d79ca2bc728.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent However, reinstating the repetition constraint and permitting a
greater variety of meters gives an even closer fitting than the very first
example. Not only do the \sfrac[big]{11}{8} and \sfrac[big]{17}{8} offsets align at
downbeats, but the three-weight offset at \sfrac[big]{25}{8} matches the downbeat of
a \sfrac[big]{3}{4} meter with two-weight accents on both its second and third beat
as well as the following downbeat:

\begin{comment}
<abjad>
permitted_meters = metertools.MeterInventory([
    (2, 4), (4, 8), (3, 4), (6, 8), (7, 8), (4, 4),
    ])
fitted_meters = metertools.Meter.fit_meters_to_expr(
    expr=offset_counter,
    maximum_run_length=1,
    meters=permitted_meters,
    )
show(offset_counter, range_=(0, (19, 4)))
show(fitted_meters, range_=(0, (19, 4)))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> permitted_meters = metertools.MeterInventory([
...     (2, 4), (4, 8), (3, 4), (6, 8), (7, 8), (4, 4),
...     ])
>>> fitted_meters = metertools.Meter.fit_meters_to_expr(
...     expr=offset_counter,
...     maximum_run_length=1,
...     meters=permitted_meters,
...     )
>>> show(offset_counter, range_=(0, (19, 4)))
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-0be2900a4872bf90fe9bfb22c1e66b72.pdf}
\begin{minted}{pycon}
>>> show(fitted_meters, range_=(0, (19, 4)))
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-a1f558ce38e84f316c17684a30bd0fac.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Increasing the number of permitted offsets even further does not
necessarily improve results further. A better initial meter fitting -- like the
initial \sfrac[big]{9}{8} here -- often diminishes the choices possible afterward:

\begin{comment}
<abjad>
permitted_meters = metertools.MeterInventory([
    (2, 4), (3, 16), (3, 4), (4, 4), (4, 8), (5, 16),
    (5, 4), (5, 8), (6, 8), (7, 8), (9, 8),
    ])
poorly_fitted_meters = metertools.Meter.fit_meters_to_expr(
    expr=offset_counter,
    maximum_run_length=1,
    meters=permitted_meters,
    )
show(offset_counter, range_=(0, (19, 4)))
show(poorly_fitted_meters, range_=(0, (19, 4)))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> permitted_meters = metertools.MeterInventory([
...     (2, 4), (3, 16), (3, 4), (4, 4), (4, 8), (5, 16),
...     (5, 4), (5, 8), (6, 8), (7, 8), (9, 8),
...     ])
>>> poorly_fitted_meters = metertools.Meter.fit_meters_to_expr(
...     expr=offset_counter,
...     maximum_run_length=1,
...     meters=permitted_meters,
...     )
>>> show(offset_counter, range_=(0, (19, 4)))
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-0be2900a4872bf90fe9bfb22c1e66b72.pdf}
\begin{minted}{pycon}
>>> show(poorly_fitted_meters, range_=(0, (19, 4)))
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-0750946d1cd0bfe69efd61bdaf0de800.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent The process of meter fitting described here is not perfect. While
useful for creating generally convincing metrical solutions to dense timespan
structures, meter fitting could probably be better solved through human
intervention. The fitting process often over-emphasizes local attack point
maxima while ignoring larger or more elegant metrical patterns. Likewise, the
process often provides an accurate fitting for the very first meter, but causes
a cascade of poor solutions for every following meter. Where procedural meter
fitting wins over human intervention is in speed. Solutions to enormous
timespan inventories with hundreds or thousands of timespans can be found in
less than a second, facilitating the rapid sketching and revising of
timespan-based musical structures.

Meter fitting can be considered as a kind of constraint problem. The set of
permitted meters act as a search space while each progressive selection of
offsets from the input offset counter act as the problem to solve against. In
that light, improvements might involve searching for meter solutions with
increased \emph{lookahead} -- that is, fitting the current meter based not only
on its response to a selection of offsets, but also on how well any meter
following it would score. Searching the offset counter for patterns, changing
the weighting algorithm of metric accent kernels, or jumping directly to the
attack point maxima in the input offset counter and solving forwards and
backwards from them are also possible avenues for improvement.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Synthesizing time techniques}
\label{sec:synthesizing-time-techniques}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The techniques outlined in this chapter -- timespan inventories,
timespan-makers, rhythm-makers, meter fitting and rewriting -- describe various
ways of modeling, creating and manipulating aspects of musical score. Taken
separately, none of them can ever result in the rhythmic framework for a
polyphonic piece of music. However, by combining all of them together, it is
possible to construct powerful tools for generating arbitrarily large amounts
of notation. The following \texttt{build\_score()} function sketches one
possible approach to combining these techniques:

\begin{comment}
<abjadextract dissertation.py.time_tools:build_score />[strip_prompt]
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
def build_score(
    performed_rhythm_maker,
    permitted_meters,
    score_template,
    timespan_inventory,
    ):
    fitted_meters, meter_boundaries = get_meters_and_meter_boundaries(
        timespan_inventory, permitted_meters)
    all_voicewise_timespans = get_all_voicewise_timespans(timespan_inventory)
    seed = 0
    score = score_template()
    for voice in iterate(score).by_class(Voice):
        if voice.name not in all_voicewise_timespans:
            all_voicewise_timespans[voice.name] = \
                timespantools.TimespanInventory()
        voice_timespans = all_voicewise_timespans[voice.name]
        previous_stop_offset = Offset(0)
        for shard in voice_timespans.partition(include_tangent_timespans=True):
            if shard.start_offset != previous_stop_offset:
                silent_music = make_silent_music(
                    meter_boundaries=meter_boundaries,
                    start_offset=previous_stop_offset,
                    stop_offset=shard.start_offset,
                    )
                voice.append(silent_music)
            performed_music = make_performed_music(
                meter_boundaries=meter_boundaries,
                rhythm_maker=performed_rhythm_maker,
                seed=seed,
                timespans=shard,
                )
            voice.append(performed_music)
            seed += 1
            previous_stop_offset = shard.stop_offset
        if previous_stop_offset != meter_boundaries[-1]:
            silent_music = make_silent_music(
                meter_boundaries=meter_boundaries,
                start_offset=previous_stop_offset,
                stop_offset=meter_boundaries[-1],
                )
            voice.append(silent_music)
        for phrase in voice:
            rewrite_meters(phrase, fitted_meters, meter_boundaries)
    add_time_signature_context(score, fitted_meters)
    return score
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent \texttt{build\_score()} creates a score from a rhythm-maker, a
sequence of permitted meters, a score template and a timespan inventory. The
timespan inventory must contain performed timespans whose voice names align
with the voice names in the score produced by the score template. For example,
Abjad's \texttt{GroupedRhythmicStavesScoreTemplate} class can produce scores
containing voices with names like \enquote{Voice 1}, \enquote{Voice 2} and so
forth. The timespan inventory used for this example -- created earlier in this
chapter -- contains performed timespans with the voice names \enquote{Voice 1},
\enquote{Voice 2}, \enquote{Voice 3} and \enquote{Voice 4}, requiring a score
template capable of creating scores with four staves of one voice each:

\begin{comment}
<abjad>
show(timespan_inventory, key='voice_name')
score_template = templatetools.GroupedRhythmicStavesScoreTemplate(
    staff_count=4, with_clefs=True,
    )
score = score_template()
print(format(score))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> show(timespan_inventory, key='voice_name')
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-c8add88d2445d1747bd8b6e8fad82e97.pdf}
\begin{minted}{pycon}
>>> score_template = templatetools.GroupedRhythmicStavesScoreTemplate(
...     staff_count=4, with_clefs=True,
...     )
>>> score = score_template()
>>> print(format(score))
\context Score = "Grouped Rhythmic Staves Score" <<
    \context StaffGroup = "Grouped Rhythmic Staves Staff Group" <<
        \context RhythmicStaff = "Staff 1" {
            \clef "percussion"
            \context Voice = "Voice 1" {
            }
        }
        \context RhythmicStaff = "Staff 2" {
            \clef "percussion"
            \context Voice = "Voice 2" {
            }
        }
        \context RhythmicStaff = "Staff 3" {
            \clef "percussion"
            \context Voice = "Voice 3" {
            }
        }
        \context RhythmicStaff = "Staff 4" {
            \clef "percussion"
            \context Voice = "Voice 4" {
            }
        }
    >>
>>
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Score building proceeds by first fitting the permitted meters against
the timespan inventory and calculating their \emph{meter boundaries} -- the
offsets of each downbeat, as well as the virtual downbeat, the
\enquote{end-beat}, after the final meter. Then the timespans in the input
timespan inventory are separated into new timespan inventories according to
their associated voice names, with these new inventories stored in a dictionary
whose keys are those same voice names. With the timespan and metrical
structures organized, the \texttt{build\_score()} produces an unpopulated score
from its score template. For each voice in this score, an inventory of
timespans is retrieved from the \texttt{all\_voicewise\_timespans} dictionary.
If no inventory exists, an empty one is created. The associated performed
timespans are partitioned into contiguous groups in order to facilitate rhythm
generation. Each partitioned group is passed, along with the input
rhythm-maker, the fitted meter boundaries, and a seed value -- the number of
performed timespan groups encountered so far -- to a rhythm generation
subroutine, with the resulting phrase container appended into the current
voice. If a gap is encountered between two partitioned groups, between the
beginning of the first partitioned group and the beginning of the score -- the
offset 0, or between the end of the last partitioned group and the final meter
boundary, "silent music" will be created in the form of rests grouped into a
container, with that container then inserted into the current voice. Once all
voices in the score have been populated, their meters are rewritten, then the
score is formatted and finally returned.

An analysis of each of the functions called within \texttt{build\_score()}
follows.

\subsection{Organizing meter}
\label{ssec:organizing-meter}

Consider the first function called inside \texttt{build\_score()},
\texttt{get\_meters\_and\_meter\_boundaries()}. A meter sequence of equal or
greater duration to the input timespan inventory can be produced through
fitting a collection of permitted meters against that same input timespan
inventory. The sequence of offsets found at the boundaries of each fitted meter
can then be determined by computing the cumulative sums of the durations of the
fitted meters. These boundary offsets will be used to split timespans before
they are fed to rhythm-makers for rhythm generation in order to ensure that no
generated rhythm crosses any bar-lines:

\begin{comment}
<abjadextract dissertation.py.time_tools:get_meters_and_meter_boundaries />[strip_prompt]
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
def get_meters_and_meter_boundaries(timespan_inventory, permitted_meters):
    offset_counter = metertools.OffsetCounter(timespan_inventory)
    fitted_meters = metertools.Meter.fit_meters_to_expr(
        expr=offset_counter,
        maximum_run_length=1,
        meters=permitted_meters,
        )
    meter_durations = [Duration(_) for _ in fitted_meters]
    meter_boundaries = mathtools.cumulative_sums(
        meter_durations,
        start=Offset(0),
        )
    return fitted_meters, meter_boundaries
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\subsection{Organizing timespans}
\label{ssec:organizing-timespans}

Each of the performed timespans in the input timespan inventory was configured
with a voice name, allowing that timespan to be associated with a voice context
in the score hierarchy produced by the input score template. As demonstrated
earlier, Abjad components can be indexed by context name regardless of the
depth of the named context in the score hierarchy:

\begin{comment}
<abjad>
timespan = timespan_inventory[0]
print(format(timespan))
score = score_template()
voice = score[timespan.voice_name]
for component in inspect_(voice).get_parentage():
    component

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> timespan = timespan_inventory[0]
>>> print(format(timespan))
consort.tools.PerformedTimespan(
    start_offset=durationtools.Offset(0, 1),
    stop_offset=durationtools.Offset(1, 4),
    original_start_offset=durationtools.Offset(9, 2),
    original_stop_offset=durationtools.Offset(19, 4),
    voice_name='Voice 3',
    )
\end{minted}
\begin{minted}{pycon}
>>> score = score_template()
>>> voice = score[timespan.voice_name]
>>> for component in inspect_(voice).get_parentage():
...     component
...
Voice()
<RhythmicStaff-"Staff 3"{1}>
<StaffGroup-"Grouped Rhythmic Staves Staff Group"<<4>>>
<Score-"Grouped Rhythmic Staves Score"<<1>>>
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent In order to populate each voice in the score, the timespans in the
timespan inventory need to be separated into \emph{voice-wise} timespan
inventories, each only containing timespans associated with the same voice.
This can be accomplished by building a dictionary whose keys are voice names
and whose values are timespan inventories:

\begin{comment}
<abjadextract dissertation.py.time_tools:get_all_voicewise_timespans />[strip_prompt]
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
def get_all_voicewise_timespans(timespan_inventory):
    voicewise_timespans = {}
    for timespan in timespan_inventory:
        voice_name = timespan.voice_name
        if voice_name not in voicewise_timespans:
            voicewise_timespans[voice_name] = timespantools.TimespanInventory()
        voicewise_timespans[voice_name].append(timespan)
    return voicewise_timespans
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\subsection{Populating voices}
\label{ssec:populating-voices}

Creating \emph{performed} music requires first splitting a contiguous inventory
of performed timespans by meter boundaries, collecting the shards together into
a new inventory and then calculating the durations of those timespans. The
resulting sequence of durations, along with an input rhythm-maker and an
optional seed value can be sent to another function for rhythm generation:

\begin{comment}
<abjadextract dissertation.py.time_tools:make_performed_music />[strip_prompt]
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
def make_performed_music(rhythm_maker, timespans, meter_boundaries, seed=0):
    split_timespans = timespantools.TimespanInventory()
    for shard in timespans.split_at_offsets(meter_boundaries):
        split_timespans.extend(shard)
    durations = [_.duration for _ in split_timespans if _.duration]
    music = make_music(rhythm_maker, durations, seed=seed)
    return music
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Similarly, \emph{silent} music -- rests between groups of performed
timespans in each voice -- can be created by constructing a timespan which
outlines the gap between other performed timespans, splitting that timespan by
meter boundaries, collecting the durations of the split shards, and finally
passing those durations along with a rest-generating rhythm-maker to another
function for rhythm generation. As demonstrated in
\autoref{ssec:note-rhythm-makers}, rest-generating rhythm-makers can be created
from note rhythm-makers which use output masks to silence all output divisions:

\begin{comment}
<abjadextract dissertation.py.time_tools:make_silent_music />[strip_prompt]
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
def make_silent_music(start_offset, stop_offset, meter_boundaries):
    silence_timespan = timespantools.Timespan(start_offset, stop_offset)
    shards = silence_timespan.split_at_offsets(meter_boundaries)
    durations = [_.duration for _ in shards if _.duration]
    mask = rhythmmakertools.silence_all()
    rhythm_maker = rhythmmakertools.NoteRhythmMaker(output_masks=[mask])
    music = make_music(rhythm_maker, durations)
    return music
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Both silent and performed music generation relies on the same core
rhythm generating function, \texttt{make\_music()}. This function calls its
input rhythm-maker with a sequence of durations and an optional seed value,
which may be interpreted variably depending on what kind of rhythm-maker was
used, but which generally results in the rotation of any sequence-like
configured value in that rhythm-maker, such as talea. The product of this first
operation is a sequence of component selections. Some massaging converts this
selections into a sequence of trivially-prolated containers and non-trivially
prolated tuplets which can then be wrapped inside a larger container
representing a complete phrase:

\begin{comment}
<abjadextract dissertation.py.time_tools:make_music />[strip_prompt]
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
def make_music(rhythm_maker, durations, seed=0):
    music = rhythm_maker(durations, rotation=seed)
    for i, division in enumerate(music):
        if len(division) == 1 and isinstance(division[0], scoretools.Tuplet):
            music[i] = division[0]
        else:
            music[i] = scoretools.Container(division)
    music = scoretools.Container(music)
    return music
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\subsection{Rewriting meters}
\label{ssec:rewriting-meters}

After all phrases for a voice have been generated, their meters are rewritten.
This process involves simultaneously iterating through both the divisions in
each phrase along with pairs of meters and meter downbeat offsets -- that is,
the offset from the origin of the score where each meter begins.\footnote{More
optimizations to this joint container / meter iteration are obviously possible.
Some have even been implemented in Consort's source. Such optimization include
associating meters with their own timespans, and storing these meter-timespans
in an optimized interval-tree data structure allowing rapid retrieval by both
offset and timespan intersection. For the sake of pedagogical clarity, a more
naive approach is used here.} Unprolated division containers are rewritten
according to the meter active when they begin. Because a division may start
\emph{after} a meter has begun it is necessary to calculate the difference
between each unprolated division's start offset and each meter's start offset.
This difference is passed to the \texttt{MutationAgent}'s
\texttt{rewrite\_meter()} method via the \texttt{initial\_offset} keyword,
allowing the division to be properly aligned against the desired meter.
Prolated divisions -- tuplets -- are rewritten solely with respect to the
duration of their contents, not to the prevailing meter. That is, a 5:4 tuplet
in a \sfrac[big]{4}{8} measure is rewritten with a meter of \sfrac[big]{5}{8}, not of
\sfrac[big]{4}{8}:

\begin{comment}
<abjadextract dissertation.py.time_tools:rewrite_meters />[strip_prompt]
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
def rewrite_meters(phrase, meters, meter_boundaries):
    pairs = list(zip(meters, meter_boundaries))
    for division in phrase:
        division_offset = inspect_(division).get_timespan().start_offset
        while 1 < len(pairs) and pairs[1][1] <= division_offset:
            pairs.pop(0)
        if isinstance(division, scoretools.Tuplet):
            contents_duration = division._contents_duration
            meter = metertools.Meter(contents_duration)
            mutate(division).rewrite_meter(
                meter,
                boundary_depth=1,
                )
        else:
            meter, meter_boundary = pairs[0]
            initial_offset = division_offset - meter_boundary
            mutate(division).rewrite_meter(
                meter,
                boundary_depth=1,
                initial_offset=initial_offset,
                )
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\subsection{Score post-processing}
\label{ssec:score-post-processing}

\noindent The final step in this score building process adds a
\enquote{floating time signature context} to the score, filled with typographic
spacer skips and time signature commands, one for each of the fitted meters.
This context appears as a row of time signatures floating above the topmost
staff in the score, allowing time signatures to be omitted from every staff in
the score and thereby improving proportional notation spacing. The time
signature context's \texttt{context\_name} property instructs LilyPond to look
for a context definition with that name and apply any typographic overrides
found there during the typesetting process. While LilyPond does not come
packaged with a \texttt{TimeSignatureContext} definition, examples of what such
a definition looks like can be found in the various \texttt{stylesheet}
sections of the source code appendices to this document:

\begin{comment}
<abjadextract dissertation.py.time_tools:add_time_signature_context />[strip_prompt]
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
def add_time_signature_context(score, meters):
    time_signatures = [_.implied_time_signature for _ in meters]
    measures = scoretools.make_spacer_skip_measures(time_signatures)
    time_signature_context = scoretools.Context(
        [measures],
        context_name='TimeSignatureContext',
        name='TimeSignatureContext',
        )
    score.insert(0, time_signature_context)
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\subsection{Examples}
\label{ssec:score-building-examples}

\noindent Calling the \texttt{build\_score()} function generates a score as
described above. In this example, the function's arguments comprise a talea
rhythm-maker, an inventory of meters, as well as the previously defined score
template and timespan inventory:

\begin{comment}
<abjad>
permitted_meters = metertools.MeterInventory([
    (2, 4), (4, 8), (3, 4), (6, 8), (7, 8), (4, 4),
    ])
performed_rhythm_maker = rhythmmakertools.TaleaRhythmMaker(
    beam_specifier=rhythmmakertools.BeamSpecifier(
        beam_each_division=True,
        beam_divisions_together=True,
        ),
    extra_counts_per_division=(0, 1),
    talea=rhythmmakertools.Talea([1, 2, 3, 4, 5], 16),
    )
show(performed_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> permitted_meters = metertools.MeterInventory([
...     (2, 4), (4, 8), (3, 4), (6, 8), (7, 8), (4, 4),
...     ])
>>> performed_rhythm_maker = rhythmmakertools.TaleaRhythmMaker(
...     beam_specifier=rhythmmakertools.BeamSpecifier(
...         beam_each_division=True,
...         beam_divisions_together=True,
...         ),
...     extra_counts_per_division=(0, 1),
...     talea=rhythmmakertools.Talea([1, 2, 3, 4, 5], 16),
...     )
>>> show(performed_rhythm_maker, divisions=divisions)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-12a3ce90ede7ebf565493e80cd2b641b.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent For clarity, the phrases and their internal divisions have been
annotated via Consort's \texttt{annotate} function. This function draws thick
brackets underneath each staff, with the lower bracket indicating the overall
phrase grouping and the inner brackets indicating divisions within each phrase.
Entirely silent phrasing brackets are drawn with dashed rather than solid
lines:

\begin{comment}
<abjad>[stylesheet=../consort-small.ily]
score = build_score(
    performed_rhythm_maker=performed_rhythm_maker,
    permitted_meters=permitted_meters,
    score_template=score_template,
    timespan_inventory=timespan_inventory,
    )
consort.annotate(score)
show(score)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> score = build_score(
...     performed_rhythm_maker=performed_rhythm_maker,
...     permitted_meters=permitted_meters,
...     score_template=score_template,
...     timespan_inventory=timespan_inventory,
...     )
>>> consort.annotate(score)
>>> show(score)
\end{minted}
\noindent\includegraphics[max width=\textwidth,page=1]{assets/lilypond-4cc99eb25ad6bff16e0d80e74536a91c.pdf}
\newline
\newline
\noindent\includegraphics[max width=\textwidth,page=2]{assets/lilypond-4cc99eb25ad6bff16e0d80e74536a91c.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Large-scale variations are possible simply by altering the arguments
to the \texttt{build\_score()} function. For example, the timespan inventory
can be reflected around its axis and stretched from a duration of \sfrac[big]{19}{4}
to \sfrac[big]{25}{4}. This will change the overall duration and phrase density of
the resulting score while maintaining the character of its surface rhythms:

\begin{comment}
<abjad>[stylesheet=../consort-small.ily]
multiplier = Duration(24, 4) / Duration(19, 4)
timespan_inventory = timespan_inventory.reflect()
timespan_inventory = timespan_inventory.stretch(multiplier)
timespan_inventory = timespan_inventory.round_offsets(Duration(1, 8))
show(timespan_inventory, key='voice_name')
score = build_score(
    performed_rhythm_maker=performed_rhythm_maker,
    permitted_meters=permitted_meters,
    score_template=score_template,
    timespan_inventory=timespan_inventory,
    )
consort.annotate(score)
show(score)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{pycon}
>>> multiplier = Duration(24, 4) / Duration(19, 4)
>>> timespan_inventory = timespan_inventory.reflect()
>>> timespan_inventory = timespan_inventory.stretch(multiplier)
>>> timespan_inventory = timespan_inventory.round_offsets(Duration(1, 8))
>>> show(timespan_inventory, key='voice_name')
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-cbf2e54be533296d32c9607c4f42c82f.pdf}
\begin{minted}{pycon}
>>> score = build_score(
...     performed_rhythm_maker=performed_rhythm_maker,
...     permitted_meters=permitted_meters,
...     score_template=score_template,
...     timespan_inventory=timespan_inventory,
...     )
>>> consort.annotate(score)
>>> show(score)
\end{minted}
\noindent\includegraphics[max width=\textwidth,page=1]{assets/lilypond-9a60e0606f9bf6de2f325689ff40447b.pdf}
\newline
\newline
\noindent\includegraphics[max width=\textwidth,page=2]{assets/lilypond-9a60e0606f9bf6de2f325689ff40447b.pdf}
\newline
\newline
\noindent\includegraphics[max width=\textwidth,page=3]{assets/lilypond-9a60e0606f9bf6de2f325689ff40447b.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Many other variations and extensions to the basic score-building
algorithm outlined above are possible. The input rhythm-maker could be varied
or replaced by a composite rhythm-maker. The score generation process could be
extended so that rhythm-makers could be stored on the performed timespans
themselves, allowing each performed timespan to specify its local rhythmic
language. Multiple timespan inventories could be combined together using the
various logical operations to implement masking or fusing when timespans from
one inventory overlap those from another. In fact, all of these extensions and
variations are employed in Consort's own score generation process, as described
in \autoref{chap:a-model-of-composition}.