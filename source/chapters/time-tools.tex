%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Tools for modeling time, rhythm and meter}
\label{chap:time-tools}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{comment}
<abjad>[hide=true]
import collections
import consort
</abjad>
\end{comment}

\todo[inline]{\textbf{TODO:} Add section labels.}

\todo[inline]{\textbf{TODO:} Investigate adding indexing commands.}

\todo[inline]{\textbf{TODO:} Investigate additional citations.}

\todo[inline]{\textbf{TODO:} Investigate use of colons to introduce examples.}

\todo[inline]{\textbf{TODO:} Determine appropriate pronoun usage.}

\todo[inline]{\textbf{TODO:} Verify hyphenated lowercase class names.}

Consort implements a model of composition which relies on a number of
interrelated but distinct approaches to working with musical time. For example,
Abjad's \emph{Timespan} suggests a \enquote{coarse} approach to musical
time. These objects represent arbitrary durated events on a timeline, without
respect for score hierarchy or meter. They are well-suited for modeling
large-scale phrasing and gestural density structures and can be transformed
through splitting, scaling, stretching, and translation among various other
manipulations. Because they have no notational reality, they can model
temporal concepts unsuited to notated music -- without introducing additional
complexity--, such as arbitrarily overlapping events. Timespans may also be
annotated, allowing composers to position metadata anywhere on a timeline, much
like arranging audio regions in a DAW.\footnote{Cite the \emph{Computer Music
Tutorial}.} Moreover, every durated object in a score hierarchy can be
described as a timespan, allowing score components to engage in abstract time
relations. In contrast, notated rhythms, composed of note, rest, tie and tuplet
objects -- among others--, provide the most \enquote{fine-grained} approach to
musical time. While incredibly expressive, fully notated rhythms are
potentially complex to create, and must ultimately be anchored in a score
hierarchy. Highly-configurable rhythm-maker classes ameliorate the complexity
of creating notated rhythms by providing a high-level interface to the process
of rhythm generation. Meter coordinates time and rhythm vertically across
score hierarchy, and bridges Consort's coarse and fine stages of rhythmic
interpretation. Meter sequences can be generated from timespan-based phrase
structures, and those meter sequences used to transform notated rhythms in
turn. A thorough discussion of the implementation of these time models and
their implications will clarify a later analysis of Consort's score
interpretation stage.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Timespans}
\label{sec:timespans}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\emph{Timespans} model left-closed / right-open intervals of time positioned
absolutely along a timeline. Every timespan describes a range
of offsets $x$ starting with -- and including -- some start offset $A$ and
leading up to -- but \emph{not} including -- some stop offset $B$:

\begin{equation}
A \leq x < B
\end{equation}

Note that all leaves in a score describe such half-bounded intervals of time.
Adjacent notes in a score do not overlap but rather abut one another because
their timespans do not overlap. In fact, every durated object in a score --
every note, chord, rest, measure, staff, and even the score itself -- can be
described in terms of timespans. Yet, while score objects can always be
expressed as timespans, those timespans themselves do not -- by definition
-- refer to any score objects. Abjad implements timespans as immutable
constants, much like Abjad's \texttt{Pitch} and \texttt{Duration} objects, and
similarly to Python's implementation of numbers and strings. Constancy allows
timespans to avoid a variety of computational reference problems. For example,
multiple objects can reference the same timespan without fear of that timespan
changing state, much as multiple objects can reference the integer 11 without
fear that that same integer will change into the integer 5.

\todo[inline]{\textbf{TODO:} Emphasize and clarify set-theoretic definition of
timespans in terms of offsets.}

Abjad implements timespans via the \texttt{Timespan} class in its
\texttt{timespantools} library. The following code shows the definition of a
timespan object beginning at the offset 1/4 and continues up until the offset
3/2:

\begin{comment}
<abjad>
timespan = timespantools.Timespan(
    start_offset=Offset(1, 4),
    stop_offset=Offset(3, 2),
    )
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespan = timespantools.Timespan(
...     start_offset=Offset(1, 4),
...     stop_offset=Offset(3, 2),
...     )
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Like many objects in Abjad, timespan can be formatted for
human-readable textual inspection, or displayed as a graphic illustration.

\begin{comment}
<abjad>
print(format(timespan))
show(timespan)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> print(format(timespan))
timespantools.Timespan(
    start_offset=durationtools.Offset(1, 4),
    stop_offset=durationtools.Offset(3, 2),
    )
\end{lstlisting}
\begin{lstlisting}
>>> show(timespan)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-3197d8ddef560bdde0c460c116b33801.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent The \texttt{Timespan} class provides a large number of methods and
properties for inspecting timespans, comparing them to other timespans or
offsets, and for operating on timespans to generate new timespans. Once
instantiated, a timespan can be examined for its start offset, stop offset
and duration. Because of the \texttt{Timespan} class' immutability, these
properties are read-only and therefore can only be accessed, but not changed.

\begin{comment}
<abjad>
timespan.start_offset
timespan.stop_offset
timespan.duration
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespan.start_offset
Offset(1, 4)
\end{lstlisting}
\begin{lstlisting}
>>> timespan.stop_offset
Offset(3, 2)
\end{lstlisting}
\begin{lstlisting}
>>> timespan.duration
Duration(5, 4)
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent A timespan's start offset must be equal to or less than its stop
offset. Timespans with identical start and stop offsets have a duration of 0
and effectively model a single time-point. Such timespans are considered not
\enquote{well-formed}.

\begin{comment}
<abjad>
timepoint_timespan = timespantools.Timespan(1, 1)
timepoint_timespan.duration
timepoint_timespan.is_well_formed
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timepoint_timespan = timespantools.Timespan(1, 1)
>>> timepoint_timespan.duration
Duration(0, 1)
\end{lstlisting}
\begin{lstlisting}
>>> timepoint_timespan.is_well_formed
False
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Both the \texttt{start\_offset} and \texttt{stop\_offset} keywords to
the \texttt{Timespan} class' initializer are optional, and default to Abjad's
built-in rational constants \texttt{NegativeInfinity} and \texttt{Infinity}
respectively. A timespan created without specifying either a start or stop
offset effectively describes the timespan which encompasses all possible
offsets in time.

\begin{comment}
<abjad>
infinite_timespan = timespantools.Timespan()
infinite_timespan.start_offset
infinite_timespan.stop_offset
infinite_timespan.duration
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> infinite_timespan = timespantools.Timespan()
>>> infinite_timespan.start_offset
NegativeInfinity
\end{lstlisting}
\begin{lstlisting}
>>> infinite_timespan.stop_offset
Infinity
\end{lstlisting}
\begin{lstlisting}
>>> infinite_timespan.duration
Infinity
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent By specifying only a start or stop offset, timespans can also be
created which encompass the infinite set of offsets up until some stop offset,
or the infinite set of offsets starting at and following some start-offset.

\begin{comment}
<abjad>
timespantools.Timespan(stop_offset=0)
timespantools.Timespan(start_offset=0)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespantools.Timespan(stop_offset=0)
Timespan(start_offset=NegativeInfinity, stop_offset=Offset(0, 1))
\end{lstlisting}
\begin{lstlisting}
>>> timespantools.Timespan(start_offset=0)
Timespan(start_offset=Offset(0, 1), stop_offset=Infinity)
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent \texttt{Timespan} objects also partake in Abjad's templating regime.
New timespans can be created from old ones through the use of the top-level
\texttt{new()} function.

\begin{comment}
<abjad>
new(timespan, stop_offset=(5, 16))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> new(timespan, stop_offset=(5, 16))
Timespan(start_offset=Offset(1, 4), stop_offset=Offset(5, 16))
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Note that the above timespans have been configured from input in
various formats, such as explicit \texttt{Offset} objects, integers, and even
numerator/denominator pairs. Timespans always coerce arguments given for their
\texttt{start\_offset} and \texttt{stop\_offset} properties into explicit
\texttt{Offset} instances. Abjad's other classes and functions implement
similar offset, duration, and even pitch-coercion behavior pervasively.

\subsection{Annotated timespans} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

While the \texttt{Timespan} class only has two configurable properties -- its
start offset and stop offset --, subclassing allows for the creation of new
classes with the same core functionality as \texttt{Timespan} but extended to
support new behaviors and configurations. As an example, Abjad's
\texttt{timespantools} library provides an \texttt{AnnotatedTimespan} class
which subclasses \texttt{Timespan} but adds a third read-only
\texttt{annotation} property, which can be configured with any arbitrary
object.

\begin{comment}
<abjad>
annotated_timespan = timespantools.AnnotatedTimespan(
    start_offset=(1, 8),
    stop_offset=(7, 8),
    annotation='Any arbitrary object can act as an annotation.'
    )
annotated_timespan.annotation
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> annotated_timespan = timespantools.AnnotatedTimespan(
...     start_offset=(1, 8),
...     stop_offset=(7, 8),
...     annotation='Any arbitrary object can act as an annotation.'
...     )
>>> annotated_timespan.annotation
'Any arbitrary object can act as an annotation.'
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Annotated timespans allow composers to position annotations or any
other metadata along a timeline. If the annotation object is itself a mutable
data structure such as a Python list or dictionary, that annotation can be used
to store increasing amounts of information during the compositional process.
Additionally, Abjad's top-level \texttt{new()} function can be used to template
new annotated timespans from old ones, replacing one annotation with another
while preserving temporal information. If that same annotation object supports
templating, nested reconfiguration can be performed.

\begin{comment}
<abjad>
metadata_timespan = new(annotated_timespan,
    stop_offset=(3, 2),
    annotation={
        'durations': ((1, 8), (1, 8), (3, 16)),
        'dynamic': indicatortools.Dynamic('ppp'),
        'pitch_segment': pitchtools.PitchSegment([0, 1, 4, 7]),
        },
    )
metadata_timespan.annotation['bow_contact_point'] = Multiplier(1, 3)
print(format(metadata_timespan))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> metadata_timespan = new(annotated_timespan,
...     stop_offset=(3, 2),
...     annotation={
...         'durations': ((1, 8), (1, 8), (3, 16)),
...         'dynamic': indicatortools.Dynamic('ppp'),
...         'pitch_segment': pitchtools.PitchSegment([0, 1, 4, 7]),
...         },
...     )
>>> metadata_timespan.annotation['bow_contact_point'] = Multiplier(1, 3)
>>> print(format(metadata_timespan))
timespantools.AnnotatedTimespan(
    start_offset=durationtools.Offset(1, 8),
    stop_offset=durationtools.Offset(3, 2),
    annotation={
        'bow_contact_point': durationtools.Multiplier(1, 3),
        'durations': (
            (1, 8),
            (1, 8),
            (3, 16),
            ),
        'dynamic': indicatortools.Dynamic(
            name='ppp',
            ),
        'pitch_segment': pitchtools.PitchSegment(
            (
                pitchtools.NumberedPitch(0),
                pitchtools.NumberedPitch(1),
                pitchtools.NumberedPitch(4),
                pitchtools.NumberedPitch(7),
                ),
            item_class=pitchtools.NumberedPitch,
            ),
        },
    )
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Other \texttt{Timespan} subclasses are possible, allowing for even
more configurable properties, as well as new methods. Two \texttt{Timespan}
subclasses discussed later, \texttt{consort.PerformedTimespan} and
\texttt{consort.SilentTimespan}, are core components in Consort's score
interpretation stage.

\subsection{Time relations} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\emph{Time relations} model the disposition of one timespan relative to
another timespan or offset. These relationships include intersection,
containment, simultaneous start offsets or stop offsets, and many others.
Abjad's \texttt{timespantools} library provides a \texttt{TimeRelation} class
and a collection of factory methods for configuring \texttt{TimeRelation}
instances which formalize all possible dispositions of a timespan relative
another timespan or offset\footnote{The thirty-three time relation factory
functions contained in \texttt{timespantools} are
\texttt{offset\_happens\_after\_timespan\_starts()},
\texttt{offset\_happens\_after\_timespan\_stops()},
\texttt{offset\_happens\_before\_timespan\_starts()},
\texttt{offset\_happens\_before\_timespan\_stops()},
\texttt{offset\_happens\_during\_timespan()},
\texttt{offset\_happens\_when\_timespan\_starts()},
\texttt{offset\_happens\_when\_timespan\_stops()},
\texttt{timespan\_2\_contains\_timespan\_1\_improperly()},
\texttt{timespan\_2\_curtails\_timespan\_1()},
\texttt{timespan\_2\_delays\_timespan\_1()},
\texttt{timespan\_2\_happens\_during\_timespan\_1()},
\texttt{timespan\_2\_intersects\_timespan\_1()},
\texttt{timespan\_2\_is\_congruent\_to\_timespan\_1()},
\texttt{timespan\_2\_overlaps\_all\_of\_timespan\_1()},
\texttt{timespan\_2\_overlaps\_only\_start\_of\_timespan\_1()},
\texttt{timespan\_2\_overlaps\_only\_stop\_of\_timespan\_1()},
\texttt{timespan\_2\_overlaps\_start\_of\_timespan\_1()},
\texttt{timespan\_2\_overlaps\_stop\_of\_timespan\_1()},
\texttt{timespan\_2\_starts\_after\_timespan\_1\_starts()},
\texttt{timespan\_2\_starts\_after\_timespan\_1\_stops()},
\texttt{timespan\_2\_starts\_before\_timespan\_1\_starts()},
\texttt{timespan\_2\_starts\_before\_timespan\_1\_stops()},
\texttt{timespan\_2\_starts\_during\_timespan\_1()},
\texttt{timespan\_2\_starts\_when\_timespan\_1\_starts()},
\texttt{timespan\_2\_starts\_when\_timespan\_1\_stops()},
\texttt{timespan\_2\_stops\_after\_timespan\_1\_starts()},
\texttt{timespan\_2\_stops\_after\_timespan\_1\_stops()},
\texttt{timespan\_2\_stops\_before\_timespan\_1\_starts()},
\texttt{timespan\_2\_stops\_before\_timespan\_1\_stops()},
\texttt{timespan\_2\_stops\_during\_timespan\_1()},
\texttt{timespan\_2\_stops\_when\_timespan\_1\_starts()},
\texttt{timespan\_2\_stops\_when\_timespan\_1\_stops()} and
\texttt{timespan\_2\_trisects\_timespan\_1()}. }. Time relations may be
configured with or without reference to any timespans or offsets at all,
allowing for the possibility of modeling a purely abstract time relationship.

\begin{comment}
<abjad>
time_relation_1 = timespantools.timespan_2_intersects_timespan_1()
print(format(time_relation_1))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> time_relation_1 = timespantools.timespan_2_intersects_timespan_1()
>>> print(format(time_relation_1))
timespantools.TimespanTimespanTimeRelation(
    inequality=timespantools.CompoundInequality(
        [
            timespantools.CompoundInequality(
                [
                    timespantools.SimpleInequality('timespan_1.start_offset <= timespan_2.start_offset'),
                    timespantools.SimpleInequality('timespan_2.start_offset < timespan_1.stop_offset'),
                    ],
                logical_operator='and',
                ),
            timespantools.CompoundInequality(
                [
                    timespantools.SimpleInequality('timespan_2.start_offset <= timespan_1.start_offset'),
                    timespantools.SimpleInequality('timespan_1.start_offset < timespan_2.stop_offset'),
                    ],
                logical_operator='and',
                ),
            ],
        logical_operator='or',
        ),
    )
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent The above intersection relationship between the timespans $[a, b)$
and $[c, d)$ can be described more pithily by the following predicate:

\begin{equation}
(a \leq c \land c < b) \lor (c \leq a \land a < d)
\end{equation}

\noindent A \enquote{half-configured} time relation is also possible. Such an
object acts as a kind of \enquote{frozen} predicate. Calling the time
relation as though it was a function\footnote{Any class in Python can be made
treatable as a function by implementing a \texttt{\_\_call\_\_()} method.} on
another timespan or offset returns a truth value.

\begin{comment}
<abjad>
time_relation_2 = timespantools.timespan_2_intersects_timespan_1(
    timespan_1=timespantools.Timespan(0, 10),
    )
time_relation_2(timespan_2=timespantools.Timespan(5, 15))
time_relation_2(timespan_2=timespantools.Timespan(30, 45))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> time_relation_2 = timespantools.timespan_2_intersects_timespan_1(
...     timespan_1=timespantools.Timespan(0, 10),
...     )
>>> time_relation_2(timespan_2=timespantools.Timespan(5, 15))
True
\end{lstlisting}
\begin{lstlisting}
>>> time_relation_2(timespan_2=timespantools.Timespan(30, 45))
False
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Providing two timespans -- or one timespan and an offset, as required
-- to one of the various time relation factory functions found in
\texttt{timespantools} will configure and then immediately evaluate the
generated time relation object, allowing the factory function itself to behave
as a predicate.

\begin{comment}
<abjad>
timespantools.timespan_2_intersects_timespan_1(
    timespan_1=timespantools.Timespan(1, 3),
    timespan_2=timespantools.Timespan(2, 4),
    )
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespantools.timespan_2_intersects_timespan_1(
...     timespan_1=timespantools.Timespan(1, 3),
...     timespan_2=timespantools.Timespan(2, 4),
...     )
True
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent The time relation factory functions in \texttt{timespantools} are
mirrored as methods on the \texttt{Timespan} class itself, allowing composers
to determine the various relations of any timespan relative any other timespan
or offset in an object-oriented fashion. The \texttt{Timespan} object
automatically \enquote{fills in} the \texttt{timespan\_1} argument to the
\texttt{TimeRelation} with a reference to itself, and can pass the optional
argument to its method call as the other object in the relation, allowing for
the immediate evaluation of the relation as either true or false.

Consider the following three timespans:

\begin{comment}
<abjad>
timespan_1 = timespantools.Timespan(0, 10)
timespan_2 = timespantools.Timespan(5, 15)
timespan_3 = timespantools.Timespan(10, 20)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespan_1 = timespantools.Timespan(0, 10)
>>> timespan_2 = timespantools.Timespan(5, 15)
>>> timespan_3 = timespantools.Timespan(10, 20)
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent After being collected into a \emph{timespan inventory}, discussed
further in \autoref{sec:timespan-inventories}, the three timespans can be
illustrated. Note that the beginning and end of each timespan is demarcated by
a short vertical line, and that only non-intersecting timespans are shown in
each \enquote{row} in the illustration.

\begin{comment}
<abjad>[hide=true]
timespan_inventory = timespantools.TimespanInventory([
    timespan_1,
    timespan_2,
    timespan_3,
    ])
show(timespan_inventory)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-2bec073ccb80642bed69b2ea98034628.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent We can test for intersection between these three timespans via the
\texttt{intersects\_timespan()} method. Two timespans are considered to
intersect if any part of one timespan overlaps any part of another.
\emph{Intersection} is therefore commutative. Note that \texttt{timespan\_1}
and \texttt{timespan\_3} do not overlap even though they share the offset 10.
As discussed earlier, timespans are left-closed / right-open, meaning that
while their start offset is contained in the infinite set of offsets they range
over, their stop offset is not.

\begin{comment}
<abjad>
timespan_1.intersects_timespan(timespan_2)
timespan_1.intersects_timespan(timespan_3)
timespan_2.intersects_timespan(timespan_1)
timespan_2.intersects_timespan(timespan_3)
timespan_3.intersects_timespan(timespan_1)
timespan_3.intersects_timespan(timespan_2)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespan_1.intersects_timespan(timespan_2)
True
\end{lstlisting}
\begin{lstlisting}
>>> timespan_1.intersects_timespan(timespan_3)
False
\end{lstlisting}
\begin{lstlisting}
>>> timespan_2.intersects_timespan(timespan_1)
True
\end{lstlisting}
\begin{lstlisting}
>>> timespan_2.intersects_timespan(timespan_3)
True
\end{lstlisting}
\begin{lstlisting}
>>> timespan_3.intersects_timespan(timespan_1)
False
\end{lstlisting}
\begin{lstlisting}
>>> timespan_3.intersects_timespan(timespan_2)
True
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent \emph{Congruency} tests whether two timespans share the same start
and stop offset. Every timespan is congruent with itself.

\begin{comment}
<abjad>
timespan_1.is_congruent_to_timespan(timespan_2)
timespan_1.is_congruent_to_timespan(timespan_1)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespan_1.is_congruent_to_timespan(timespan_2)
False
\end{lstlisting}
\begin{lstlisting}
>>> timespan_1.is_congruent_to_timespan(timespan_1)
True
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent \emph{Tangency} tests whether one timespan's stop offset is the same
as another timespan's start offset, or vice versa. Tangency can be used to
determine if a sorted collection of timespans is both entirely contiguous and
non-overlapping.

\begin{comment}
<abjad>
timespan_1.is_tangent_to_timespan(timespan_2)
timespan_1.is_tangent_to_timespan(timespan_3)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespan_1.is_tangent_to_timespan(timespan_2)
False
\end{lstlisting}
\begin{lstlisting}
>>> timespan_1.is_tangent_to_timespan(timespan_3)
True
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent A wide variety of other time relation predicates are also possible,
such as testing if a timespan intersects with a specific offset, testing if a
timespan overlaps only the beginning or end of another timespan, or testing if
a timespan contains another timespan entirely. These predicates make possible
the many generative operations carried out on timespans.

\subsection{Operations on timespans} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:operations-on-timespans}

Many \texttt{Timespan} methods provide transformations, such as translation,
scaling or offset rounding. Because timespans are immutable, these methods
create a new timespan based on the old one and then return the new, leaving
the old exactly as it was.

\begin{comment}
<abjad>
timespan = timespantools.Timespan(0, 15)
timespan.translate(3)
timespan.scale(3)
timespan.round_offsets(2)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespan = timespantools.Timespan(0, 15)
>>> timespan.translate(3)
Timespan(start_offset=Offset(3, 1), stop_offset=Offset(18, 1))
\end{lstlisting}
\begin{lstlisting}
>>> timespan.scale(3)
Timespan(start_offset=Offset(0, 1), stop_offset=Offset(45, 1))
\end{lstlisting}
\begin{lstlisting}
>>> timespan.round_offsets(2)
Timespan(start_offset=Offset(0, 1), stop_offset=Offset(16, 1))
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent These generative methods are implemented internally in terms of
templating via \texttt{new()}, as described in \autoref{sec:timespans},
allowing annotated timespan subclasses to partake in the same generative
functionality -- reconfiguring their start and / or stop offsets, but
maintaining all other previously configured properties.

\begin{comment}
<abjad>
annotated_timespan = timespantools.AnnotatedTimespan(0, 5, 'an annotation')
scaled_annotated_timespan = annotated_timespan.translate((-1, 3))
print(format(scaled_annotated_timespan))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> annotated_timespan = timespantools.AnnotatedTimespan(0, 5, 'an annotation')
>>> scaled_annotated_timespan = annotated_timespan.translate((-1, 3))
>>> print(format(scaled_annotated_timespan))
timespantools.AnnotatedTimespan(
    start_offset=durationtools.Offset(-1, 3),
    stop_offset=durationtools.Offset(14, 3),
    annotation='an annotation',
    )
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Some generative operations may return zero or more timespans,
aggregated in a data structure called a \emph{timespan inventory}, discussed at
length in \autoref{sec:timespan-inventories}. Splitting a timespan by an offset
is one such operation. If the timespan to be split \emph{properly
contains}\footnote{\emph{Proper containment} of an offset means that the offset
is greater than the timespan's start offset and less than the timespan's stop
offset. \emph{Improper containment} would indicated the offset is greater than
or equal to the timespan's start offset and less than or equal to its stop
offset.} the splitting offset, a timespan inventory containing two new
timespans will be returned. Otherwise, the split operation will return a
timespan inventory containing a copy of the original input timespan.

\begin{comment}
<abjad>
two_shards = timespan.split_at_offset(5)
print(format(two_shards))
one_shard = timespan.split_at_offset(10000)
print(format(one_shard))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> two_shards = timespan.split_at_offset(5)
>>> print(format(two_shards))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(0, 1),
            stop_offset=durationtools.Offset(5, 1),
            ),
        timespantools.Timespan(
            start_offset=durationtools.Offset(5, 1),
            stop_offset=durationtools.Offset(15, 1),
            ),
        ]
    )
\end{lstlisting}
\begin{lstlisting}
>>> one_shard = timespan.split_at_offset(10000)
>>> print(format(one_shard))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(0, 1),
            stop_offset=durationtools.Offset(15, 1),
            ),
        ]
    )
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent More complex operations between timespans resulting in timespan
inventories include subtraction and the logical operations
\texttt{AND}, \texttt{OR} and \texttt{XOR}. These generative operations are
conceptually \emph{set} operations -- union, difference, intersection,
symmetric difference, etc. -- performed on the two sets of offsets contained by
the two timespan operands. Consider these same set operations -- union,
difference, intersection, symmetric difference -- carried out on trivial sets
in Python.

\begin{comment}
<abjad>
set([1, 2, 3]) | set([2, 3, 4])  # union
set([1, 2, 3]) - set([2, 3, 4])  # difference
set([1, 2, 3]) & set([2, 3, 4])  # intersection
set([1, 2, 3]) ^ set([2, 3, 4])  # symmetric difference
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> set([1, 2, 3]) | set([2, 3, 4])  # union
set([1, 2, 3, 4])
\end{lstlisting}
\begin{lstlisting}
>>> set([1, 2, 3]) - set([2, 3, 4])  # difference
set([1])
\end{lstlisting}
\begin{lstlisting}
>>> set([1, 2, 3]) & set([2, 3, 4])  # intersection
set([2, 3])
\end{lstlisting}
\begin{lstlisting}
>>> set([1, 2, 3]) ^ set([2, 3, 4])  # symmetric difference
set([1, 4])
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Set operations performed on timespans are conceptually identical, but
operate on infinite but bounded sets of offsets instead of discrete sets of
objects such as integers. For example, subtracting one timespan from another
computes the set difference of the offsets contained by both. This operation is
not commutative -- subtracting one timespan from another will not result in the
same output as subtracting the latter from the former. Subtracting a timespan
from itself always results in the empty set of offsets: no timespan at all.

\begin{comment}
<abjad>
result = timespantools.Timespan(0, 10) - timespantools.Timespan(0, 10)
print(format(result))
result = timespantools.Timespan(0, 10) - timespantools.Timespan(5, 15)
print(format(result))
result = timespantools.Timespan(0, 10) - timespantools.Timespan(10, 20)
print(format(result))
result = timespantools.Timespan(5, 15) - timespantools.Timespan(0, 10)
print(format(result))
result = timespantools.Timespan(5, 15) - timespantools.Timespan(5, 15)
print(format(result))
result = timespantools.Timespan(5, 15) - timespantools.Timespan(10, 20)
print(format(result))
result = timespantools.Timespan(10, 20) - timespantools.Timespan(0, 10)
print(format(result))
result = timespantools.Timespan(10, 20) - timespantools.Timespan(5, 15)
print(format(result))
result = timespantools.Timespan(10, 20) - timespantools.Timespan(10, 20)
print(format(result))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> result = timespantools.Timespan(0, 10) - timespantools.Timespan(0, 10)
>>> print(format(result))
timespantools.TimespanInventory(
    []
    )
\end{lstlisting}
\begin{lstlisting}
>>> result = timespantools.Timespan(0, 10) - timespantools.Timespan(5, 15)
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(0, 1),
            stop_offset=durationtools.Offset(5, 1),
            ),
        ]
    )
\end{lstlisting}
\begin{lstlisting}
>>> result = timespantools.Timespan(0, 10) - timespantools.Timespan(10, 20)
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(0, 1),
            stop_offset=durationtools.Offset(10, 1),
            ),
        ]
    )
\end{lstlisting}
\begin{lstlisting}
>>> result = timespantools.Timespan(5, 15) - timespantools.Timespan(0, 10)
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(10, 1),
            stop_offset=durationtools.Offset(15, 1),
            ),
        ]
    )
\end{lstlisting}
\begin{lstlisting}
>>> result = timespantools.Timespan(5, 15) - timespantools.Timespan(5, 15)
>>> print(format(result))
timespantools.TimespanInventory(
    []
    )
\end{lstlisting}
\begin{lstlisting}
>>> result = timespantools.Timespan(5, 15) - timespantools.Timespan(10, 20)
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(5, 1),
            stop_offset=durationtools.Offset(10, 1),
            ),
        ]
    )
\end{lstlisting}
\begin{lstlisting}
>>> result = timespantools.Timespan(10, 20) - timespantools.Timespan(0, 10)
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(10, 1),
            stop_offset=durationtools.Offset(20, 1),
            ),
        ]
    )
\end{lstlisting}
\begin{lstlisting}
>>> result = timespantools.Timespan(10, 20) - timespantools.Timespan(5, 15)
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(15, 1),
            stop_offset=durationtools.Offset(20, 1),
            ),
        ]
    )
\end{lstlisting}
\begin{lstlisting}
>>> result = timespantools.Timespan(10, 20) - timespantools.Timespan(10, 20)
>>> print(format(result))
timespantools.TimespanInventory(
    []
    )
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Computing the logical \texttt{OR} of two timespans results in an
offset set union -- a commutative operation, effectively fusing the timespans
together if they overlap.

\begin{comment}
<abjad>
result = timespantools.Timespan(0, 10) | timespantools.Timespan(5, 15)
print(format(result))
result = timespantools.Timespan(0, 10) | timespantools.Timespan(10, 20)
print(format(result))
result = timespantools.Timespan(5, 15) | timespantools.Timespan(10, 20)
print(format(result))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> result = timespantools.Timespan(0, 10) | timespantools.Timespan(5, 15)
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(0, 1),
            stop_offset=durationtools.Offset(15, 1),
            ),
        ]
    )
\end{lstlisting}
\begin{lstlisting}
>>> result = timespantools.Timespan(0, 10) | timespantools.Timespan(10, 20)
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(0, 1),
            stop_offset=durationtools.Offset(20, 1),
            ),
        ]
    )
\end{lstlisting}
\begin{lstlisting}
>>> result = timespantools.Timespan(5, 15) | timespantools.Timespan(10, 20)
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(5, 1),
            stop_offset=durationtools.Offset(20, 1),
            ),
        ]
    )
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Unioning guarantees that all of the offsets contained in the two
input timespans will appear in the output timespan or timespans, whether or not
any overlap occurred:

\begin{comment}
<abjad>
result = timespantools.Timespan(10, 20) | timespantools.Timespan(25, 50)
print(format(result))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> result = timespantools.Timespan(10, 20) | timespantools.Timespan(25, 50)
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(10, 1),
            stop_offset=durationtools.Offset(20, 1),
            ),
        timespantools.Timespan(
            start_offset=durationtools.Offset(25, 1),
            stop_offset=durationtools.Offset(50, 1),
            ),
        ]
    )
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent The logical \texttt{AND} -- set intersection -- results in the
intersection of the two input timespans. Only those offsets which occur in both
timespan operands will occur in the output timespan, if any.

\begin{comment}
<abjad>
result = timespantools.Timespan(0, 10) & timespantools.Timespan(5, 15)
print(format(result))
result = timespantools.Timespan(0, 10) & timespantools.Timespan(10, 20)
print(format(result))
result = timespantools.Timespan(5, 15) & timespantools.Timespan(10, 20)
print(format(result))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> result = timespantools.Timespan(0, 10) & timespantools.Timespan(5, 15)
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(5, 1),
            stop_offset=durationtools.Offset(10, 1),
            ),
        ]
    )
\end{lstlisting}
\begin{lstlisting}
>>> result = timespantools.Timespan(0, 10) & timespantools.Timespan(10, 20)
>>> print(format(result))
timespantools.TimespanInventory(
    []
    )
\end{lstlisting}
\begin{lstlisting}
>>> result = timespantools.Timespan(5, 15) & timespantools.Timespan(10, 20)
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(10, 1),
            stop_offset=durationtools.Offset(15, 1),
            ),
        ]
    )
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Logical \texttt{XOR} -- also known as exclusive \texttt{OR} --
results in the symmetric difference of the two input timespans. Only those
offsets which are contained by only one of the two input timespans will occur
in the output.

\begin{comment}
<abjad>
result = timespantools.Timespan(0, 10) ^ timespantools.Timespan(5, 15)
print(format(result))
result = timespantools.Timespan(0, 10) ^ timespantools.Timespan(10, 20)
print(format(result))
result = timespantools.Timespan(5, 15) ^ timespantools.Timespan(10, 20)
print(format(result))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> result = timespantools.Timespan(0, 10) ^ timespantools.Timespan(5, 15)
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(0, 1),
            stop_offset=durationtools.Offset(5, 1),
            ),
        timespantools.Timespan(
            start_offset=durationtools.Offset(10, 1),
            stop_offset=durationtools.Offset(15, 1),
            ),
        ]
    )
\end{lstlisting}
\begin{lstlisting}
>>> result = timespantools.Timespan(0, 10) ^ timespantools.Timespan(10, 20)
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(0, 1),
            stop_offset=durationtools.Offset(10, 1),
            ),
        timespantools.Timespan(
            start_offset=durationtools.Offset(10, 1),
            stop_offset=durationtools.Offset(20, 1),
            ),
        ]
    )
\end{lstlisting}
\begin{lstlisting}
>>> result = timespantools.Timespan(5, 15) ^ timespantools.Timespan(10, 20)
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(5, 1),
            stop_offset=durationtools.Offset(10, 1),
            ),
        timespantools.Timespan(
            start_offset=durationtools.Offset(15, 1),
            stop_offset=durationtools.Offset(20, 1),
            ),
        ]
    )
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent These operations, while perhaps initially rather abstract, are
incredibly powerful and artistically useful. They afford composers with the
procedural building blocks to mask temporal objects with one another, fuse them
together, or create lacunae. When extended to operate on many timespans at
once, wholesale transformations on massed timespans becomes practical.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Timespan inventories}
\label{sec:timespan-inventories}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\todo[inline]{\textbf{TODO:} Cite \emph{Introduction to Algorithms} for
interval trees.}

Abjad provides a \texttt{TimespanInventory} class specifically for aggregating
together a collection of \texttt{Timespan} objects.\footnote{ Consort provides
its own timespan collection class -- the \texttt{TimespanCollection}. This
class stores timespans internally not in a list, but in a balanced
\emph{interval tree}. An interval tree is an augmented, self-balancing binary
tree which stores start offsets and stop offsets. Such a data structure
guarantees its contents are always sorted, and allows for highly optimized
lookups for timespan matching various search criteria. The
\texttt{TimespanCollection} class is used at crucial points during Consort's
interpretation stage simply for purposes of speed, and should be considered an
implementation detail. It provides only a few methods, specifically for
affording rapid search and retrieval of timespans intersecting other timespans
or offsets. With work, its internal data structure may eventually be merged into
Abjad's own \texttt{TimespanInventory} class.} Timespan inventories implement
Python's \emph{mutable sequence protocol} which allow them to behave exactly
like lists, supporting appension, extension, insertion, indexing, sorting,
iteration and other procedures pertinent to list-like objects. They also
provide a wide variety of properties and methods for interacting with massed
groups of timespans such as searching for timespans matching a time relation,
splitting all timespans which intersect with a given offset, mapping a logical
operation against all timespans in the inventory, or partitioning an
inventory containing overlapping timespans into multiple separate inventories
containing non-overlapping timespans.

Like a Python list, a timespan inventory can be created with an iterable of
zero or more timespans as an instantiation argument, be appended to, or
extended into.

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(0, 16),
    ])
timespan_inventory.append(timespantools.Timespan(5, 12))
timespan_inventory.extend([
    timespantools.Timespan(-2, 8),
    timespantools.Timespan(15, 20),
    ])
print(format(timespan_inventory))
show(timespan_inventory)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespan_inventory = timespantools.TimespanInventory([
...     timespantools.Timespan(0, 16),
...     ])
>>> timespan_inventory.append(timespantools.Timespan(5, 12))
>>> timespan_inventory.extend([
...     timespantools.Timespan(-2, 8),
...     timespantools.Timespan(15, 20),
...     ])
>>> print(format(timespan_inventory))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(0, 1),
            stop_offset=durationtools.Offset(16, 1),
            ),
        timespantools.Timespan(
            start_offset=durationtools.Offset(5, 1),
            stop_offset=durationtools.Offset(12, 1),
            ),
        timespantools.Timespan(
            start_offset=durationtools.Offset(-2, 1),
            stop_offset=durationtools.Offset(8, 1),
            ),
        timespantools.Timespan(
            start_offset=durationtools.Offset(15, 1),
            stop_offset=durationtools.Offset(20, 1),
            ),
        ]
    )
\end{lstlisting}
\begin{lstlisting}
>>> show(timespan_inventory)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-334f7faa0ec05aeb7fa5ff0a1269aca8.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Timespan inventories can also be queried for their length, be indexed
into, or iterated over like any other sequence-like object in Python.

\begin{comment}
<abjad>
len(timespan_inventory)
timespan_inventory[1]
for timespan in timespan_inventory:
    timespan

</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> len(timespan_inventory)
4
\end{lstlisting}
\begin{lstlisting}
>>> timespan_inventory[1]
Timespan(start_offset=Offset(5, 1), stop_offset=Offset(12, 1))
\end{lstlisting}
\begin{lstlisting}
>>> for timespan in timespan_inventory:
...     timespan
...
Timespan(start_offset=Offset(0, 1), stop_offset=Offset(16, 1))
Timespan(start_offset=Offset(5, 1), stop_offset=Offset(12, 1))
Timespan(start_offset=Offset(-2, 1), stop_offset=Offset(8, 1))
Timespan(start_offset=Offset(15, 1), stop_offset=Offset(20, 1))
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent One timespan inventory can be created from another by passing the
first timespan inventory as an instantiation argument to the second, just like
one can create a Python list simply by calling \texttt{list()} on another
iterable object, including another list. Unlike timespans, timespan inventories
are mutable. As many of the operations implemented on timespan inventories
mutate the inventory \emph{in-place}, this instantiation pattern provides a
simple means of \enquote{copying}, allowing composers to duplicate a timespan
structure before operating on it, thereby preserving the original.

\begin{comment}
<abjad>
duplicate = timespantools.TimespanInventory(timespan_inventory)
duplicate == timespan_inventory
duplicate is timespan_inventory
print(format(duplicate))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> duplicate = timespantools.TimespanInventory(timespan_inventory)
>>> duplicate == timespan_inventory
True
\end{lstlisting}
\begin{lstlisting}
>>> duplicate is timespan_inventory
False
\end{lstlisting}
\begin{lstlisting}
>>> print(format(duplicate))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(0, 1),
            stop_offset=durationtools.Offset(16, 1),
            ),
        timespantools.Timespan(
            start_offset=durationtools.Offset(5, 1),
            stop_offset=durationtools.Offset(12, 1),
            ),
        timespantools.Timespan(
            start_offset=durationtools.Offset(-2, 1),
            stop_offset=durationtools.Offset(8, 1),
            ),
        timespantools.Timespan(
            start_offset=durationtools.Offset(15, 1),
            stop_offset=durationtools.Offset(20, 1),
            ),
        ]
    )
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Timespan inventories can be treated as timespans themselves, having a
start offset equal to the minimum start offset of any of their contained
timespans, and a stop offset equal to the maximum stop offset of any of their
contained timespans. Their start and stop offset properties allow them to
express a duration, as well as provide a concrete timespan representation.
Because timespan inventories can be modeled as timespans, they can even be
inserted into other timespan inventories, effectively masquerading as
timespans.

\begin{comment}
<abjad>
timespan_inventory.start_offset
timespan_inventory.stop_offset
timespan_inventory.duration
timespan_inventory.timespan
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespan_inventory.start_offset
Offset(-2, 1)
\end{lstlisting}
\begin{lstlisting}
>>> timespan_inventory.stop_offset
Offset(20, 1)
\end{lstlisting}
\begin{lstlisting}
>>> timespan_inventory.duration
Duration(22, 1)
\end{lstlisting}
\begin{lstlisting}
>>> timespan_inventory.timespan
Timespan(start_offset=Offset(-2, 1), stop_offset=Offset(20, 1))
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Because timespan inventories aggregate multiple timespans together,
they also provide properties for describing collective qualities of those
timespans. \emph{Contiguity} tests if every timespan in the inventory is
tangent to another timespan and also does not overlap any other timespan.
\emph{Overlap} tests if any timespan intersects any other timespan.
\emph{Well-formedness} tests that all timespans' durations are greater than 0.
A timespan inventory whose timespans are contiguous is necessarily also
non-overlapping.

\begin{comment}
<abjad>
timespan_inventory.all_are_contiguous
timespan_inventory.all_are_nonoverlapping
timespan_inventory.all_are_well_formed
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespan_inventory.all_are_contiguous
False
\end{lstlisting}
\begin{lstlisting}
>>> timespan_inventory.all_are_nonoverlapping
False
\end{lstlisting}
\begin{lstlisting}
>>> timespan_inventory.all_are_well_formed
True
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent The following timespan inventory's timespans are non-overlapping but
also non-contiguous.

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(0, 10),
    timespantools.Timespan(10, 20),
    timespantools.Timespan(30, 40),
    ])
show(timespan_inventory)
timespan_inventory.all_are_contiguous
timespan_inventory.all_are_nonoverlapping
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespan_inventory = timespantools.TimespanInventory([
...     timespantools.Timespan(0, 10),
...     timespantools.Timespan(10, 20),
...     timespantools.Timespan(30, 40),
...     ])
>>> show(timespan_inventory)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-a70ee4d73e99262ce1f5b0d756fdd03b.pdf}
\begin{lstlisting}
>>> timespan_inventory.all_are_contiguous
False
\end{lstlisting}
\begin{lstlisting}
>>> timespan_inventory.all_are_nonoverlapping
True
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent In contrast, this timespan inventory's timespans are both
non-overlapping and contiguous.

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(0, 10),
    timespantools.Timespan(10, 20),
    timespantools.Timespan(20, 30),
    ])
show(timespan_inventory)
timespan_inventory.all_are_contiguous
timespan_inventory.all_are_nonoverlapping
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespan_inventory = timespantools.TimespanInventory([
...     timespantools.Timespan(0, 10),
...     timespantools.Timespan(10, 20),
...     timespantools.Timespan(20, 30),
...     ])
>>> show(timespan_inventory)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-b3f55aeb2663321d68249a5274bfbcd4.pdf}
\begin{lstlisting}
>>> timespan_inventory.all_are_contiguous
True
\end{lstlisting}
\begin{lstlisting}
>>> timespan_inventory.all_are_nonoverlapping
True
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\subsection{Operations on timespan inventories} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Timespan inventories implement unioning, differencing and splitting methods
which parallel those implemented on timespans themselves. These methods map the
desired operation onto the contents of the inventory by, for example, splitting
every timespan contained in a given inventory by some offset. All of these
operations act in place. The intersection of all of the timespans in a timespan
inventory relative another timespan can be computed with the Python \texttt{\&}
operator, the same syntax used when operating on individual timespans, as
demonstrated in \autoref{sec:operations-on-timespans}.\footnote{ The call to
\texttt{show()} in the code example here contains the keyword argument
\texttt{range\_}. This argument controls the horizontal scaling and spacing of
the timespan illustration, allowing different illustrations to be aligned
against one another in a document even if the timespan inventories they
illustrate have different start and stop offsets. The name \texttt{range\_} --
with a trailing underscore -- is used instead of \texttt{range}, a
commonly-used built-in Python function. It is common practice in the Python
community to append underscores to names when they would otherwise conflict
with reserved words in Python's grammar or global built-in namespace. For
example, one would use the names \texttt{break\_}, \texttt{object\_},
\texttt{set\_} and \texttt{type\_} instead of the reserved word \texttt{break},
or the built-in names \texttt{object}, \texttt{set} and \texttt{type}.}

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(0, 16),
    timespantools.Timespan(5, 12),
    timespantools.Timespan(-2, 8),
    ])
show(timespan_inventory)
timespan_operand = timespantools.Timespan(6, 10)
result = timespan_inventory & timespan_operand
show(result, range_=(-2, 16))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespan_inventory = timespantools.TimespanInventory([
...     timespantools.Timespan(0, 16),
...     timespantools.Timespan(5, 12),
...     timespantools.Timespan(-2, 8),
...     ])
>>> show(timespan_inventory)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-9b42007deeb7b033ec210fb673117f16.pdf}
\begin{lstlisting}
>>> timespan_operand = timespantools.Timespan(6, 10)
>>> result = timespan_inventory & timespan_operand
>>> show(result, range_=(-2, 16))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-780a4eb96f5a2ab70bd4ee332cb4121f.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Likewise, the offsets bound by a given timespan can be subtracted
from all of the timespans in a timespan inventory, effectively cutting a hole
in that inventory's timeline.

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(0, 16),
    timespantools.Timespan(5, 12),
    timespantools.Timespan(-2, 8),
    ])
show(timespan_inventory)
timespan_operand = timespantools.Timespan(6, 10)
result = timespan_inventory - timespan_operand
show(result)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespan_inventory = timespantools.TimespanInventory([
...     timespantools.Timespan(0, 16),
...     timespantools.Timespan(5, 12),
...     timespantools.Timespan(-2, 8),
...     ])
>>> show(timespan_inventory)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-9b42007deeb7b033ec210fb673117f16.pdf}
\begin{lstlisting}
>>> timespan_operand = timespantools.Timespan(6, 10)
>>> result = timespan_inventory - timespan_operand
>>> show(result)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-093cdaf46f6b94446ef82999702eda1c.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent As with a single timespan and an offset, an entire timespan inventory
can be split into two separate inventories via the \texttt{split\_at\_offset()}
method.

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(0, 3),
    timespantools.Timespan(3, 6),
    timespantools.Timespan(6, 10),
    ])
show(timespan_inventory)
left, right = timespan_inventory.split_at_offset(4)
show(left, range_=(0, 10))
show(right, range_=(0, 10))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespan_inventory = timespantools.TimespanInventory([
...     timespantools.Timespan(0, 3),
...     timespantools.Timespan(3, 6),
...     timespantools.Timespan(6, 10),
...     ])
>>> show(timespan_inventory)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-dc1472aa97e4c5d099167a69c04c00f6.pdf}
\begin{lstlisting}
>>> left, right = timespan_inventory.split_at_offset(4)
>>> show(left, range_=(0, 10))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-316a5eb07621d2627596f5326675ad66.pdf}
\begin{lstlisting}
>>> show(right, range_=(0, 10))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-d06f648bf6c12655be313c93786f9531.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent The \texttt{TimespanInventory} class also provides the convenience
method \texttt{split\_at\_offsets()} for splitting an inventory by an arbitrary
number of offsets at once.

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(0, 3),
    timespantools.Timespan(3, 6),
    timespantools.Timespan(6, 10),
    ])
show(timespan_inventory)
shards = timespan_inventory.split_at_offsets((2, 4, 7))
for shard in shards:
    show(shard, range_=(0, 10))

</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespan_inventory = timespantools.TimespanInventory([
...     timespantools.Timespan(0, 3),
...     timespantools.Timespan(3, 6),
...     timespantools.Timespan(6, 10),
...     ])
>>> show(timespan_inventory)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-dc1472aa97e4c5d099167a69c04c00f6.pdf}
\begin{lstlisting}
>>> shards = timespan_inventory.split_at_offsets((2, 4, 7))
>>> for shard in shards:
...     show(shard, range_=(0, 10))
...
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-352a5111f35bca1be6c7ff229f3ccf80.pdf}\\
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-9a4dc172fcf9ff904688085a13b8056c.pdf}\\
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-5d9e98d9c3963af4d0e090991c6f03f1.pdf}\\
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-430eaccdb8c664619fba4358c2edaec4.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent The mutating methods described above modify a timespan inventory
by mapping some procedure against its contents and some outside timespan or
offset. However, timespan inventories may also be modified by applying a
procedure solely against the contents of the inventory itself, mapping each
timespan in the collection against each other timespan in that collection.
For example, a timespan inventory can be modified by computing the logical
\texttt{OR} -- the set union -- of every timespan in the inventory relative
every other timespan, effectively fusing all overlapping timespans together.

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(-2, 2),
    timespantools.Timespan(0, 10),
    timespantools.Timespan(5, 12),
    ])
show(timespan_inventory)
result = timespan_inventory.compute_logical_or()
print(format(result))
show(result)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespan_inventory = timespantools.TimespanInventory([
...     timespantools.Timespan(-2, 2),
...     timespantools.Timespan(0, 10),
...     timespantools.Timespan(5, 12),
...     ])
>>> show(timespan_inventory)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-ddb69738dd7250f40ad276ee1dd102e0.pdf}
\begin{lstlisting}
>>> result = timespan_inventory.compute_logical_or()
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(-2, 1),
            stop_offset=durationtools.Offset(12, 1),
            ),
        ]
    )
\end{lstlisting}
\begin{lstlisting}
>>> show(result)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-3f810a28d4b1a316daea09727ada2da7.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent A timespan inventory can also be modified by computing the logical
\texttt{AND} of every timespan in the inventory relative every other timespan.
This procedure leaves only those offsets where every single timespan
overlaps.

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(-2, 8),
    timespantools.Timespan(0, 10),
    timespantools.Timespan(5, 12),
    ])
show(timespan_inventory)
result = timespan_inventory.compute_logical_and()
print(format(result))
show(result, range_=(-2, 12))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespan_inventory = timespantools.TimespanInventory([
...     timespantools.Timespan(-2, 8),
...     timespantools.Timespan(0, 10),
...     timespantools.Timespan(5, 12),
...     ])
>>> show(timespan_inventory)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-e523698cbed9e80d8d2d668c81490c34.pdf}
\begin{lstlisting}
>>> result = timespan_inventory.compute_logical_and()
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(5, 1),
            stop_offset=durationtools.Offset(8, 1),
            ),
        ]
    )
\end{lstlisting}
\begin{lstlisting}
>>> show(result, range_=(-2, 12))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-6c46cea5de76a50856a8dcc8e4ac39c2.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Lastly, computing the in-place logical \texttt{XOR} removes all
overlap from the timespan inventory, leaving only those offsets occupied by
only one timespan.

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(-2, 2),
    timespantools.Timespan(0, 10),
    timespantools.Timespan(5, 12),
    ])
show(timespan_inventory)
result = timespan_inventory.compute_logical_xor()
print(format(result))
show(result, range_=(-2, 12))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespan_inventory = timespantools.TimespanInventory([
...     timespantools.Timespan(-2, 2),
...     timespantools.Timespan(0, 10),
...     timespantools.Timespan(5, 12),
...     ])
>>> show(timespan_inventory)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-ddb69738dd7250f40ad276ee1dd102e0.pdf}
\begin{lstlisting}
>>> result = timespan_inventory.compute_logical_xor()
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(-2, 1),
            stop_offset=durationtools.Offset(0, 1),
            ),
        timespantools.Timespan(
            start_offset=durationtools.Offset(2, 1),
            stop_offset=durationtools.Offset(5, 1),
            ),
        timespantools.Timespan(
            start_offset=durationtools.Offset(10, 1),
            stop_offset=durationtools.Offset(12, 1),
            ),
        ]
    )
\end{lstlisting}
\begin{lstlisting}
>>> show(result, range_=(-2, 12))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-579456be41236bcc4c6f3ef2d8b96dad.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Timespan \emph{partitioning} separates a timespan inventory into
groups of overlapping and optionally tangent timespans, aggregated into new
timespan inventories. This procedure allows composers to isolate contiguous
blocks of activity.

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(0, 10),
    timespantools.Timespan(5, 15),
    timespantools.Timespan(15, 20),
    timespantools.Timespan(25, 30),
    ])
show(timespan_inventory)
for shard in timespan_inventory.partition():
    show(shard, range_=(0, 30))

for shard in timespan_inventory.partition(include_tangent_timespans=True):
    show(shard, range_=(0, 30))

</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespan_inventory = timespantools.TimespanInventory([
...     timespantools.Timespan(0, 10),
...     timespantools.Timespan(5, 15),
...     timespantools.Timespan(15, 20),
...     timespantools.Timespan(25, 30),
...     ])
>>> show(timespan_inventory)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-529696911567b1b55dfc7ba216d6e59d.pdf}
\begin{lstlisting}
>>> for shard in timespan_inventory.partition():
...     show(shard, range_=(0, 30))
...
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-d6ab9da0c9636474e745d5612bb7bbbb.pdf}\\
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-b9c1bfc79717ac2213b1c37e123446e9.pdf}\\
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-0ab1942bf11e9b386e0aafdb9cd22edb.pdf}
\begin{lstlisting}
>>> for shard in timespan_inventory.partition(include_tangent_timespans=True):
...     show(shard, range_=(0, 30))
...
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-fa4b2285bd55e802c98578492760a139.pdf}\\
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-0ab1942bf11e9b386e0aafdb9cd22edb.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Conversely, \emph{explosion} separates a timespan inventory into one
or more new inventories in an attempt to limit the amount of overlap in each
resulting inventory. The number of output inventories can be left unspecified,
in which case explosion will generate as many inventories as necessary to
prevent overlap entirely in every resulting inventory.\footnote{ Explosion is
one of the techniques used to create timespan inventory illustrations,
providing the mechanism by which arbitrary collections of timespans are
automatically separated into non-overlapping inventories, which can then be
rendered graphically as \enquote{rows} of line segments.}.

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(-2, 8),
    timespantools.Timespan(-2, 1),
    timespantools.Timespan(0, 16),
    timespantools.Timespan(4, 7),
    timespantools.Timespan(4, 11),
    timespantools.Timespan(5, 12),
    timespantools.Timespan(11, 13),
    timespantools.Timespan(14, 17),
    timespantools.Timespan(15, 20),
    ])
show(timespan_inventory)
for shard in timespan_inventory.explode():
    show(shard, range_=(-2, 20))

</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespan_inventory = timespantools.TimespanInventory([
...     timespantools.Timespan(-2, 8),
...     timespantools.Timespan(-2, 1),
...     timespantools.Timespan(0, 16),
...     timespantools.Timespan(4, 7),
...     timespantools.Timespan(4, 11),
...     timespantools.Timespan(5, 12),
...     timespantools.Timespan(11, 13),
...     timespantools.Timespan(14, 17),
...     timespantools.Timespan(15, 20),
...     ])
>>> show(timespan_inventory)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-359034e786ace6978d7c8d20de502af4.pdf}
\begin{lstlisting}
>>> for shard in timespan_inventory.explode():
...     show(shard, range_=(-2, 20))
...
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-5d4e226e47ac141094425b650893d8a1.pdf}\\
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-6750ebe2d0c1709b9fe1980042e00494.pdf}\\
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-f3d09a846f0cc1685cd3cd6921b42e8f.pdf}\\
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-47efa4599636cbf16a928f0de48493c3.pdf}\\
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-0a98e35488893ff699bd7277aedd58a2.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent The number of output inventories can also be set explicitly, in which
case explosion will attempt to limit the amount of overlap as much as possible
while maintaining a similar level of overlap or density in each output
inventory.

\begin{comment}
<abjad>
for shard in timespan_inventory.explode(inventory_count=2):
    show(shard, range_=(-2, 20))

</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> for shard in timespan_inventory.explode(inventory_count=2):
...     show(shard, range_=(-2, 20))
...
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-26e209ed37cb9f072b01f0ec5988e380.pdf}\\
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-d2712905433a02c121f7cb8c4a6d47b6.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

The procedures outlined above provide high-level tools for interacting with
large numbers of timespans at once. All of the techniques described in
\autoref{chap:a-model-of-composition} with regards to Consort's score
interpretation stage -- timespan consolidation, cascading overlap
resolution, multiplexing multiple inventories into one, demultiplexing one
inventory into many, and so forth -- build on and extend these techniques.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Annotated timespans in Consort}
\label{sec:annotated-timespans-in-consort}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

While the above data structures and operations are potentially very useful, a
larger question remains: how can composers create enough timespans, and in
various patterns, to be musically interesting? Consort approaches this problem
by providing a collection of factory classes -- \emph{timespan-makers} -- which
can be configured and called to create arbitrarily large amounts of timespans.
However, before turning to a detailed discussion of timespan-makers, we must
first describe the products of the timespan themselves: Consort's annotated
timespan subclasses.

Consort provides two separate timespan subclasses which are integral, if
transient, components of its score interpretation stage: the
\texttt{PerformedTimespan} and \texttt{SilentTimespan} classes. These classes
are never created \enquote{by hand} during Consort's specification stage --
this is, explicitly instantiated by a composer while specifying a score segment
--, but are instead generated as transitory objects during interpretation.
Consort uses \texttt{PerformedTimespan} objects to specify locations in the
score timeline where some active musical material should appear, while
\texttt{SilentTimespan} objects specify tacet passages.

As will be described in more detail in \autoref{chap:a-model-of-composition},
Consort requires composers to specify musical materials in \emph{layers}, and
to specify specifically in which voice contexts in the score -- vertically --
that material should occur in. During the course of interpretation, Consort
separates out generated timespans by voice name and layer into separate
timespan inventories, and then progressively masks out timespans in timespan
inventories with lower layer numbers by those timespans with higher layer
numbers. One can imagine this process as analogous to the use of opaque
overlapping layers in image editing software. Both the
\texttt{PerformedTimespan} and \texttt{SilentTimespan} classes provide
configurable properties for layer and voice name, in addition to the start
offset and stop offset properties provided by their parent \texttt{Timespan}
class. These properties allow the processes that generate them to record
\emph{when} they were created, as well as \emph{where} the should appear in the
score, should they survive the masking process.

\begin{comment}
<abjad>
performed_timespan = consort.PerformedTimespan(
    layer=1,
    start_offset=(1, 2),
    stop_offset=(7, 8),
    voice_name='Clarinet Voice',
    )
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> performed_timespan = consort.PerformedTimespan(
...     layer=1,
...     start_offset=(1, 2),
...     stop_offset=(7, 8),
...     voice_name='Clarinet Voice',
...     )
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Unlike performed timespans, silent timespans have no explicit reality
in score, but can still be created for a particular voice context and layer.
They act to simply erase any timespan in a lower layer through masking. This
allows timespan-making processes to demand not only when a musical event should
happen, but also when musical events should \emph{not}. For example, silent
timespans make it possible to demand silence before music events involving
instrument or mallet changes.

\begin{comment}
<abjad>
silent_timespan = consort.SilentTimespan(
    layer=2,
    start_offset=Offset(0, 1),
    stop_offset=Offset(1, 4),
    voice_name='Oboe Voice',
    )
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> silent_timespan = consort.SilentTimespan(
...     layer=2,
...     start_offset=Offset(0, 1),
...     stop_offset=Offset(1, 4),
...     voice_name='Oboe Voice',
...     )
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Performed timespans possess a number of other configurable properties
used during score interpretation. These include \texttt{minimum\_duration} --
used to force erasure of timespans considered too short, often because they
have been partially masked, \texttt{music\_specifier} -- used to attach
information about how to generate notation from a timespan, \texttt{divisions}
-- a memento of the original duration structure of a contiguous sequence of
performed timespans which have been consolidated into a single performed
timespan after the masking process ends, and \texttt{music} -- used to attach
any generated notation prior to maquetting.

\begin{comment}
<abjad>
performed_timespan = consort.PerformedTimespan(
    layer=1,
    minimum_duration=Duration(1, 8),
    music_specifier=consort.MusicSpecifier(),
    start_offset=Offset(1, 4),
    stop_offset=Offset(2, 1),
    voice_name='Violin 1 LH Voice',
    )
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> performed_timespan = consort.PerformedTimespan(
...     layer=1,
...     minimum_duration=Duration(1, 8),
...     music_specifier=consort.MusicSpecifier(),
...     start_offset=Offset(1, 4),
...     stop_offset=Offset(2, 1),
...     voice_name='Violin 1 LH Voice',
...     )
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent All of the above properties are explained in more depth in
\autoref{chap:a-model-of-composition}, in context of Consort's interpretation
process. For the sake of demonstrating timespan-creation principles pithily,
the \texttt{music\_specifier} property of any performed timespan can be set to
an arbitrary object such as Python's \texttt{None} rather than a
\texttt{MusicSpecifier} instance as actually done in practice.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Timespan-makers}
\label{sec:timespan-makers}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Consort provides a family of factory classes for producing timespans, each
implementing a different strategy for populating timespan inventories, but all
unified via the same callable interface. Timespan-makers take as input a mapping of
voice-names to \emph{music specifiers} -- arbitrary objects specifying how a
given timespan might be rendered as notation --, a \emph{target} timespan
indicating the minimum and maximum start offsets of any timespan created by the
timespan-maker, as well as an optional timespan inventory to modify in-place
and a \emph{layer} identifier indicating in which pass a particular timespan
was created,\footnote{Layer identifiers allow timespans to be sorted not only
by their position in time or by their associated voice name, but also by at
which point -- which \emph{layer} -- during some compositional process they
were created. Layer ordering allows masking processes to mask \enquote{earlier}
timespans with \enquote{later} ones.} and produce a timespan inventory as
output.

Timespan-makers fall into two broad categories: independent and dependent.
Independent timespan-makers create timespans without regard for any
pre-existing timespans, and therefore do not require being called with a
timespan inventory instance. Dependent timespan-makers create their timespans
based on the contents of a pre-existing timespan inventory, basing their output
on various aspects of the structure of their input.

All timespan-makers can be configured with \texttt{padding} and
\texttt{timespan\_specifier} keywords. Padding allows the timespan-maker to
force \enquote{silence} -- in the form of \texttt{SilentTimespan} objects --
around the beginnings and ends of contiguous groups of timespans it creates.
Timespan specifiers provide templates for some of the configurable properties
specific to performed timespans, such as \texttt{minimum\_duration} and
\texttt{forbid\_splitting}.

\subsection{Flooded timespan-makers} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\todo[inline]{\textbf{TODO:} Find a citation for flood fill. MacPaint?}

Flooded timespan-makers are perhaps the simplest in the timespan-maker class
family. Their name derives from ubiquitous graphic-design \enquote{flood fill}
tools, used for filling an entire connected area. Flooded timespan-makers
create one timespan for each voice in the input voice-name-to-music-specifier
mapping, filling the entirety of the provide target timespan from beginning to
end.

The following flooded timespan-maker will create a timespan inventory populated
by a single performed timespan associated with a \enquote{Violin Voice}
context, completely filling the span of 1/4 to 11/8.

\begin{comment}
<abjad>
music_specifiers = {'Violin Voice': 'violin music'}
target_timespan = timespantools.Timespan((1, 4), (11, 8))
flooded_timespan_maker = consort.FloodedTimespanMaker()
timespan_inventory = flooded_timespan_maker(
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
print(format(timespan_inventory))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> music_specifiers = {'Violin Voice': 'violin music'}
>>> target_timespan = timespantools.Timespan((1, 4), (11, 8))
>>> flooded_timespan_maker = consort.FloodedTimespanMaker()
>>> timespan_inventory = flooded_timespan_maker(
...     music_specifiers=music_specifiers,
...     target_timespan=target_timespan,
...     )
>>> print(format(timespan_inventory))
timespantools.TimespanInventory(
    [
        consort.tools.PerformedTimespan(
            start_offset=durationtools.Offset(1, 4),
            stop_offset=durationtools.Offset(11, 8),
            music_specifier='violin music',
            voice_name='Violin Voice',
            ),
        ]
    )
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Adding a second entry to the music specifier mapping results in two
timespans in the output. Likewise, calling the timespan-maker with a
\texttt{layer} keyword configures the output timespans with that layer number.
The layer is indicated in the illustration just above and to the right of the
beginning of each timespan.

\begin{comment}
<abjad>
music_specifiers = {
    'Violin Voice': 'violin music',
    'Cello Voice': 'cello music',
    }
timespan_inventory = flooded_timespan_maker(
    layer=3,
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
print(format(timespan_inventory))
show(timespan_inventory, key='voice_name')
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> music_specifiers = {
...     'Violin Voice': 'violin music',
...     'Cello Voice': 'cello music',
...     }
>>> timespan_inventory = flooded_timespan_maker(
...     layer=3,
...     music_specifiers=music_specifiers,
...     target_timespan=target_timespan,
...     )
>>> print(format(timespan_inventory))
timespantools.TimespanInventory(
    [
        consort.tools.PerformedTimespan(
            start_offset=durationtools.Offset(1, 4),
            stop_offset=durationtools.Offset(11, 8),
            layer=3,
            music_specifier='cello music',
            voice_name='Cello Voice',
            ),
        consort.tools.PerformedTimespan(
            start_offset=durationtools.Offset(1, 4),
            stop_offset=durationtools.Offset(11, 8),
            layer=3,
            music_specifier='violin music',
            voice_name='Violin Voice',
            ),
        ]
    )
\end{lstlisting}
\begin{lstlisting}
>>> show(timespan_inventory, key='voice_name')
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-f746878bb77dae0baec37bbeb02cb34f.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Configuring the timespan-maker with padding creates silent timespans
around the beginning and end of each group of output timespans on a per-voice
basis. The timespan-maker will also configure these silent timespans with any
specified layer number. Silent timespans are illustrated with dashed line, for
clarity.

\begin{comment}
<abjad>
flooded_timespan_maker = consort.FloodedTimespanMaker(
    padding=Duration(1, 4),
    timespan_specifier=consort.TimespanSpecifier(
        minimum_duration=Duration(1, 8),
        ),
    )
timespan_inventory = flooded_timespan_maker(
    layer=5,
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
print(format(timespan_inventory))
show(timespan_inventory, key='voice_name')
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> flooded_timespan_maker = consort.FloodedTimespanMaker(
...     padding=Duration(1, 4),
...     timespan_specifier=consort.TimespanSpecifier(
...         minimum_duration=Duration(1, 8),
...         ),
...     )
>>> timespan_inventory = flooded_timespan_maker(
...     layer=5,
...     music_specifiers=music_specifiers,
...     target_timespan=target_timespan,
...     )
>>> print(format(timespan_inventory))
timespantools.TimespanInventory(
    [
        consort.tools.SilentTimespan(
            start_offset=durationtools.Offset(0, 1),
            stop_offset=durationtools.Offset(1, 4),
            layer=5,
            voice_name='Violin Voice',
            ),
        consort.tools.SilentTimespan(
            start_offset=durationtools.Offset(0, 1),
            stop_offset=durationtools.Offset(1, 4),
            layer=5,
            voice_name='Cello Voice',
            ),
        consort.tools.PerformedTimespan(
            start_offset=durationtools.Offset(1, 4),
            stop_offset=durationtools.Offset(11, 8),
            layer=5,
            minimum_duration=durationtools.Duration(1, 8),
            music_specifier='cello music',
            voice_name='Cello Voice',
            ),
        consort.tools.PerformedTimespan(
            start_offset=durationtools.Offset(1, 4),
            stop_offset=durationtools.Offset(11, 8),
            layer=5,
            minimum_duration=durationtools.Duration(1, 8),
            music_specifier='violin music',
            voice_name='Violin Voice',
            ),
        consort.tools.SilentTimespan(
            start_offset=durationtools.Offset(11, 8),
            stop_offset=durationtools.Offset(13, 8),
            layer=5,
            voice_name='Violin Voice',
            ),
        consort.tools.SilentTimespan(
            start_offset=durationtools.Offset(11, 8),
            stop_offset=durationtools.Offset(13, 8),
            layer=5,
            voice_name='Cello Voice',
            ),
        ]
    )
\end{lstlisting}
\begin{lstlisting}
>>> show(timespan_inventory, key='voice_name')
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-b922fd9d63818b0a3f22a0377c8e95d3.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\subsection{Talea timespan-makers} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Consort's \texttt{TaleaTimespanMaker} class creates rich timespan textures
through the use of \emph{talea} -- infinitely cyclic duration patterns. Abjad
implements the concept of talea via the \texttt{Talea} class in its
\texttt{rhythmmakertools} library. \texttt{Talea} defines a sequence of
durations in terms of a finite sequence of numerators paired with a
denominator. Once defined, they can be iterated over and indexed like an
infinite sequence.

\begin{comment}
<abjad>
talea = rhythmmakertools.Talea(
    counts=[1, 2, 3, 4],
    denominator=16,
    )
for index in range(10):
    talea[index]

</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> talea = rhythmmakertools.Talea(
...     counts=[1, 2, 3, 4],
...     denominator=16,
...     )
>>> for index in range(10):
...     talea[index]
...
NonreducedFraction(1, 16)
NonreducedFraction(2, 16)
NonreducedFraction(3, 16)
NonreducedFraction(4, 16)
NonreducedFraction(1, 16)
NonreducedFraction(2, 16)
NonreducedFraction(3, 16)
NonreducedFraction(4, 16)
NonreducedFraction(1, 16)
NonreducedFraction(2, 16)
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Talea timespan-makers make use of talea to control patterns of
performed duration and silences. These timespan-makers can create timespan in
\emph{synchronized} or \emph{unsynchronized} fashions. Unsynchronized timespan
generation proceeds voice-by-voice through the input
voice-name-to-music-specifier mapping, creating timespans from the start of the
target timespan until its stop, then wrapping around to the next voice. Such
unsynchronized timespan creation is ideal for creating massed textures of
seemingly-unrelated timespans. Careful management of silence patterns and
contiguous timespan grouping during synchronized creation can create dense,
overlapping textures or sparse, pointillistic ones. Contrastingly, synchronized
creation provides a mechanism for creating moments of shared attack across
voices, followed by shared silences.

All of the timespan inventories created in the following talea
timespan-maker examples will use the same music specifier mapping and target
timespan. An ordered dictionary from Python's \texttt{collections} module
guarantees that the timespan-makers process the music specifier entries in the
same order, from \enquote{Voice 1} through \enquote{Voice 4}.

\begin{comment}
<abjad>
import collections
music_specifiers = collections.OrderedDict([
    ('Voice 1', None),
    ('Voice 2', None),
    ('Voice 3', None),
    ('Voice 4', None),
    ])
target_timespan = timespantools.Timespan(0, (19, 4))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> import collections
>>> music_specifiers = collections.OrderedDict([
...     ('Voice 1', None),
...     ('Voice 2', None),
...     ('Voice 3', None),
...     ('Voice 4', None),
...     ])
>>> target_timespan = timespantools.Timespan(0, (19, 4))
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Without any manual configuration, talea timespan-makers generate
unsynchronized 1-length groups of 1/4-duration timespans, separated by
1/4-duration silences, creating the appearance of synchronization across
voices.

\begin{comment}
<abjad>
talea_timespan_maker = consort.TaleaTimespanMaker()
print(format(talea_timespan_maker))
result = talea_timespan_maker(
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
show(result, key='voice_name')
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> talea_timespan_maker = consort.TaleaTimespanMaker()
>>> print(format(talea_timespan_maker))
consort.tools.TaleaTimespanMaker(
    playing_talea=rhythmmakertools.Talea(
        counts=(4,),
        denominator=16,
        ),
    playing_groupings=(1,),
    repeat=True,
    silence_talea=rhythmmakertools.Talea(
        counts=(4,),
        denominator=16,
        ),
    step_anchor=Right,
    synchronize_groupings=False,
    synchronize_step=False,
    )
\end{lstlisting}
\begin{lstlisting}
>>> result = talea_timespan_maker(
...     music_specifiers=music_specifiers,
...     target_timespan=target_timespan,
...     )
>>> show(result, key='voice_name')
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-ebfd8c880740e50dc088f6304e30f973.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Changing the talea timespan-maker's \texttt{playing\_talea} from a
series of 1/4-durations to 1/4, 2/4, 3/4, 4/4 reveals the timespan-maker's
voice-wrapping behavior. Note how \enquote{Voice 1}'s timespans receive the
durations 1/4, 2/4, 3/4, 4/4, 1/4 and 2/4. \enquote{Voice 2} continues the
duration sequence with 3/4, 4/4 and so forth. The playing-duration talea
continues to wrap around the end of each voice's timespans to the beginning of
the next voice's.

\begin{comment}
<abjad>
talea_timespan_maker = new(
    talea_timespan_maker,
    playing_talea=rhythmmakertools.Talea(
        counts=(1, 2, 3, 4),
        denominator=4,
        )
    )
result = talea_timespan_maker(
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
show(result, key='voice_name')
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> talea_timespan_maker = new(
...     talea_timespan_maker,
...     playing_talea=rhythmmakertools.Talea(
...         counts=(1, 2, 3, 4),
...         denominator=4,
...         )
...     )
>>> result = talea_timespan_maker(
...     music_specifiers=music_specifiers,
...     target_timespan=target_timespan,
...     )
>>> show(result, key='voice_name')
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-a6702ee36d43cf93ba5728eaa6773fd1.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent The talea timespan-maker's \texttt{playing\_groupings} property
controls how many timespans are created together as contiguous groups. When a
grouping would run beyond the stop offset provided by the target timespan, that
grouping's length is chosen again for the first timespan group of the next
voice's timespans. Note how \enquote{Voice 2}'s final timespan, from 13/4 to
4/1, should -- according to the following talea timespan-maker's groupings
pattern -- begin a group of length 2. Because that grouping would run beyond
the target timespan's 19/4 stop offset, the following voice's first timespan
group receives the 2-length grouping instead.

\begin{comment}
<abjad>
talea_timespan_maker = new(
    talea_timespan_maker,
    playing_groupings=(1, 2),
    )
result = talea_timespan_maker(
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
show(result, key='voice_name')
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> talea_timespan_maker = new(
...     talea_timespan_maker,
...     playing_groupings=(1, 2),
...     )
>>> result = talea_timespan_maker(
...     music_specifiers=music_specifiers,
...     target_timespan=target_timespan,
...     )
>>> show(result, key='voice_name')
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-7f1b78377186311548aec873e02a00b0.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Reconfiguring the above talea timespan-maker with a different
\texttt{silence\_talea} produces patterned variations in the durations of
silences between timespan groups.

\begin{comment}
<abjad>
talea_timespan_maker = new(
    talea_timespan_maker,
    silence_talea=rhythmmakertools.Talea(
        counts=(3, 1, 1),
        denominator=8,
        ),
    )
result = talea_timespan_maker(
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
show(result, key='voice_name')
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> talea_timespan_maker = new(
...     talea_timespan_maker,
...     silence_talea=rhythmmakertools.Talea(
...         counts=(3, 1, 1),
...         denominator=8,
...         ),
...     )
>>> result = talea_timespan_maker(
...     music_specifiers=music_specifiers,
...     target_timespan=target_timespan,
...     )
>>> show(result, key='voice_name')
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-e7f5987861858d91a2809a56e791d1d1.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Likewise, changing the \texttt{initial\_silence\_talea} produces
varying amounts of silence at the beginning of each voice.

\begin{comment}
<abjad>
talea_timespan_maker = new(
    talea_timespan_maker,
    initial_silence_talea=rhythmmakertools.Talea(
        counts=(0, 1, 3),
        denominator=8,
        ),
    )
result = talea_timespan_maker(
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
show(result, key='voice_name')
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> talea_timespan_maker = new(
...     talea_timespan_maker,
...     initial_silence_talea=rhythmmakertools.Talea(
...         counts=(0, 1, 3),
...         denominator=8,
...         ),
...     )
>>> result = talea_timespan_maker(
...     music_specifiers=music_specifiers,
...     target_timespan=target_timespan,
...     )
>>> show(result, key='voice_name')
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-78aaaa427152e614120861752f4366e1.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Talea timespan-makers also provide for transformations derived from
the timespan inventory class itself. The \texttt{reflect} keyword configures
the timespan-maker to reflect its output timespan inventory around its own
axis, creating a \enquote{mirror image}.

\begin{comment}
<abjad>
talea_timespan_maker = new(
    talea_timespan_maker,
    reflect=True,
    )
result = talea_timespan_maker(
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
show(result, key='voice_name')
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> talea_timespan_maker = new(
...     talea_timespan_maker,
...     reflect=True,
...     )
>>> result = talea_timespan_maker(
...     music_specifiers=music_specifiers,
...     target_timespan=target_timespan,
...     )
>>> show(result, key='voice_name')
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-54d2fa8b64e488a84ee52a488caf28df.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Synchronized talea timespan-makers can be created simply by
configuring a new timespan-maker with its \texttt{synchronize\_step} flag set
to true. This option causes the timespan-maker to create all of the timespans
in every voice at once, then select some amount of silence between the end of
that vertically-synchronized group and the beginning of the next. Note here how
the duration of each timespan follows the timespan-maker's 1/4, 2/4, 3/4, 4/4,
5/4 pattern not from left-to-right by voice, but top-to-bottom by voice and
then left-to-right. The silence durations between these synchronized groups are
calculated from the end of the longest timespan in each group to the beginning
of the next group. Therefore the second group starts at 1/1 because the first
silence duration is 4/8 and the first group stops at 1/2. Similarly, the third
group starts at 5/2 (20/8) because the second silence duration is 7/8 and the
second group ended at 13/8. This silence \emph{stepping} can also be calculated
from the beginning of one group to the next, rather than from the end of one to
the beginning of the next, by changing the timespan-maker's
\texttt{step\_anchor} property from \texttt{Right} to \texttt{Left}. Such a
change helps guarantee the timing of initial attacks across synchronized
groups.

\begin{comment}
<abjad>
synchronized_talea_timespan_maker = consort.TaleaTimespanMaker(
    playing_talea=rhythmmakertools.Talea(
        counts=(1, 2, 3, 4, 5),
        denominator=8,
        ),
    silence_talea=rhythmmakertools.Talea(
        counts=(4, 7),
        denominator=8,
        ),
    synchronize_step=True,
    )
result = synchronized_talea_timespan_maker(
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
show(result, key='voice_name')
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> synchronized_talea_timespan_maker = consort.TaleaTimespanMaker(
...     playing_talea=rhythmmakertools.Talea(
...         counts=(1, 2, 3, 4, 5),
...         denominator=8,
...         ),
...     silence_talea=rhythmmakertools.Talea(
...         counts=(4, 7),
...         denominator=8,
...         ),
...     synchronize_step=True,
...     )
>>> result = synchronized_talea_timespan_maker(
...     music_specifiers=music_specifiers,
...     target_timespan=target_timespan,
...     )
>>> show(result, key='voice_name')
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-780df86ad9a6fb2424e5754f4ed917da.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Initial silences behave differently in synchronized talea
timespan-makers than with unsynchronized talea timespan-makers. Rather than
adding silences only at the very beginning of each voice's timespans, silences
are determined for each voice at the beginning of each synchronized group.

\begin{comment}
<abjad>
synchronized_talea_timespan_maker = new(
    synchronized_talea_timespan_maker,
    initial_silence_talea=rhythmmakertools.Talea(
        counts=(0, 1, 2),
        denominator=8,
        ),
    )
result = synchronized_talea_timespan_maker(
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
show(result, key='voice_name')
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> synchronized_talea_timespan_maker = new(
...     synchronized_talea_timespan_maker,
...     initial_silence_talea=rhythmmakertools.Talea(
...         counts=(0, 1, 2),
...         denominator=8,
...         ),
...     )
>>> result = synchronized_talea_timespan_maker(
...     music_specifiers=music_specifiers,
...     target_timespan=target_timespan,
...     )
>>> show(result, key='voice_name')
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-baaa4c6ab62859d41728fefd33b4a778.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent And unlike flooded timespan-makers, padding durations are included in
the start offset and step duration calculations for talea timespan-makers.

\begin{comment}
<abjad>
synchronized_talea_timespan_maker = new(
    synchronized_talea_timespan_maker,
    padding=(1, 8),
    )
result = synchronized_talea_timespan_maker(
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
show(result, key='voice_name')
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> synchronized_talea_timespan_maker = new(
...     synchronized_talea_timespan_maker,
...     padding=(1, 8),
...     )
>>> result = synchronized_talea_timespan_maker(
...     music_specifiers=music_specifiers,
...     target_timespan=target_timespan,
...     )
>>> show(result, key='voice_name')
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-d2009fad335e628aa2ba715e8ff1bc54.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\subsection{Dependent timespan-makers} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Dependent timespan-makers create timespans based on the disposition of
timespans in an input timespan inventory, selecting the start and stop offsets
of their generated timespans by filtering and inspecting timespans from the
input according to their voice name or music specifier label. This behavior
helps model how timespans used to generate phrasing for a pianist's pedaling
voice can be derived by selecting only those timespans in a timespan inventory
for entire ensemble which pertain to the pianists right and left-hand voices.

Consider the following timespan inventory, comprised of overlapping and
non-overlapping timespans created for the contexts \enquote{Voice 1},
\enquote{Voice 2} and \enquote{Ignored Voice}.

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    consort.PerformedTimespan(0, 10, voice_name='Voice 1'),
    consort.PerformedTimespan(0, 10, voice_name='Voice 2'),
    consort.PerformedTimespan(5, 20, voice_name='Ignored Voice'),
    consort.PerformedTimespan(10, 20, voice_name='Voice 1'),
    consort.PerformedTimespan(15, 35, voice_name='Voice 2'),
    consort.PerformedTimespan(25, 30, voice_name='Voice 1'),
    consort.PerformedTimespan(30, 45, voice_name='Ignored Voice'),
    consort.PerformedTimespan(40, 45, voice_name='Voice 2'),
    consort.PerformedTimespan(45, 75, voice_name='Voice 2'),
    consort.PerformedTimespan(50, 80, voice_name='Ignored Voice'),
    consort.PerformedTimespan(50, 60, voice_name='Voice 1'),
    ])
show(timespan_inventory, key='voice_name')
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespan_inventory = timespantools.TimespanInventory([
...     consort.PerformedTimespan(0, 10, voice_name='Voice 1'),
...     consort.PerformedTimespan(0, 10, voice_name='Voice 2'),
...     consort.PerformedTimespan(5, 20, voice_name='Ignored Voice'),
...     consort.PerformedTimespan(10, 20, voice_name='Voice 1'),
...     consort.PerformedTimespan(15, 35, voice_name='Voice 2'),
...     consort.PerformedTimespan(25, 30, voice_name='Voice 1'),
...     consort.PerformedTimespan(30, 45, voice_name='Ignored Voice'),
...     consort.PerformedTimespan(40, 45, voice_name='Voice 2'),
...     consort.PerformedTimespan(45, 75, voice_name='Voice 2'),
...     consort.PerformedTimespan(50, 80, voice_name='Ignored Voice'),
...     consort.PerformedTimespan(50, 60, voice_name='Voice 1'),
...     ])
>>> show(timespan_inventory, key='voice_name')
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-7bde2c56ce3e058e09f98d245ffed630.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent A dependent timespan-maker can be configured to depend on timespans
created for the \enquote{Voice 1} and \enquote{Voice 2} contexts by specifying
a tuple of voice names during instantiation. Passing the previously defined
timespan inventory as an argument when calling the dependent timespan-maker
adds the newly-created dependent timespans to it. For the sake of brevity and
because timespan-makers modify any timespan inventory passed as an argument to
\texttt{\_\_call\_\_()} in-place, we pass a copy of this timespan inventory,
created via a call to \texttt{new()}, instead of the original.

\begin{comment}
<abjad>
music_specifiers = {'Dependent Voice': None}
dependent_timespan_maker = consort.DependentTimespanMaker(
    voice_names=(
        'Voice 1',
        'Voice 2',
        )
    )
result = dependent_timespan_maker(
    music_specifiers=music_specifiers,
    timespan_inventory=new(timespan_inventory),
    )
show(result, key='voice_name')
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> music_specifiers = {'Dependent Voice': None}
>>> dependent_timespan_maker = consort.DependentTimespanMaker(
...     voice_names=(
...         'Voice 1',
...         'Voice 2',
...         )
...     )
>>> result = dependent_timespan_maker(
...     music_specifiers=music_specifiers,
...     timespan_inventory=new(timespan_inventory),
...     )
>>> show(result, key='voice_name')
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-d84a2c5076bc15e57217374c119dbda8.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Note how the above timespan inventory shows the timespans for
\enquote{Dependent Voice} outlining the start and stop offset for partitioned
shards of the timespans for \enquote{Voice 1} and \enquote{Voice 2}, but
ignoring the boundaries outlined by the timespans for the \enquote{Ignored
Voice} context. Dependent timespans first select all timespans from their input
timespan inventory matching their voice-names criteria, then partition them
into shards in order to determine which offsets to use for timespan creation.
Partitioning guarantees that the created dependent timespans do not exceed the
bounds of the timespans they depend upon.

Configuring the dependent timespan-maker with its
\texttt{include\_inner\_starts} flag set to true causes it to create contiguous
groups of dependent timespans, as though splitting at every moment when a
timespan it depends upon starts.

\begin{comment}
<abjad>
new_dependent_timespan_maker = new(
    dependent_timespan_maker,
    include_inner_starts=True,
    )
result = new_dependent_timespan_maker(
    music_specifiers=music_specifiers,
    timespan_inventory=new(timespan_inventory),
    )
show(result, key='voice_name')
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> new_dependent_timespan_maker = new(
...     dependent_timespan_maker,
...     include_inner_starts=True,
...     )
>>> result = new_dependent_timespan_maker(
...     music_specifiers=music_specifiers,
...     timespan_inventory=new(timespan_inventory),
...     )
>>> show(result, key='voice_name')
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-655c639619ff0812649e0d2c34a28117.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Likewise, the \texttt{include\_inner\_stops} flag causes the
dependent timespan-maker to take into account the stop offsets of any timespan
it depends upon.

\begin{comment}
<abjad>
new_dependent_timespan_maker = new(
    dependent_timespan_maker,
    include_inner_stops=True,
    )
result = new_dependent_timespan_maker(
    music_specifiers=music_specifiers,
    timespan_inventory=new(timespan_inventory),
    )
show(result, key='voice_name')
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> new_dependent_timespan_maker = new(
...     dependent_timespan_maker,
...     include_inner_stops=True,
...     )
>>> result = new_dependent_timespan_maker(
...     music_specifiers=music_specifiers,
...     timespan_inventory=new(timespan_inventory),
...     )
>>> show(result, key='voice_name')
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-7bfff0fff12a4fed37c9d3b032378ee4.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Both options can be combined together, resulting in dependent
timespans outlining all offsets from the collection of timespans they depend
upon.

\begin{comment}
<abjad>
new_dependent_timespan_maker = new(
    dependent_timespan_maker,
    include_inner_starts=True,
    include_inner_stops=True,
    )
result = new_dependent_timespan_maker(
    music_specifiers=music_specifiers,
    timespan_inventory=new(timespan_inventory),
    )
show(result, key='voice_name')
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> new_dependent_timespan_maker = new(
...     dependent_timespan_maker,
...     include_inner_starts=True,
...     include_inner_stops=True,
...     )
>>> result = new_dependent_timespan_maker(
...     music_specifiers=music_specifiers,
...     timespan_inventory=new(timespan_inventory),
...     )
>>> show(result, key='voice_name')
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-7deb68434b102f489e182b7dd824f01a.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Note that in the previous dependent timespan-maker examples no target
timespan was specified. When passed a non-empty timespan inventory during
calling, timespan-makers can treat that inventory's timespan as their target
timespan if no target timespan was specified explicitly. However, passing a
target timespan to a dependent timespan-maker causes that timespan-maker to
perform a logical \texttt{AND} of the target timespan with any selected
timespans in the input inventory.

\begin{comment}
<abjad>
result = new_dependent_timespan_maker(
    music_specifiers=music_specifiers,
    target_timespan=timespantools.Timespan(17, 58),
    timespan_inventory=new(timespan_inventory),
    )
show(result, key='voice_name', range_=(0, 75))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> result = new_dependent_timespan_maker(
...     music_specifiers=music_specifiers,
...     target_timespan=timespantools.Timespan(17, 58),
...     timespan_inventory=new(timespan_inventory),
...     )
>>> show(result, key='voice_name', range_=(0, 75))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-eed8f0800343d386847212c7a2dd79e8.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Finally, dependent timespan-makers are capable of performing simple
transformations on the offsets they extract from their input timespan
inventory. Rotation allows the timespan-maker to rotate the durations outlined
by the offsets extracted from the timespans they select. Specifying a rotation
index of 1 causes each created group of dependent timespans to rotate its
internal durations by that index.

\begin{comment}
<abjad>
rotated_dependent_timespan_maker = new(
    new_dependent_timespan_maker,
    rotation_indices=(1,),
    )
result = rotated_dependent_timespan_maker(
    music_specifiers=music_specifiers,
    timespan_inventory=new(timespan_inventory),
    )
show(result, key='voice_name', range_=(0, 75))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> rotated_dependent_timespan_maker = new(
...     new_dependent_timespan_maker,
...     rotation_indices=(1,),
...     )
>>> result = rotated_dependent_timespan_maker(
...     music_specifiers=music_specifiers,
...     timespan_inventory=new(timespan_inventory),
...     )
>>> show(result, key='voice_name', range_=(0, 75))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-823ed74b320470ddf828bf90bdd24b28.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent More than one rotation index can be specified, allowing for each
group of dependent timespans -- as created from each shard of the partitioned
selected timespans -- to be rotated independently.

\begin{comment}
<abjad>
rotated_dependent_timespan_maker = new(
    new_dependent_timespan_maker,
    rotation_indices=(1, -1),
    )
result = rotated_dependent_timespan_maker(
    music_specifiers=music_specifiers,
    timespan_inventory=new(timespan_inventory),
    )
show(result, key='voice_name', range_=(0, 75))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> rotated_dependent_timespan_maker = new(
...     new_dependent_timespan_maker,
...     rotation_indices=(1, -1),
...     )
>>> result = rotated_dependent_timespan_maker(
...     music_specifiers=music_specifiers,
...     timespan_inventory=new(timespan_inventory),
...     )
>>> show(result, key='voice_name', range_=(0, 75))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-57ce3dce1f7346f365183d8abb73e3a2.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Rhythm-makers}
\label{sec:rhythm-makers}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Abjad's rhythm-makers, like Consort's timespan-makers, are highly-configurable
factory classes which behave like partially evaluated functions, taking
as input sequences of \emph{divisions} -- positive duration tokens representing
the divisions in some phrase of music -- and producing selections of score
components as output. Abjad's \texttt{rhythmmakertools} library contains a
variety of such classes, each providing a different strategy for rhythm
generation, but unified by the same callable interface. Additionally,
\texttt{rhythmmakertools} provides a collection of \emph{specifier} classes
which group related configuration values together for controlling the behavior
of ties, beams, duration spelling and other notational aspects of each
rhythm-maker's output. Like many other classes in Abjad -- timespans, for
example -- both these specifiers and the rhythm-makers themselves can be
templated via calls to \texttt{new()}. A tour of these rhythm-maker classes
demonstrates how a wide range of rhythmic textures can be produced.

\subsection{Note rhythm-makers}

Note rhythm-makers, arguably the simplest class of rhythm-maker, take a
sequence of input divisions and \enquote{fill} them with notes, tied as
necessary, such that the duration of each logical tie in each output division
equals the duration of each input division.

\begin{comment}
<abjad>
note_rhythm_maker = rhythmmakertools.NoteRhythmMaker()
divisions = [(3, 8), (4, 8), (3, 16), (4, 16), (5, 8), (2, 4)]
show(note_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> note_rhythm_maker = rhythmmakertools.NoteRhythmMaker()
>>> divisions = [(3, 8), (4, 8), (3, 16), (4, 16), (5, 8), (2, 4)]
>>> show(note_rhythm_maker, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-d0f66021e4860194d32ee0fa226ed174.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Like many objects implemented in Abjad and its extensions,
rhythm-makers can be illustrated via a call to \texttt{show()}. Rhythm-maker
illustrations take an optional \texttt{divisions} argument, specifying what
durations should be used for the generated rhythmic output, grouping each of
those divisions into measures for ease of visualization.

Rhythm-makers can be configured with a variety of specifiers, allowing for
optional customization of their rhythm-generating behavior. For example, a
\texttt{TieSpecifier} can be used to force a rhythm-maker to tie the last note
of each output division to the first note of the next output division. When
used with a note rhythm-maker, this effectively ties all notes in the output
together.

\begin{comment}
<abjad>
note_rhythm_maker = new(
    note_rhythm_maker,
    tie_specifier=rhythmmakertools.TieSpecifier(
        tie_across_divisions=True,
        ),
    )
show(note_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> note_rhythm_maker = new(
...     note_rhythm_maker,
...     tie_specifier=rhythmmakertools.TieSpecifier(
...         tie_across_divisions=True,
...         ),
...     )
>>> show(note_rhythm_maker, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-1c2192761535f741178fd5fc2ed22ed7.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Other rhythm-maker specifiers influence beaming, tuplet spelling, or
can cause a rhythm-maker to convert patterned groups of leaves in its output
from notes to rests or vice versa. Rhythm-makers configured with \emph{output
masks} replace the contents of their output divisions with rests in a patterned
per-division basis. A sequence of one or more \texttt{BooleanPattern} instances
control the masking pattern. These patterns partition the rhythm-maker's output
divisions into segments of a given period, and then mask out divisions
specified by indices within that period. For example, a note rhythm-maker
configured with a single output mask of a period of length 2 and a masking
index 0 will cause the first of every two divisions to be silenced.

\begin{comment}
<abjad>
mask = rhythmmakertools.BooleanPattern(indices=[0], period=2)
note_rhythm_maker = rhythmmakertools.NoteRhythmMaker(output_masks=[mask])
show(note_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> mask = rhythmmakertools.BooleanPattern(indices=[0], period=2)
>>> note_rhythm_maker = rhythmmakertools.NoteRhythmMaker(output_masks=[mask])
>>> show(note_rhythm_maker, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-fb60261fce39a6a8bed29c6bc1a39b14.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Reducing the period of the boolean pattern from 2 to 1 silences every
output division, effectively turning a note-generating rhythm-maker into a
rest-generating rhythm-maker.

\begin{comment}
<abjad>
mask = rhythmmakertools.BooleanPattern(indices=[0], period=1)
note_rhythm_maker = rhythmmakertools.NoteRhythmMaker(output_masks=[mask])
show(note_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> mask = rhythmmakertools.BooleanPattern(indices=[0], period=1)
>>> note_rhythm_maker = rhythmmakertools.NoteRhythmMaker(output_masks=[mask])
>>> show(note_rhythm_maker, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-b8d4d2abe1d0cabd1dba685a0e5a2bcc.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\subsection{Talea rhythm-makers}

Talea rhythm-makers, like talea timespan-makers, create rhythmic output through
the use of a talea -- an infinitely cyclic pattern of durations. Talea
rhythm-makers fill their output divisions with durations from their talea,
splitting those durations across division boundaries when the divisions are
over-full. The following trivial talea rhythm-maker uses a length-1 talea
comprised of a single 1/16 duration.

\begin{comment}
<abjad>
talea_rhythm_maker = rhythmmakertools.TaleaRhythmMaker(
    talea=rhythmmakertools.Talea(
        counts=[1],
        denominator=16,
        ),
    )
show(talea_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> talea_rhythm_maker = rhythmmakertools.TaleaRhythmMaker(
...     talea=rhythmmakertools.Talea(
...         counts=[1],
...         denominator=16,
...         ),
...     )
>>> show(talea_rhythm_maker, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-a8d7d6245553b2c4f5d2e404e62ae27b.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Extending the talea counts to a sequence of alternating 1/16 and 1/8
notes produces more complex results. Note how the 1/8 durations break over the
boundaries of the 3/16 measure, but remain tied together. Talea rhythm-makers
handle talea splitting and tying transparently.

\begin{comment}
<abjad>
talea_rhythm_maker = new(
    talea_rhythm_maker,
    talea__counts=[1, 2],
    )
show(talea_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> talea_rhythm_maker = new(
...     talea_rhythm_maker,
...     talea__counts=[1, 2],
...     )
>>> show(talea_rhythm_maker, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-a91e80c7459af113e517ef98d44608db.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent With the talea counts changed to a descending sequence of durations,
the pattern of split and tied durations also changes.

\begin{comment}
<abjad>
talea_rhythm_maker = new(
    talea_rhythm_maker,
    talea__counts=[4, 3, 2, 1],
    )
show(talea_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> talea_rhythm_maker = new(
...     talea_rhythm_maker,
...     talea__counts=[4, 3, 2, 1],
...     )
>>> show(talea_rhythm_maker, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-8d6fdf555decf2c32991c6d1f43307af.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Talea rhythm-makers can be configured to treat input divisions as
though they had more counts than they actually do via their
\texttt{extra\_counts\_per\_division} property, potentially causing tuplets to
appear in the output. The following talea, reconfigured from the previous, adds
an extra count to every second and third input division. This causes the 4/8
and 3/16 as well as the 5/8 and 2/4 divisions to become tuplets, each with a
pre-prolated duration 1/16 longer than their prolated duration. That is, the
4/8 division contains a tuplet whose contents sum to 9/16, but scaled into a
duration of 8/16. Likewise, the 3/16 division contains a tuplet whose contents
sum to 4/16, but scaled into a duration of 3/16. Note how this tupletting
causes the pattern of split and tied talea durations to shift. In the previous
example, the second instance of the talea's 3/16 duration occurred entirely
during the 3/16 division. Here, that same 3/16 talea duration begins on the
final 1/16 of the 4/8 division's 9:8 tuplet, tied into the 4:3 tuplet in the
following division.

\begin{comment}
<abjad>
talea_rhythm_maker = new(
    talea_rhythm_maker,
    extra_counts_per_division=[0, 1, 1],
    )
show(talea_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> talea_rhythm_maker = new(
...     talea_rhythm_maker,
...     extra_counts_per_division=[0, 1, 1],
...     )
>>> show(talea_rhythm_maker, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-f868ef7342d21df2f091666e876b44e7.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Like note rhythm-makers, talea rhythm-makers can be configured with a
tie specifier, causing the last note of each division to be tied to the first
note of the next division. In note rhythm-makers, the contents of each
non-masked division is guaranteed to be a single logical tie. Therefore, tying
across divisions results in the entire output of the note rhythm-maker merging
into the same logical tie. The output divisions of talea rhythm-makers
generally contain more than one logical tie, and therefore tying across
divisions tends to produce the effect of elided downbeats with intermittent
attacks.

\begin{comment}
<abjad>
talea_rhythm_maker = new(
    talea_rhythm_maker,
    tie_specifier=rhythmmakertools.TieSpecifier(
        tie_across_divisions=True,
        ),
    )
show(talea_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> talea_rhythm_maker = new(
...     talea_rhythm_maker,
...     tie_specifier=rhythmmakertools.TieSpecifier(
...         tie_across_divisions=True,
...         ),
...     )
>>> show(talea_rhythm_maker, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-0aa7f18c24b9676851fc7ace0fbb408e.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Talea rhythm-makers can also be configured to produce intermittent
silences, either by specifying negative count values in the rhythm-maker's
talea, or by configuring the rhythm-maker with a special \emph{burnish}
specifier which casts logical ties generated by the rhythm-maker as either
notes or rests, in a patterned way. Here, the 3-count in the talea
rhythm-maker's talea is changed to -3, resulting in the production of
3/16-duration silences.

\begin{comment}
<abjad>
talea_rhythm_maker_with_rests = new(
    talea_rhythm_maker,
    talea__counts=[4, -3, 2, 1],
    )
show(talea_rhythm_maker_with_rests, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> talea_rhythm_maker_with_rests = new(
...     talea_rhythm_maker,
...     talea__counts=[4, -3, 2, 1],
...     )
>>> show(talea_rhythm_maker_with_rests, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-f4acf8cc0f640f8afb7dbc701a8bbc82.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Alternatively, configuring the rhythm-maker with the following
\texttt{BurnishSpecifier} allows the first logical tie of every other division
to be converted to rests.

\begin{comment}
<abjad>
talea_rhythm_maker_with_rests = new(
    talea_rhythm_maker,
    burnish_specifier=rhythmmakertools.BurnishSpecifier(
        left_classes=[Rest],
        left_counts=[1, 0],
        ),
    )
show(talea_rhythm_maker_with_rests, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> talea_rhythm_maker_with_rests = new(
...     talea_rhythm_maker,
...     burnish_specifier=rhythmmakertools.BurnishSpecifier(
...         left_classes=[Rest],
...         left_counts=[1, 0],
...         ),
...     )
>>> show(talea_rhythm_maker_with_rests, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-56c4a8d2c9d313021bf1f182ccb3a96e.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\subsection{Incised rhythm-makers}

Incised rhythm-makers behave similarly to note rhythm-makers, but allow for
\emph{incising} patterned sequences of notes and rests from the beginnings and
ends of each output division, or even from the beginning and end of the entire
sequence of divisions -- the rhythm-maker \emph{output}. Configuring an incised
rhythm-maker to perform incision requires an \texttt{InciseSpecifier} instance.
An unconfigured incised rhythm-maker behaves identically to unconfigured note
rhythm-maker.

\begin{comment}
<abjad>
incised_rhythm_maker = rhythmmakertools.IncisedRhythmMaker()
show(incised_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> incised_rhythm_maker = rhythmmakertools.IncisedRhythmMaker()
>>> show(incised_rhythm_maker, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-d0f66021e4860194d32ee0fa226ed174.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Incise specifiers define talea and group counts for prefix and suffix
incision. The talea -- as determined by the numerators given in the
\texttt{prefix\_talea} and \texttt{suffix\_talea} sequences combined with the
\texttt{talea\_denominator} -- define the durations to be selected from, as
well as the \emph{sign} of the component to be incised. Negative talea items
indicate rests, while positive talea items indicate notes. The count properties
-- \texttt{suffix\_counts} and \texttt{prefix\_counts} -- indicate how many
talea durations should be selected at each pass. The following incised
rhythm-maker incises a single 1/16 rest at the end of each division.

\begin{comment}
<abjad>
incised_rhythm_maker = rhythmmakertools.IncisedRhythmMaker(
    incise_specifier=rhythmmakertools.InciseSpecifier(
        suffix_counts=[1],
        suffix_talea=[-1],
        talea_denominator=16,
        ),
    )
show(incised_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> incised_rhythm_maker = rhythmmakertools.IncisedRhythmMaker(
...     incise_specifier=rhythmmakertools.InciseSpecifier(
...         suffix_counts=[1],
...         suffix_talea=[-1],
...         talea_denominator=16,
...         ),
...     )
>>> show(incised_rhythm_maker, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-f21215b14c3e76d687060a020bdca52a.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Extending the suffix talea results in a more complex incision
pattern.

\begin{comment}
<abjad>
incised_rhythm_maker = new(
    incised_rhythm_maker,
    incise_specifier__suffix_talea=[-1, -2, -3],
    )
show(incised_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> incised_rhythm_maker = new(
...     incised_rhythm_maker,
...     incise_specifier__suffix_talea=[-1, -2, -3],
...     )
>>> show(incised_rhythm_maker, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-fafb95028809a8071ef2a59e4da26ec9.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Prefix incision occurs in an identical fashion, by specifying
sequences of group counts and talea numerators. Here, alternating groups of
length-1 and length-2 are incised from the beginning of each division.

\begin{comment}
<abjad>
incised_rhythm_maker = rhythmmakertools.IncisedRhythmMaker(
    incise_specifier=rhythmmakertools.InciseSpecifier(
        prefix_counts=[2, 1],
        prefix_talea=[2, 1],
        talea_denominator=16,
        ),
    )
show(incised_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> incised_rhythm_maker = rhythmmakertools.IncisedRhythmMaker(
...     incise_specifier=rhythmmakertools.InciseSpecifier(
...         prefix_counts=[2, 1],
...         prefix_talea=[2, 1],
...         talea_denominator=16,
...         ),
...     )
>>> show(incised_rhythm_maker, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-c2461da064af411639e8a2608af00305.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Setting the incise specifier's \texttt{fill\_with\_notes} property to
false causes the rhythm-maker to fill the unincised durations of its divisions
with rests rather notes.

\begin{comment}
<abjad>
incised_rhythm_maker = new(
    incised_rhythm_maker,
    incise_specifier__fill_with_notes=False,
    )
show(incised_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> incised_rhythm_maker = new(
...     incised_rhythm_maker,
...     incise_specifier__fill_with_notes=False,
...     )
>>> show(incised_rhythm_maker, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-25581a22cd4059e8966b0ff386bbbcc6.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Incised rhythm-makers can be configured to only incise the outer
divisions of their output. The following rhythm-maker cuts 1/8 rests from the
beginning of the first division in its output, and the end of the last
division.

\begin{comment}
<abjad>
incised_rhythm_maker = rhythmmakertools.IncisedRhythmMaker(
    incise_specifier=rhythmmakertools.InciseSpecifier(
        outer_divisions_only=True,
        prefix_counts=[1],
        prefix_talea=[-1],
        suffix_counts=[1],
        suffix_talea=[-1],
        talea_denominator=8,
        ),
    )
show(incised_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> incised_rhythm_maker = rhythmmakertools.IncisedRhythmMaker(
...     incise_specifier=rhythmmakertools.InciseSpecifier(
...         outer_divisions_only=True,
...         prefix_counts=[1],
...         prefix_talea=[-1],
...         suffix_counts=[1],
...         suffix_talea=[-1],
...         talea_denominator=8,
...         ),
...     )
>>> show(incised_rhythm_maker, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-8245f754d4c0b647786ba2c3e22988f3.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Incised rhythm-makers also respect many of the same rhythm-maker
specifiers as the other rhythm-maker classes defined in Abjad's
\texttt{rhythmmakertools} library. Like note rhythm-makers, they can be
configured to tie the last note of each output division to the first note of
the next output division via an instance of the \texttt{TieSpecifier} class.

\begin{comment}
<abjad>
incised_rhythm_maker = new(
    incised_rhythm_maker,
    tie_specifier=rhythmmakertools.TieSpecifier(
        tie_across_divisions=True,
        ),
    )
show(incised_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> incised_rhythm_maker = new(
...     incised_rhythm_maker,
...     tie_specifier=rhythmmakertools.TieSpecifier(
...         tie_across_divisions=True,
...         ),
...     )
>>> show(incised_rhythm_maker, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-9890ffbc1115862a9479f6a97bf677e3.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\subsection{Even-division rhythm-makers}

Even-division rhythm-makers attempt to divide each input division into runs of
notes with a basic duration \texttt{1/denominator}, where the \texttt{denominator}
is specified on a per-division basis by the rhythm-maker's configurable
\texttt{denominator} sequence property. When an input division does not
exactly fit some multiple of this basic duration, some combination of
augmentation or tupletting will be used to produce notes with durations as
close to that basic duration as possible.

\begin{comment}
<abjad>
even_division_rhythm_maker = rhythmmakertools.EvenDivisionRhythmMaker()
show(even_division_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> even_division_rhythm_maker = rhythmmakertools.EvenDivisionRhythmMaker()
>>> show(even_division_rhythm_maker, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-2bcea48859d1e8378a750341c3315103.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Extending the even-division rhythm-maker's denominator sequence to a
2-length pattern produces divisions filled alternatingly with 1/8 and 1/16
notes. Note that the 3/16 measure is filled with a dotted 1/8 note.

\begin{comment}
<abjad>
even_division_rhythm_maker = new(
    even_division_rhythm_maker,
    denominators=[8, 16],
    )
show(even_division_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> even_division_rhythm_maker = new(
...     even_division_rhythm_maker,
...     denominators=[8, 16],
...     )
>>> show(even_division_rhythm_maker, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-042a232c8ba3c9adb624c404980efe18.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Extending the denominator sequence even further results in more
complex output. Note here how the 5/8 division is rendered as a tuplet.

\begin{comment}
<abjad>
even_division_rhythm_maker = new(
    even_division_rhythm_maker,
    denominators=[8, 4, 16],
    )
show(even_division_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> even_division_rhythm_maker = new(
...     even_division_rhythm_maker,
...     denominators=[8, 4, 16],
...     )
>>> show(even_division_rhythm_maker, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-18b3464ab66c7d829de5417e6e668687.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Like the talea rhythm-maker, even-division rhythm-makers can be
configured with a \texttt{extra\_counts\_per\_division} property, forcing the
rhythm-maker to treat input divisions as longer than the actually. Artificially
lengthened divisions are rendered as tuplets. With the following rhythm-maker,
every other division is extended by one count, causing the 4/8 and 2/4
divisions to be rendered as 5:4 tuplets, and the 4/16 division to be rendered
as a 3:2 tuplet.

\begin{comment}
<abjad>
even_division_rhythm_maker = new(
    even_division_rhythm_maker,
    denominators=[8],
    extra_counts_per_division=(0, 1),
    )
show(even_division_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> even_division_rhythm_maker = new(
...     even_division_rhythm_maker,
...     denominators=[8],
...     extra_counts_per_division=(0, 1),
...     )
>>> show(even_division_rhythm_maker, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-7bd6867c75e18e48ebf2c898a35a53b9.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent When configured with a tie specifier, the even-division rhythm-maker
obscures the downbeat of every output division.

\begin{comment}
<abjad>
even_division_rhythm_maker = new(
    even_division_rhythm_maker,
    tie_specifier=rhythmmakertools.TieSpecifier(
        tie_across_divisions=True,
        ),
    )
show(even_division_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> even_division_rhythm_maker = new(
...     even_division_rhythm_maker,
...     tie_specifier=rhythmmakertools.TieSpecifier(
...         tie_across_divisions=True,
...         ),
...     )
>>> show(even_division_rhythm_maker, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-4cc7ba58b448cb7add8a0024b1e90f9b.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent And when reconfigured with the earlier 8-4-16 denominator pattern,
the even-division rhythm-maker produces rich tupletted rhythmic output.

\begin{comment}
<abjad>
even_division_rhythm_maker = new(
    even_division_rhythm_maker,
    denominators=[8, 4, 16],
    )
show(even_division_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> even_division_rhythm_maker = new(
...     even_division_rhythm_maker,
...     denominators=[8, 4, 16],
...     )
>>> show(even_division_rhythm_maker, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-af43995b8651db6fd08d7d3e42ff809b.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\subsection{Composite rhythm-makers} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Consort provides a class for aggregating multiple rhythm-maker instances
together into a \emph{composite} rhythm-maker, which applies its aggregated
rhythm-makers conditionally against input divisions to generate rhythmic
output. The following contrived composite rhythm-maker uses the previously note
rhythm-maker -- which only generates rests -- for the last of any sequence of
input divisions, the previously defined incised rhythm-maker for the first of
any sequence of input divisions, and the previously defined talea rhythm-maker
for all other input divisions.

\begin{comment}
<abjad>
composite_rhythm_maker = consort.CompositeRhythmMaker(
    default=talea_rhythm_maker,
    last=note_rhythm_maker,
    first=incised_rhythm_maker,
    )
show(composite_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> composite_rhythm_maker = consort.CompositeRhythmMaker(
...     default=talea_rhythm_maker,
...     last=note_rhythm_maker,
...     first=incised_rhythm_maker,
...     )
>>> show(composite_rhythm_maker, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-b1e38a72e659f0b2878d87c5401d2cd5.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\todo[inline]{\textbf{TODO:} Conclude composite rhythm-maker discussion with a
motivating example.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Meter}
\label{sec:meter}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\todo[inline]{\textbf{TODO:} Provide a definition of meter. Cite Lerdahl.}

Abjad models meter as a \emph{rhythm-tree} of nested, durated nodes which
outline a series of strongly and weakly accented offsets. The accent strength
of a particular offset found in a meter's rhythm-tree derives from the number
of nodes in that tree sharing that offset as a start or stop. The more nodes in
the rhythm-tree which share an offset, the greater the weight -- the
accentedness -- of that offset is taken to be. Abjad can construct the rhythm
tree for any meter from a numerator / denominator pair such as a rational
duration or time signature. Meter construction involves the progressive
division of the numerator of the input pair into groups of two and
threes\footnote{The factors 4 and 5 are also used in meter rhythm-tree
generation as they provide better typical results during meter rewriting.}, and
the decomposition of any other prime factors into groups of threes and twos.
Division by two always occurs before division by three, giving preference to
even metrical structures above odd or otherwise prime divisions. Constructing
rhythm-trees in this fashion gives results which generally align with common
practice expectations.

Consider the following 6/8 meter and its graph representation:

\begin{comment}
<abjad>
six_eight_meter = metertools.Meter((6, 8))
graph(six_eight_meter)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> six_eight_meter = metertools.Meter((6, 8))
>>> graph(six_eight_meter)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,scale=0.333,]{assets/graphviz-476d0f5c7605cc762b9e3a391835548f.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent The triangular and rectangular boxes indicate nodes in the
rhythm-tree itself. Rectangular boxes represent \enquote{beats} -- the leaves
of the rhythm-tree -- while triangular boxes indicate larger metrical
groupings. The ovals at the bottom of the graph indicate -- at their top -- the
start or stop offset of the nodes connected to them from above and -- at their
bottom -- the relative weight of their accent. The final oval on the right
indicates the offset and accent weight of the \enquote{next} downbeat.

The topmost triangle in the above graph represent the \enquote{highest}
metrical grouping in a 6/8 meter. Tracing the leftmost and rightmost arrows
down through the topmost node's children gives the offsets 0 and 3/4: the first
downbeat and next downbeat in a 6/8 meter. Offsets 0 and 3/4 also have the
strongest accent weights as they occur as either the start offset or stop
offset of nodes at three levels of hierarchy in the rhythm tree. At the second
level the 6/8 grouping divides into two 3/8 groupings, following common
practice expectations: metrical groupings tend to subdivide into groups of two
before they subdivide into groups of three\footnote{Consider a 12/8 meter.
Western musicians tend to subdivide twelve into either two groups of six or
four groups of three rather than into three groups of four.}. Both second-level
nodes share the offset of 3/8, which also occurs in the third level, giving 3/8
a weight of two. The third level contains the 1/8 duration beats, grouped by
their parents in the second level into two groups three 1/8 duration nodes. The
offsets 1/8, 1/4, 1/2 and 5/8 are not shared by any nodes except at the lowest
metrical level and therefore all receive an accent weight of one.

\subsection{Examples of meter} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Consider the following examples of meters modeled in Abjad.

A 3/4 meter consists of a top-level 3/4 metrical grouping divided into three
1/4 duration beats:

\begin{comment}
<abjad>
three_four_meter = metertools.Meter((3, 4))
graph(three_four_meter)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> three_four_meter = metertools.Meter((3, 4))
>>> graph(three_four_meter)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,scale=0.333,]{assets/graphviz-27e6f78f37c92f763186b4aaae59c563.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent By default, a 7/8 meter subdivides its top-level metrical grouping
into 3/8+2/8+2/8 groupings:

\begin{comment}
<abjad>
seven_eight_meter = metertools.Meter((7, 8))
graph(seven_eight_meter)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> seven_eight_meter = metertools.Meter((7, 8))
>>> graph(seven_eight_meter)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,scale=0.333,]{assets/graphviz-aa33afdcb82327be8e33e7587b5b7fb5.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent A 12/8 meter subdivides into four 3/8 duration groupings, each
containing three 1/8 duration beats:

\begin{comment}
<abjad>
twelve_eight_meter = metertools.Meter((12, 8))
graph(twelve_eight_meter)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> twelve_eight_meter = metertools.Meter((12, 8))
>>> graph(twelve_eight_meter)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,scale=0.333,]{assets/graphviz-c2a676a2bd53c91042417caefc7efaa9.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\subsection{Alternate meter representations} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Abjad permits alternate representations of meters with the same numerator and
denominator. The default interpretation of 4/4 generates a top-level rhythmic
grouping with a duration of 4/4 and four 1/4 beats as children\footnote{A
\enquote{flat} 4/4 metrical structure is useful for meter rewriting as it
allows the meter rewriting algorithm to ignore many common rhythmic idioms like
1/4+1/2+1/4 and 1/4+3/4.}.

\begin{comment}
<abjad>
four_four_meter = metertools.Meter((4, 4))
graph(four_four_meter)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> four_four_meter = metertools.Meter((4, 4))
>>> graph(four_four_meter)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,scale=0.333,]{assets/graphviz-1e7a83f7d35a8732ccfa1919e9c8f64f.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent While meter objects are usually instantiated from numerator /
denominator pairs, with their rhythm-tree structure determined programmatically
from that input pair, they can also be instantiated from strings parsable as
rhythm-trees, or from rhythm-tree objects themselves. All meters, because they
are implemented in terms of rhythm-trees, can be represented by a Lisp-like
rhythm-tree syntax:

\begin{comment}
<abjad>
print(four_four_meter.pretty_rtm_format)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> print(four_four_meter.pretty_rtm_format)
(4/4 (
	1/4
	1/4
	1/4
	1/4))
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

Instantiating meters from explicit rhythm tree syntax allows composers to
choose alternate representations of metrical structures. For example, a 4/4
meter which strongly emphasizes beat three is possible by subdividing the
top-level 4/4 metrical grouping into two 2/4 duration groupings, which are then
subdivided each into two 1/4 duration beats:

\begin{comment}
<abjad>
arbitrary_meter_1 = metertools.Meter('(4/4 ((2/4 (1/4 1/4)) (2/4 (1/4 1/4))))')
graph(arbitrary_meter_1)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> arbitrary_meter_1 = metertools.Meter('(4/4 ((2/4 (1/4 1/4)) (2/4 (1/4 1/4))))')
>>> graph(arbitrary_meter_1)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,scale=0.333,]{assets/graphviz-538350f4d574238c7fe14b0bc2fcd602.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Unusual metrical structures are also possible, such as the following
4/4 meter which divides into two parts, with the first part dividing into two
again, and the second grouping of that divided into two again:

\begin{comment}
<abjad>
arbitrary_meter_2 = metertools.Meter('(4/4 ((2/4 (1/4 (1/4 (1/8 1/8)))) 1/2))')
graph(arbitrary_meter_2)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> arbitrary_meter_2 = metertools.Meter('(4/4 ((2/4 (1/4 (1/4 (1/8 1/8)))) 1/2))')
>>> graph(arbitrary_meter_2)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,scale=0.333,]{assets/graphviz-c0c488f838ef576f45131546e93310fa.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Rewriting meters}
\label{sec:rewriting-meters}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\todo[inline]{\textbf{TODO:} Remove subscripts in rewrite\_meter() calls.}

Notated rhythms can be expressed in multiple ways while maintaining the same
attack-point and duration structure. \emph{Meter rewriting} formalizes the
process of re-notating a rhythm according to the offset structure inherent to
some meter while maintaining the original attack-points and durations. Logical
ties are fused or split depending on their \emph{validity}. In the context of
meter rewriting, validity expresses whether any logical tie -- trivial or not
-- \emph{aligns} to offsets found in nodes at a particular depth in a meter's
rhythm-tree. Alignment requires that a logical tie both starts and stops at
offsets found in some collection of offsets. Meter rewriting proceeds by
testing logical ties against offsets outlined first by the root node of a
meter and, if found invalid, against those offsets found in nodes progressively
deeper in the meter's rhythm-tree.

For example, the offsets outlined by the root node of a 6/8 meter can be found
by examining its depth-wise offset inventory.

\begin{comment}
<abjad>
six_eight_meter = metertools.Meter((6, 8))
six_eight_meter.depthwise_offset_inventory[0]
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> six_eight_meter = metertools.Meter((6, 8))
>>> six_eight_meter.depthwise_offset_inventory[0]
(Offset(0, 1), Offset(3, 4))
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

A logical tie three-quarters in duration starting at the offset 0 would be
considered valid in the context of 6/8 because it aligns to the offsets
outlined at depth-0 of the meter's rhythm-tree. In contrast, a logical tie two
quarters in duration starting at 1/8 -- therefore outlining the timespan of
1/8:5/8 -- would be considered invalid due to misalignment.

\begin{comment}
<abjad>
six_eight_measure = Measure((6, 8), "r8 c'2 r8")
show(six_eight_measure)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> six_eight_measure = Measure((6, 8), "r8 c'2 r8")
>>> show(six_eight_measure)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-2dd583c36ffd0a13968eee4ac11dcfb5.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

Meter rewriting splits misaligned
logical ties at any possible offset found in the currently considered depth. If
no offsets at that depth intersect with the misaligned tie, the depth is
increased and the process repeats. At a depth of 1 in a 6/8 meter we finally
find an offset intersecting the timespan of the misaligned 1/8:5/8 logical tie:
3/8.

\begin{comment}
<abjad>
six_eight_meter.depthwise_offset_inventory[1]
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> six_eight_meter.depthwise_offset_inventory[1]
(Offset(0, 1), Offset(3, 8), Offset(3, 4))
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Rewriting the contents of the 6/8 measure against a 6/8 meter splits
the inner half-note at the 3/8 offset boundary.

\begin{comment}
<abjad>
mutate(six_eight_measure).rewrite_meter(six_eight_meter)
show(six_eight_measure)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> mutate(six_eight_measure).rewrite_meter(six_eight_meter)
>>> show(six_eight_measure)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-c0edb6ffb12fe0ee5fb467e0bfefecdd.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

As another example, consider the following rhythm:

\begin{comment}
<abjad>
parseable = "abj: | 2/4 c'2 ~ |"
parseable += "| 4/4 c'32 d'2.. ~ d'16 e'32 ~ |"
parseable += "| 2/4 e'2 |"
staff = Staff(parseable)
show(staff)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> parseable = "abj: | 2/4 c'2 ~ |"
>>> parseable += "| 4/4 c'32 d'2.. ~ d'16 e'32 ~ |"
>>> parseable += "| 2/4 e'2 |"
>>> staff = Staff(parseable)
>>> show(staff)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-329490b244b088f012cb5146859cdab0.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent The middle measure is notated in a perfectly valid manner. However,
the double-dotted D does not align with or break against any of the offsets of
a 4/4 metrical structure: 0/4, 1/4, 2/4, 3/4 or 4/4.

\begin{comment}
<abjad>
four_four_meter = metertools.Meter((4, 4))
graph(four_four_meter)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> four_four_meter = metertools.Meter((4, 4))
>>> graph(four_four_meter)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,scale=0.333,]{assets/graphviz-1e7a83f7d35a8732ccfa1919e9c8f64f.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Rewriting the inner measure against a 4/4 meter breaks the inner
logical tie at 1/4 and 3/4, slightly improving readability.

\begin{comment}
<abjad>
mutate(staff[1]).rewrite_meter(four_four_meter)
show(staff)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> mutate(staff[1]).rewrite_meter(four_four_meter)
>>> show(staff)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-52ed3c73b623b7b0d9a2c6230084a264.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Rewriting the same measure against a 2/2 meter breaks the inner
logical tie at the offset 1/2, as two double-dotted quarter notes. While
identical to 4/4 in duration, 2/2 strongly emphasizes this duple division.

\begin{comment}
<abjad>
two_two_meter = metertools.Meter((2, 2))
staff = Staff(parseable)
mutate(staff[1]).rewrite_meter(two_two_meter)
show(staff)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> two_two_meter = metertools.Meter((2, 2))
>>> staff = Staff(parseable)
>>> mutate(staff[1]).rewrite_meter(two_two_meter)
>>> show(staff)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-467c7a453dd4de93da0cc1c7acbe0a87.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\subsection{Dot count} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Meter rewriting can control for various qualities of how rhythms are notated.
For example, the maximum number of dots allowed for any notated rhythmic value
can be constrained. Logical ties encountered during the rewriting process whose
individual notes exceed the maximum number of permitted dots will be rewritten,
if a maximum dot count has been specified.

Consider this series of progressively rewritten rhythms, beginning with the
following unrewritten 3/4 measure.

\begin{comment}
<abjad>
measure = Measure((3, 4), "c'32 d'8 e'8 fs'4...")
show(measure)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> measure = Measure((3, 4), "c'32 d'8 e'8 fs'4...")
>>> show(measure)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-8d4bc784b86bdade27d371532ab358a2.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent After meter rewriting, the final F-sharp is notated as a
triple-dotted quarter-note, valid because its stop offset aligns perfectly with
the containing measure's stop offset.

\begin{comment}
<abjad>
mutate(measure).rewrite_meter((3, 4))
show(measure)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> mutate(measure).rewrite_meter((3, 4))
>>> show(measure)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-d4d52cf91b08080c4067643d24faaf2a.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Capping the maximum number of dots to 2 causes the F-sharp to be
rewritten with as a double-dotted eighth-note tied to a quarter-note.

\begin{comment}
<abjad>
measure = Measure((3, 4), "c'32 d'8 e'8 fs'4...")
mutate(measure).rewrite_meter((3, 4), maximum_dot_count=2)
show(measure)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> measure = Measure((3, 4), "c'32 d'8 e'8 fs'4...")
>>> mutate(measure).rewrite_meter((3, 4), maximum_dot_count=2)
>>> show(measure)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-40b68312fd44f949b40de163b21588c3.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Constraining the maximum number of dots to 1 further subdivides the
F-sharp logical tie.

\begin{comment}
<abjad>
measure = Measure((3, 4), "c'32 d'8 e'8 fs'4...")
mutate(measure).rewrite_meter((3, 4), maximum_dot_count=1)
show(measure)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> measure = Measure((3, 4), "c'32 d'8 e'8 fs'4...")
>>> mutate(measure).rewrite_meter((3, 4), maximum_dot_count=1)
>>> show(measure)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-5fba6e827130a27fefae4843d2b21248.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Finally, with no dots permitted at all, the rhythmic presentation of
the measure changes considerably. Every dotted rhythm has been subdivided.

\begin{comment}
<abjad>
measure = Measure((3, 4), "c'32 d'8 e'8 fs'4...")
mutate(measure).rewrite_meter((3, 4), maximum_dot_count=0)
show(measure)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> measure = Measure((3, 4), "c'32 d'8 e'8 fs'4...")
>>> mutate(measure).rewrite_meter((3, 4), maximum_dot_count=0)
>>> show(measure)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-2ca50ee6f27ae56bae476fb9dc1faafa.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Prudent application of dot count constraints can clarify awkward
rhythmic spellings by forcing the appearance of offsets in logical ties
inherent to the rewriting meter.

\subsection{Boundary depth} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In meter rewriting, \emph{boundary depth} forces emphasis of offsets found at
different \emph{depths} in a meter's rhythm-tree by marking as invalid logical
ties which do not immediately align to those offsets on the very first pass of
the recursive meter rewriting process. Use of boundary depth often clarifies
distinctive groupings in more deeply nested meters, such as the 3-ness inherent
to a 9/8 meter. The nodes with a depth of 1 in the following 9/8 meter's
rhythm-tree -- the three 3/8 inner nodes marked by triangles -- outline the
offsets 0/8, 3/8, 6/8 and 9/8. When rewriting a 9/8 rhythm with a boundary
depth of 1, any logical ties not aligning with -- \emph{both} starting and
stopping at -- those offsets would be marked as invalid and therefore
rewritten.

\begin{comment}
<abjad>
nine_eight_meter = metertools.Meter((9, 8))
graph(nine_eight_meter)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> nine_eight_meter = metertools.Meter((9, 8))
>>> graph(nine_eight_meter)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,scale=0.333,]{assets/graphviz-9a650c94101f81b5350bc7b0edcf43a1.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\begin{comment}
<abjad>
measure = Measure((9, 8), "c'2 d'2 e'8")
show(measure)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> measure = Measure((9, 8), "c'2 d'2 e'8")
>>> show(measure)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-f459f8c64dd96ba762e4bdebba6f4680.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\begin{comment}
<abjad>
mutate(measure).rewrite_meter(nine_eight_meter)
show(measure)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> mutate(measure).rewrite_meter(nine_eight_meter)
>>> show(measure)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-63f30ee6e2e244440af9d6f1e0f84a02.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent After rewriting, without any boundary depth specified, the D half
note in the above 9/8 measure has been split into two quarter-notes, tied
together. The second of these quarter-notes begins at 6/8, therefore aligning
with the start of the third 3/8 node at depth 1 in the 9/8 meter's rhythm tree.
Likewise, the first half of the split half-note ends at the same 6/8 offset.
However, the initial C half-note, while aligning with the beginning of the
meter and therefore treated as valid, does not emphasize any of the meter's
inner offsets as outlined by the offsets 3/8 and 6/8.

\begin{comment}
<abjad>
measure = Measure((9, 8), "c'2 d'2 e'8")
mutate(measure).rewrite_meter(
    nine_eight_meter,
    boundary_depth=1,
    )
show(measure)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> measure = Measure((9, 8), "c'2 d'2 e'8")
>>> mutate(measure).rewrite_meter(
...     nine_eight_meter,
...     boundary_depth=1,
...     )
>>> show(measure)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-93c0260083a9ae2ad25a3c7c064e3024.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent After rewriting with boundary depth set to 1, not only has the D
half-note been split in half, but the initial C half-note has been split at its
3/8 offset. Because the initial half note aligned at the 0/8 offset -- as
outlined by the root node in the 9/8 meter's rhythm tree --, but not at
the 3/8 offset -- as outlined by the first and second 3/8-duration nodes at
depth 1 of the same meter's rhythm tree --, it was marked invalid and therefor
split at the first available offset: 3/8.

\subsection{Recursive meter rewriting} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Meter rewriting treats the contents of tuplets with non-trivial prolation as
existing within their own metrical scope, isolated from any other meter. The
numerator and denominator of the tuplet's pre-prolated contents duration act as
the numerator and denominator of their \enquote{virtual} meter. Thus, a 6:5
tuplet encountered in any context will be rewritten as though under some
6-numerator meter.

\begin{comment}
<abjad>
parseable = "abj: | 4/4 c'16 ~ c'4 d'8. ~ "
parseable += "2/3 { d'8. ~ 3/5 { d'16 e'8 ~ e'16 f'16 ~ } } "
parseable += "f'4 |"
measure = parse(parseable)
show(measure)
mutate(measure).rewrite_meter(
    measure,
    boundary_depth=1,
    )
show(measure)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> parseable = "abj: | 4/4 c'16 ~ c'4 d'8. ~ "
>>> parseable += "2/3 { d'8. ~ 3/5 { d'16 e'8 ~ e'16 f'16 ~ } } "
>>> parseable += "f'4 |"
>>> measure = parse(parseable)
>>> show(measure)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-270f471c0052391c9bf1a5df2ccc4474.pdf}
\begin{lstlisting}
>>> mutate(measure).rewrite_meter(
...     measure,
...     boundary_depth=1,
...     )
>>> show(measure)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-f7aa660690e64db249ef36ea1eac5ace.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent If, while rewriting the contents of one tuplet, a second tuplet is
encountered as a child of that first tuplet, the meter rewriting algorithm will
recursively descend into that second tuplet -- and any further tuplet children
at any depth. This recursive descent allows any encountered component to be
rewritten in a relevant metrical context.

\subsection{Examples of meter rewriting: 3/4 \& 6/8} %%%%%%%%%%%%%%%%%%%%%%%%%%

Meter rewriting can clarify structural differences between meters with
identical durations, such as 3/4 and 6/8, or between various possible
representations of other prime-numerator meters like 5/4, 7/8 and so forth.
The following series of 3/4 measures contain rhythms which emphasize 3/4-ness
or 6/8-ness to different degrees. While perfectly valid and totally legible,
they can still be rewritten to more strongly express one meter over the other.

\begin{comment}
<abjad>
staff = Staff(context_name='RhythmicStaff')
staff.extend("{ c'2 c'4 } { c'4. c'4. } { c'2 ~ c'8 c'8 }")
attach(TimeSignature((3, 4)), staff)
show(staff)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> staff = Staff(context_name='RhythmicStaff')
>>> staff.extend("{ c'2 c'4 } { c'4. c'4. } { c'2 ~ c'8 c'8 }")
>>> attach(TimeSignature((3, 4)), staff)
>>> show(staff)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-b4a2116ab0031b6068b1112932629bac.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Rewriting under a 3/4 meter with a boundary depth of 1 forces
emphasis of the offsets found in the 3/4 meter's depth-1 group of three
quarter-duration nodes: 0/4, 1/4, 2/4 and 3/4. Both the outer measures'
contents align to these offsets, but the inner measure's hemiola contents do
not, and are rewritten.

\begin{comment}
<abjad>
for container in staff:
    mutate(container).rewrite_meter((3, 4), boundary_depth=1)

show(staff)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> for container in staff:
...     mutate(container).rewrite_meter((3, 4), boundary_depth=1)
...
>>> show(staff)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-0cef77f45f31e31ad271d15c9c32edf8.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Conversely, rewriting with a 6/8 meter -- again with a boundary depth
of 1 -- forces emphasis of the offsets outlined by 6/8's two depth-1
3/8-duration nodes: 0/8, 3/8 and 6/8. Only the inner measure's contents align
perfectly these offsets, so the outer measures are rewritten, better
demonstrating 6/8's duple-ness.

\begin{comment}
<abjad>
staff = Staff(context_name='RhythmicStaff')
staff.extend("{ c'2 c'4 } { c'4. c'4. } { c'2 ~ c'8 c'8 }")
attach(TimeSignature((6, 8)), staff)
for container in staff:
    mutate(container).rewrite_meter((6, 8), boundary_depth=1)

show(staff)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> staff = Staff(context_name='RhythmicStaff')
>>> staff.extend("{ c'2 c'4 } { c'4. c'4. } { c'2 ~ c'8 c'8 }")
>>> attach(TimeSignature((6, 8)), staff)
>>> for container in staff:
...     mutate(container).rewrite_meter((6, 8), boundary_depth=1)
...
>>> show(staff)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-58a85c4734fd2a15643aa2409cbff0e5.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Finding meters}
\label{sec:finding-meters}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Not only can meters be used to alter rhythmic structures, they can also be
derived from them. A meter's weighted-offset pattern can be used as
one-dimensional kernel, or convolution matrix, to determine how strongly an
arbitrary collection of offsets appears to express that meter. Given a
collection of meters to choose from, each meter can be matched against those
offsets and the meter most closely aligning selected as the winner. This
process is called \emph{meter fitting}.

\subsection{Offset counters} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Before convolving a meter with a collection of offsets, those offsets need to
be extracted and counted. Abjad's \texttt{metertools} provides an
\texttt{OffsetCounter} class which maps offsets against counts. Offset counters
can be instantiated from any expression containing offsets or whose elements
can be expressed as timespans and therefore possess both start and stop
offsets. Offsets which appear multiple times in the input expression will
result in a higher count in the offset counter, and will in turn have a greater
influence during meter fitting.

Consider the following score example:

\begin{comment}
<abjad>
upper_staff = Staff("c'8 d'4. e'8 f'4.")
lower_staff = Staff(r'\clef bass c4 b,4 a,2')
piano_staff = scoretools.StaffGroup(
    [upper_staff, lower_staff],
    context_name='PianoStaff',
    )
show(piano_staff)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> upper_staff = Staff("c'8 d'4. e'8 f'4.")
>>> lower_staff = Staff(r'\clef bass c4 b,4 a,2')
>>> piano_staff = scoretools.StaffGroup(
...     [upper_staff, lower_staff],
...     context_name='PianoStaff',
...     )
>>> show(piano_staff)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-bf3a249e2b4eac93b1884bab1a122a10.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent The start and stop offsets of all of the leaves of this score can be
counted by selecting the score's leaves and instantiating an offset counter
from them. Because all score components can be expressed as timespans via
\texttt{inspect\_(some\_component).get\_timespan()} the offset counter can
retrieve both their start and stop offsets within the score.

\begin{comment}
<abjad>
leaves = piano_staff.select_leaves(allow_discontiguous_leaves=True)
piano_staff_counter = metertools.OffsetCounter(leaves)
print(format(piano_staff_counter))
show(piano_staff_counter)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> leaves = piano_staff.select_leaves(allow_discontiguous_leaves=True)
>>> piano_staff_counter = metertools.OffsetCounter(leaves)
>>> print(format(piano_staff_counter))
metertools.OffsetCounter(
    {
        durationtools.Offset(0, 1): 2,
        durationtools.Offset(1, 8): 2,
        durationtools.Offset(1, 4): 2,
        durationtools.Offset(1, 2): 4,
        durationtools.Offset(5, 8): 2,
        durationtools.Offset(1, 1): 2,
        }
    )
\end{lstlisting}
\begin{lstlisting}
>>> show(piano_staff_counter)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-b2c45afc4a29ecdf622c76195f1251ae.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Note that the offset 1/2 shows a count of 4. This is because 1/2 acts
as both the start or stop offset for four separate leaves in the score.

Offset counters can also be generated from timespan inventories, allowing meter
convolution to be used without reference to any score objects at all.

\begin{comment}
<abjad>
timespans = timespantools.TimespanInventory([
    timespantools.Timespan(-1, 10),
    timespantools.Timespan(5, 15),
    timespantools.Timespan(15, 20),
    timespantools.Timespan(10, 15),
    ])
timespan_counter = metertools.OffsetCounter(timespans)
show(timespan_counter)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespans = timespantools.TimespanInventory([
...     timespantools.Timespan(-1, 10),
...     timespantools.Timespan(5, 15),
...     timespantools.Timespan(15, 20),
...     timespantools.Timespan(10, 15),
...     ])
>>> timespan_counter = metertools.OffsetCounter(timespans)
>>> show(timespan_counter)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-92e87e63b34df27878f535ac2f8e07ac.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\subsection{Metric accent kernels} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

As demonstrated earlier, Abjad's model of meter describes a sequence of offsets
with varying degrees of weight -- accentedness -- attributed to each offset, as
determined by the hierarchical tree structure of that meter. This model allows
us to explain how downbeats have a stronger weight than upbeats, and how the
3/8 offset in a 6/8 measure is less strong than its downbeat but still stronger
than the offsets at 1/8, 2/8, 4/8 or 5/8. However, the default model of a 6/8
meter makes no explicit reference to offsets such as 1/16 or 3/16. A common
practice understanding of meter tells us that these offsets should be taken as
less accented than those at 1/8, 2/8, 3/8 and so forth. They effectively
represent an even lower level of leaves on the rhythm-tree for 6/8. Likewise,
offsets with a denominator of 32 or 64 should be explainable in an identical
fashion.

Abjad's \texttt{MetricAccentKernel} provides an object model for both the act
of progressively subdividing the weighted offsets of a meter down to some
arbitrary denominator, and for convolving those offsets as a one-dimensional
convolution kernel against an offset counter. This allows meters to be fitted
against offset counters containing offsets not explicitly modeled by those same
meters. Here a metric accent kernel is generated from a 4/4 meter, extending
its denominator to a limit of 1/16. The weights at each offset are normalized
such that they sum to 1. Normalization prevents very long meters from having
undue influence during meter fitting.

\begin{comment}
<abjad>
meter = metertools.Meter((4, 4))
kernel_44 = metertools.MetricAccentKernel.from_meter(meter, denominator=16)
for offset, weight in sorted(kernel_44.kernel.items()):
    print('{!s}\t{!s}'.format(offset, weight))

</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> meter = metertools.Meter((4, 4))
>>> kernel_44 = metertools.MetricAccentKernel.from_meter(meter, denominator=16)
>>> for offset, weight in sorted(kernel_44.kernel.items()):
...     print('{!s}\t{!s}'.format(offset, weight))
...
0	4/33
1/16	1/33
1/8	2/33
3/16	1/33
1/4	1/11
5/16	1/33
3/8	2/33
7/16	1/33
1/2	1/11
9/16	1/33
5/8	2/33
11/16	1/33
3/4	1/11
13/16	1/33
7/8	2/33
15/16	1/33
1	4/33
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent The 4/4 metric accent kernel can be called against an offset counter
-- as though it were a function -- to generate the convolution response. The
count at each offset in the input offset counter is multiplied against the
weight at the corresponding offset in the metric accent kernel. If no
corresponding offset exists in the kernel, the weight is taken as 0. The
weighted counts are then added together and returned.

\begin{comment}
<abjad>
response = kernel_44(piano_staff_counter)
float(response)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> response = kernel_44(piano_staff_counter)
>>> float(response)
0.5454545454545454
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent The following loop demonstrates the logic underlying the above meter
convolution process example:

\begin{comment}
<abjad>
total = Multiplier(0, 1)
for offset, count in sorted(piano_staff_counter.items()):
    weight = Multiplier(0, 1)
    if offset in kernel_44.kernel:
        weight = kernel_44.kernel[offset]
    weighted_count = weight * count
    total += weighted_count
    message = '{!s}:\tcount: {}, weight: {!s}, multiplied: {!s}, total: {!s}'
    message = message.format(offset, count, weight, weighted_count, total)
    print(message)

</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> total = Multiplier(0, 1)
>>> for offset, count in sorted(piano_staff_counter.items()):
...     weight = Multiplier(0, 1)
...     if offset in kernel_44.kernel:
...         weight = kernel_44.kernel[offset]
...     weighted_count = weight * count
...     total += weighted_count
...     message = '{!s}:\tcount: {}, weight: {!s}, multiplied: {!s}, total: {!s}'
...     message = message.format(offset, count, weight, weighted_count, total)
...     print(message)
...
0:	count: 2, weight: 4/33, multiplied: 8/33, total: 8/33
1/8:	count: 2, weight: 2/33, multiplied: 4/33, total: 4/11
1/4:	count: 2, weight: 1/11, multiplied: 2/11, total: 6/11
1/2:	count: 4, weight: 1/11, multiplied: 4/11, total: 10/11
5/8:	count: 2, weight: 2/33, multiplied: 4/33, total: 34/33
1:	count: 2, weight: 4/33, multiplied: 8/33, total: 14/11
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Now consider the metric accent kernels for 3/4, 7/8 and 5/4 meters:

\begin{comment}
<abjad>
kernel_34 = metertools.MetricAccentKernel.from_meter((3, 4), denominator=16)
kernel_78 = metertools.MetricAccentKernel.from_meter((7, 8), denominator=16)
kernel_54 = metertools.MetricAccentKernel.from_meter((5, 4), denominator=16)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> kernel_34 = metertools.MetricAccentKernel.from_meter((3, 4), denominator=16)
>>> kernel_78 = metertools.MetricAccentKernel.from_meter((7, 8), denominator=16)
>>> kernel_54 = metertools.MetricAccentKernel.from_meter((5, 4), denominator=16)
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent We can generate an response for each of these kernels against the
piano staff offset counter.

\begin{comment}
<abjad>
float(kernel_34(piano_staff_counter))
float(kernel_78(piano_staff_counter))
float(kernel_54(piano_staff_counter))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> float(kernel_34(piano_staff_counter))
0.5384615384615384
\end{lstlisting}
\begin{lstlisting}
>>> float(kernel_78(piano_staff_counter))
0.4482758620689655
\end{lstlisting}
\begin{lstlisting}
>>> float(kernel_54(piano_staff_counter))
0.425
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Note that the previously recorded response for a 4/4 meter is still
higher than any of these three responses.

\subsection{Meter fitting} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Meter fitting involves the progressive comparison of a collection of permitted
meters against the offsets and counts in an offset counter. Starting from the
lowest offset, the metric accent kernel for each meter is convolved with all
those offsets in the offset counter with which it overlaps. The response from
each convolution is recorded and the meter with the highest associated response
is selected to represent those offsets. The process repeats, starting at the
right-most offset of the last meter selected, until no more offsets remain to
compare against.

Consider the following offsets, which are separated from one another by the
duration of a whole note, outlining the start and stop offsets of a series of
4/4 meters.

\begin{comment}
<abjad>
offset_counter = metertools.OffsetCounter([
    (0, 4), (4, 4), (8, 4), (12, 4), (16, 4),
    ])
show(offset_counter, range_=(0, 5))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> offset_counter = metertools.OffsetCounter([
...     (0, 4), (4, 4), (8, 4), (12, 4), (16, 4),
...     ])
>>> show(offset_counter, range_=(0, 5))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-c74006582b28efb1d61d9a6f219c91c8.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Given the following collection of meters, after meter fitting is
performed only 4/4 meters should be selected as they perfectly align with
the previously defined collection of offsets.

\begin{comment}
<abjad>
permitted_meters = metertools.MeterInventory([(3, 4), (4, 4), (5, 4)])
show(permitted_meters, range_=(0, 5))
fitted_meters = metertools.Meter.fit_meters_to_expr(
    expr=offset_counter,
    meters=permitted_meters,
    )
show(fitted_meters, range_=(0, 5))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> permitted_meters = metertools.MeterInventory([(3, 4), (4, 4), (5, 4)])
>>> show(permitted_meters, range_=(0, 5))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-e862fa00da35d33ab02699b7f058c648.pdf}
\begin{lstlisting}
>>> fitted_meters = metertools.Meter.fit_meters_to_expr(
...     expr=offset_counter,
...     meters=permitted_meters,
...     )
>>> show(fitted_meters, range_=(0, 5))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-96511fa6cd9448347d5f584042ff653c.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent If we change the input offsets to no longer outline only 4/4 meters,
the meter fitting process will arrive at a different solution. Note how the
following fitted meters emphasize the 3/4 and 5/4 durations inherent to the new
input offsets. The initial 3/4 fitted meter perfectly matches the offsets 0/1
and 3/4, while the 4/4 meter after it matches the 5/4 offset against its
third beat. The next meter's end-beat offset aligns against the offset
counter's 5/2 offset allowing the meter fitting process to perfectly match the
remaining offsets against a pair of 5/4 meters.

\begin{comment}
<abjad>
offset_counter = metertools.OffsetCounter([
    (0, 4), (3, 4), (5, 4), (10, 4), (15, 4), (20, 4),
    ])
fitted_meters = metertools.Meter.fit_meters_to_expr(
    expr=offset_counter,
    meters=permitted_meters,
    )
show(offset_counter, range_=(0, 5))
show(fitted_meters, range_=(0, 5))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> offset_counter = metertools.OffsetCounter([
...     (0, 4), (3, 4), (5, 4), (10, 4), (15, 4), (20, 4),
...     ])
>>> fitted_meters = metertools.Meter.fit_meters_to_expr(
...     expr=offset_counter,
...     meters=permitted_meters,
...     )
>>> show(offset_counter, range_=(0, 5))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-51cf25a6929362a969d24f3932cb3e52.pdf}
\begin{lstlisting}
>>> show(fitted_meters, range_=(0, 5))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-dd55e0279284ea18fd6b62df64b34865.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Meter fitting can also control for how many times meters are
permitted to immediately repeat. The above example ends with two 5/4 meters in
a row. If desired, this repetition can be prevented entirely by the
\texttt{maximum\_run\_length} keyword to
\texttt{Meter.fit\_meters\_to\_expr()}. With \texttt{maximum\_run\_length} set
to 1, the meter fitting process can no longer select two 5/4 meters for the end
of the fitted meter sequence. Instead, a pair of 3/4 and 4/4 meters replace the
previously final 5/4 meter.

\begin{comment}
<abjad>
fitted_meters = metertools.Meter.fit_meters_to_expr(
    expr=offset_counter,
    meters=permitted_meters,
    maximum_run_length=1,
    )
show(fitted_meters, range_=(0, 5))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> fitted_meters = metertools.Meter.fit_meters_to_expr(
...     expr=offset_counter,
...     meters=permitted_meters,
...     maximum_run_length=1,
...     )
>>> show(fitted_meters, range_=(0, 5))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-ab7c3eddad3d28cb19706ae50e024b17.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\subsection{Meter fitting in practice}

The output of timespan-makers motivates meter fitting more forcefully than the
above trivial examples. Densely layered timespan textures often involve
hundreds or even thousands of offsets with many points of simultaneity or
overlap. Careful management of meter fitting can result in convincing metrical
solutions to such textures.

Recall the quartet timespan texture from earlier in this chapter.

\begin{comment}
<abjad>
music_specifiers = collections.OrderedDict([
    ('Voice 1', None),
    ('Voice 2', None),
    ('Voice 3', None),
    ('Voice 4', None),
    ])
target_timespan = timespantools.Timespan(0, (19, 4))
timespan_inventory = talea_timespan_maker(
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
show(timespan_inventory, key='voice_name')
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> music_specifiers = collections.OrderedDict([
...     ('Voice 1', None),
...     ('Voice 2', None),
...     ('Voice 3', None),
...     ('Voice 4', None),
...     ])
>>> target_timespan = timespantools.Timespan(0, (19, 4))
>>> timespan_inventory = talea_timespan_maker(
...     music_specifiers=music_specifiers,
...     target_timespan=target_timespan,
...     )
>>> show(timespan_inventory, key='voice_name')
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-54d2fa8b64e488a84ee52a488caf28df.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Constructing an offset counter from this timespan inventory shows
several offsets with strong simultaneities, notably at 11/8, 13/8, 17/8 and
25/8.

\begin{comment}
<abjad>
offset_counter = metertools.OffsetCounter(timespan_inventory)
show(offset_counter, range_=(0, (19, 4)))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> offset_counter = metertools.OffsetCounter(timespan_inventory)
>>> show(offset_counter, range_=(0, (19, 4)))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-0be2900a4872bf90fe9bfb22c1e66b72.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent As before, a collection of permitted meters are fit against the
offset counter. Compare the weights in the counter to the meter sequence below
it. Offsets in the counter with weights greater than 1 tend to have been fitted
against strong beats in each meter. The initial 6/8 meter receive a 2-count
accent on its half-way 3/8 offset. The second 6/8 meter is matches strong
accents on both its downbeat, its half-beat and on its end-beat. Likewise, the
7/8 meter matches strong accents on its down-beat and end-beat, as well as its
inner 2-count groupings.

\begin{comment}
<abjad>
permitted_meters = metertools.MeterInventory([
    (5, 8), (3, 4), (6, 8), (7, 8), (4, 4),
    ])
fitted_meters = metertools.Meter.fit_meters_to_expr(
    expr=offset_counter,
    meters=permitted_meters,
    maximum_run_length=1,
    )
show(offset_counter, range_=(0, (19, 4)))
show(fitted_meters, range_=(0, (19, 4)))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> permitted_meters = metertools.MeterInventory([
...     (5, 8), (3, 4), (6, 8), (7, 8), (4, 4),
...     ])
>>> fitted_meters = metertools.Meter.fit_meters_to_expr(
...     expr=offset_counter,
...     meters=permitted_meters,
...     maximum_run_length=1,
...     )
>>> show(offset_counter, range_=(0, (19, 4)))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-0be2900a4872bf90fe9bfb22c1e66b72.pdf}
\begin{lstlisting}
>>> show(fitted_meters, range_=(0, (19, 4)))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-4252566a868aa8669a597a9b20a09b83.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Removing the 5/8 meter from the permitted meters inventory gives less
convincing results. Notably, the strong simultaneities at offsets 11/8 and 17/8
no longer align with any downbeats in the fitted meters.

\begin{comment}
<abjad>
permitted_meters = metertools.MeterInventory([
    (3, 4), (6, 8), (7, 8), (4, 4),
    ])
fitted_meters = metertools.Meter.fit_meters_to_expr(
    expr=offset_counter,
    maximum_run_length=1,
    meters=permitted_meters,
    )
show(offset_counter, range_=(0, (19, 4)))
show(fitted_meters, range_=(0, (19, 4)))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> permitted_meters = metertools.MeterInventory([
...     (3, 4), (6, 8), (7, 8), (4, 4),
...     ])
>>> fitted_meters = metertools.Meter.fit_meters_to_expr(
...     expr=offset_counter,
...     maximum_run_length=1,
...     meters=permitted_meters,
...     )
>>> show(offset_counter, range_=(0, (19, 4)))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-0be2900a4872bf90fe9bfb22c1e66b72.pdf}
\begin{lstlisting}
>>> show(fitted_meters, range_=(0, (19, 4)))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-9a5158818ad5fbad7bdb5f19fd966315.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Lifting the constraint on meter repetition does not improve the
results. Both the 11/8 and 17/8 offsets still align with weak beats in the
fitted meters. The only real change is the swapping of 6/8 and 3/4 meters in
the first and last pairs of fitted meters.

\begin{comment}
<abjad>
fitted_meters = metertools.Meter.fit_meters_to_expr(
    expr=offset_counter,
    meters=permitted_meters,
    )
show(offset_counter, range_=(0, (19, 4)))
show(fitted_meters, range_=(0, (19, 4)))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> fitted_meters = metertools.Meter.fit_meters_to_expr(
...     expr=offset_counter,
...     meters=permitted_meters,
...     )
>>> show(offset_counter, range_=(0, (19, 4)))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-0be2900a4872bf90fe9bfb22c1e66b72.pdf}
\begin{lstlisting}
>>> show(fitted_meters, range_=(0, (19, 4)))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-4dea6222540afc3cf0b84d79ca2bc728.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent However, reinstating the repetition constraint and permitting a
greater variety of meters gives an even closer fitting than the very first
example. Not only do the 11/8 and 17/8 offsets align at downbeats, but the
three-weight offset at 25/8 matches the downbeat of a 3/4 meter with two-weight
accents on both its second and third beat as well as the following downbeat.

\begin{comment}
<abjad>
permitted_meters = metertools.MeterInventory([
    (2, 4), (4, 8), (3, 4), (6, 8), (7, 8), (4, 4),
    ])
fitted_meters = metertools.Meter.fit_meters_to_expr(
    expr=offset_counter,
    maximum_run_length=1,
    meters=permitted_meters,
    )
show(offset_counter, range_=(0, (19, 4)))
show(fitted_meters, range_=(0, (19, 4)))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> permitted_meters = metertools.MeterInventory([
...     (2, 4), (4, 8), (3, 4), (6, 8), (7, 8), (4, 4),
...     ])
>>> fitted_meters = metertools.Meter.fit_meters_to_expr(
...     expr=offset_counter,
...     maximum_run_length=1,
...     meters=permitted_meters,
...     )
>>> show(offset_counter, range_=(0, (19, 4)))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-0be2900a4872bf90fe9bfb22c1e66b72.pdf}
\begin{lstlisting}
>>> show(fitted_meters, range_=(0, (19, 4)))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-a1f558ce38e84f316c17684a30bd0fac.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Increasing the number of permitted offsets even further does not
necessarily improve results. A better initial meter fitting -- like the initial
9/8 here -- often diminishes the choices possible afterward.

\begin{comment}
<abjad>
permitted_meters = metertools.MeterInventory([
    (2, 4), (3, 16), (3, 4), (4, 4), (4, 8), (5, 16),
    (5, 4), (5, 8), (6, 8), (7, 8), (9, 8),
    ])
poorly_fitted_meters = metertools.Meter.fit_meters_to_expr(
    expr=offset_counter,
    maximum_run_length=1,
    meters=permitted_meters,
    )
show(offset_counter, range_=(0, (19, 4)))
show(poorly_fitted_meters, range_=(0, (19, 4)))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> permitted_meters = metertools.MeterInventory([
...     (2, 4), (3, 16), (3, 4), (4, 4), (4, 8), (5, 16),
...     (5, 4), (5, 8), (6, 8), (7, 8), (9, 8),
...     ])
>>> poorly_fitted_meters = metertools.Meter.fit_meters_to_expr(
...     expr=offset_counter,
...     maximum_run_length=1,
...     meters=permitted_meters,
...     )
>>> show(offset_counter, range_=(0, (19, 4)))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-0be2900a4872bf90fe9bfb22c1e66b72.pdf}
\begin{lstlisting}
>>> show(poorly_fitted_meters, range_=(0, (19, 4)))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-78da5486599d2faeead3b3ce63e0ba05.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent The process of meter fitting described here is not perfect. While
useful for creating generally convincing metrical solutions to dense timespan
structures, meter fitting could probably be better solved through human
intervention. The fitting process often over-emphasizes local attack point
maxima while ignoring larger or more elegant metrical patterns. Likewise, the
process often provides an accurate fitting for the very first meter, but causes
a cascade of poor solutions for every following meter. Where procedural meter
fitting wins over human intervention is in speed. Solutions to enormous
timespan inventories with hundreds or thousands of timespans can be found in
less than a second, facilitating the rapid sketching and revising of
timespan-based musical structures.

Meter fitting can be considered as a kind of constraint problem. The set of
permitted meters act as a search space while each progressive selection of
offsets from the input offset counter act as the problem to solve against. In
that light, improvements might involve searching for meter solutions with
increased \emph{lookahead} -- that is, fitting the current meter based not only
on its response to a selection of offsets, but also on how well any meter
following it would score. Searching the offset counter for patterns, changing
the weighting algorithm of metric accent kernels, or jumping directly to the
attack point maxima in the input offset counter and solving forwards and
backwards from them are also possible avenues for improvement.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Synthesizing time techniques}
\label{sec:synthesizing-time-techniques}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The techniques outlined in this chapter -- timespan inventories,
timespan-makers, rhythm-makers, meter fitting and rewriting -- describe various
ways of modeling, creating and manipulating aspects of musical score. Taken
separately, none of them can ever result in the rhythmic framework for a
polyphonic piece of music. However, by combining all of them together, it is
possible to construct powerful tools for generating arbitrarily large amounts
of notation.

The following \texttt{build\_score()} function outlines one possible approach
to combining these techniques. This function creates a score from a
rhythm-maker, a sequence of permitted meters, a score template and a timespan
inventory. The timespan inventory must contain performed timespans whose voice
names align with the voice names in the score produced by the score template.
For example, Abjad's \texttt{GroupedRhythmicStavesScoreTemplate} class can
produce scores containing voices with names like \enquote{Voice 1},
\enquote{Voice 2} and so forth. The timespan inventory used for this example --
created earlier in this chapter -- contains performed timespans with the voice
names \enquote{Voice 1}, \enquote{Voice 2}, \enquote{Voice 3} and
\enquote{Voice 4}, requiring a score template capable of creating scores with
four staves of one voice each.

\begin{comment}
<abjad>
show(timespan_inventory, key='voice_name')
score_template = templatetools.GroupedRhythmicStavesScoreTemplate(
    staff_count=4, with_clefs=True,
    )
score = score_template()
print(format(score))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> show(timespan_inventory, key='voice_name')
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-54d2fa8b64e488a84ee52a488caf28df.pdf}
\begin{lstlisting}
>>> score_template = templatetools.GroupedRhythmicStavesScoreTemplate(
...     staff_count=4, with_clefs=True,
...     )
>>> score = score_template()
>>> print(format(score))
\context Score = "Grouped Rhythmic Staves Score" <<
    \context StaffGroup = "Grouped Rhythmic Staves Staff Group" <<
        \context RhythmicStaff = "Staff 1" {
            \clef "percussion"
            \context Voice = "Voice 1" {
            }
        }
        \context RhythmicStaff = "Staff 2" {
            \clef "percussion"
            \context Voice = "Voice 2" {
            }
        }
        \context RhythmicStaff = "Staff 3" {
            \clef "percussion"
            \context Voice = "Voice 3" {
            }
        }
        \context RhythmicStaff = "Staff 4" {
            \clef "percussion"
            \context Voice = "Voice 4" {
            }
        }
    >>
>>
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

Score building proceeds by first fitting the permitted meters against the
timespan inventory and calculating their meter boundaries -- the offsets of
each downbeat, as well as the virtual downbeat, the \enquote{end-beat}, after
the final meter. Then the timespans in the input timespan inventory are
separated into new timespan inventories according to their associated voice
names, with these new inventories stored in a dictionary whose keys are those
same voice name. The score template generates an unpopulated score and the
voice components in this score are iterated over. For each iterated voice, an
inventory of timespans is retrieved from the \texttt{all\_voicewise\_timespans}
dictionary. If no inventory exists, an empty one is created. The associated
performed timespans are partitioned into contiguous groups in order to
facilitate rhythm generation. Each partitioned group is passed, along with the
input rhythm-maker, the fitted meter boundaries, and a seed value -- the number
of performed timespan groups encountered so far -- to a rhythm generation
subroutine, with the resulting phrase container appended into the current
voice. If a gap is encountered between two partitioned groups, between the
beginning of the first partitioned group and the beginning of the score -- the
offset 0, or between the end of the last partitioned group and the final meter
boundary, "silent music" will be created in the form of rests grouped into a
container, with that container then inserted into the current voice.

\begin{comment}
<abjadextract dissertation.py.time_tools:build_score />[strip_prompt]
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
def build_score(
    performed_rhythm_maker,
    permitted_meters,
    score_template,
    timespan_inventory,
    ):
    fitted_meters, meter_boundaries = get_meters_and_meter_boundaries(
        timespan_inventory, permitted_meters)
    all_voicewise_timespans = get_all_voicewise_timespans(timespan_inventory)
    seed = 0
    score = score_template()
    for voice in iterate(score).by_class(Voice):
        if voice.name not in all_voicewise_timespans:
            all_voicewise_timespans[voice.name] = \
                timespantools.TimespanInventory()
        voice_timespans = all_voicewise_timespans[voice.name]
        previous_stop_offset = Offset(0)
        for shard in voice_timespans.partition(include_tangent_timespans=True):
            if shard.start_offset != previous_stop_offset:
                silent_music = make_silent_music(
                    meter_boundaries=meter_boundaries,
                    start_offset=previous_stop_offset,
                    stop_offset=shard.start_offset,
                    )
                voice.append(silent_music)
            performed_music = make_performed_music(
                meter_boundaries=meter_boundaries,
                rhythm_maker=performed_rhythm_maker,
                seed=seed,
                timespans=shard,
                )
            voice.append(performed_music)
            seed += 1
            previous_stop_offset = shard.stop_offset
        if previous_stop_offset != meter_boundaries[-1]:
            silent_music = make_silent_music(
                meter_boundaries=meter_boundaries,
                start_offset=previous_stop_offset,
                stop_offset=meter_boundaries[-1],
                )
            voice.append(silent_music)
        for phrase in voice:
            rewrite_meters(phrase, fitted_meters, meter_boundaries)
    add_time_signature_context(score, fitted_meters)
    return score
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent A meter sequence of equal or greater duration to the input timespan
inventory can be produced through fitting a collection of permitted meters
against that same input timespan inventory. The sequence of offsets found at
the boundaries of each fitted meter can then be determined by computing the
cumulative sums of the durations of the fitted meters. These boundary offsets
will be used to split timespans before they are fed to rhythm-makers for rhythm
generation in order to ensure that no generated rhythm crosses any bar-lines.

\begin{comment}
<abjadextract dissertation.py.time_tools:get_meters_and_meter_boundaries />[strip_prompt]
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
def get_meters_and_meter_boundaries(timespan_inventory, permitted_meters):
    offset_counter = metertools.OffsetCounter(timespan_inventory)
    fitted_meters = metertools.Meter.fit_meters_to_expr(
        expr=offset_counter,
        maximum_run_length=1,
        meters=permitted_meters,
        )
    meter_durations = [Duration(_) for _ in fitted_meters]
    meter_boundaries = mathtools.cumulative_sums(
        meter_durations,
        start=Offset(0),
        )
    return fitted_meters, meter_boundaries
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Each of the performed timespans in the input timespan inventory was
configured with a voice name, allowing that timespan to be associated with a
voice context in the score hierarchy produced by the input score template. As
demonstrated earlier, Abjad components can be indexed by context name
regardless of the depth of the named context in the score hierarchy.

\begin{comment}
<abjad>
timespan = timespan_inventory[0]
print(format(timespan))
score = score_template()
voice = score[timespan.voice_name]
for component in inspect_(voice).get_parentage():
    component

</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespan = timespan_inventory[0]
>>> print(format(timespan))
consort.tools.PerformedTimespan(
    start_offset=durationtools.Offset(0, 1),
    stop_offset=durationtools.Offset(1, 4),
    original_start_offset=durationtools.Offset(9, 2),
    original_stop_offset=durationtools.Offset(19, 4),
    voice_name='Voice 3',
    )
\end{lstlisting}
\begin{lstlisting}
>>> score = score_template()
>>> voice = score[timespan.voice_name]
>>> for component in inspect_(voice).get_parentage():
...     component
...
Voice()
<RhythmicStaff-"Staff 3"{1}>
<StaffGroup-"Grouped Rhythmic Staves Staff Group"<<4>>>
<Score-"Grouped Rhythmic Staves Score"<<1>>>
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent In order to populate each voice in the score, the timespans in the
timespan inventory need to be separated into \emph{voice-wise} timespan
inventories, each only containing timespans associated with the same voice.
This can be accomplished by building a dictionary whose keys are voice names
and whose values are timespan inventories.

\begin{comment}
<abjadextract dissertation.py.time_tools:get_all_voicewise_timespans />[strip_prompt]
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
def get_all_voicewise_timespans(timespan_inventory):
    voicewise_timespans = {}
    for timespan in timespan_inventory:
        voice_name = timespan.voice_name
        if voice_name not in voicewise_timespans:
            voicewise_timespans[voice_name] = timespantools.TimespanInventory()
        voicewise_timespans[voice_name].append(timespan)
    return voicewise_timespans
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Creating \emph{performed} music requires first splitting a contiguous
inventory of performed timespans by meter boundaries, collecting the shards
together into a new inventory and then calculating the durations of those
timespans. The resulting sequence of durations, along with an input
rhythm-maker and an optional seed value can be sent to another function for
rhythm generation.

\begin{comment}
<abjadextract dissertation.py.time_tools:make_performed_music />[strip_prompt]
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
def make_performed_music(rhythm_maker, timespans, meter_boundaries, seed=0):
    split_timespans = timespantools.TimespanInventory()
    for shard in timespans.split_at_offsets(meter_boundaries):
        split_timespans.extend(shard)
    durations = [_.duration for _ in split_timespans if _.duration]
    music = make_music(rhythm_maker, durations, seed=seed)
    return music
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Similarly, \emph{silent} music -- rests between groups of performed
timespans in each voice -- can be created by constructing a timespan which
outlines the gap between other performed timespans, splitting that timespan by
meter boundaries, collecting the durations of the split shards, and finally
passing those durations along with a rest-generating rhythm-maker to another
function for rhythm generation.

\begin{comment}
<abjadextract dissertation.py.time_tools:make_silent_music />[strip_prompt]
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
def make_silent_music(start_offset, stop_offset, meter_boundaries):
    silence_timespan = timespantools.Timespan(start_offset, stop_offset)
    shards = silence_timespan.split_at_offsets(meter_boundaries)
    durations = [_.duration for _ in shards if _.duration]
    mask = rhythmmakertools.mask_all()
    rhythm_maker = rhythmmakertools.NoteRhythmMaker(output_masks=[mask])
    music = make_music(rhythm_maker, durations)
    return music
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Both silent and performed music generation relies on the same core
rhythm generating function. This function calls its input rhythm-maker with a
sequence of durations and an optional seed value, which may be interpreted
variably depending on what kind of rhythm-maker was used, but which generally
results in the rotation of any sequence-like configured value in that
rhythm-maker, such as talea. The product of this first operation is a sequence
of component selections. Some massaging converts this selections into a
sequence of trivially-prolated containers and non-trivially prolated tuplets
which can then be wrapped inside a larger container representing a complete
phrase.

\begin{comment}
<abjadextract dissertation.py.time_tools:make_music />[strip_prompt]
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
def make_music(rhythm_maker, durations, seed=0):
    music = rhythm_maker(durations, seeds=seed)
    for i, division in enumerate(music):
        if len(division) == 1 and isinstance(division[0], scoretools.Tuplet):
            music[i] = division[0]
        else:
            music[i] = scoretools.Container(division)
    music = scoretools.Container(music)
    return music
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent After all phrases for a voice have been generated, their meters are
rewritten. This process involves simultaneously iterating through both the
divisions in each phrase along with pairs of meters and meter downbeat
offsets -- that is, the offset from the origin of the score where each meter
begins.\footnote{More optimizations to this joint container / meter iteration
are obviously possible. Some have even been implemented in Consort's source.
Such optimization include associating meters with their own timespans, and
storing these meter-timespans in an optimized interval-tree data structure
allowing rapid retrieval by both offset and timespan intersection. For the sake
of pedagogical clarity, a more naive approach is used here.} Unprolated
division containers are rewritten according to the meter active when they
begin. Because a division may start \emph{after} a meter has begun it is
necessary to calculate the difference between each unprolated division's start
offset and each meter's start offset. This difference is passed to the
\texttt{MutationAgent}'s \texttt{rewrite\_meter()} method via the
\texttt{initial\_offset} keyword, allowing the division to be properly aligned
against the desired meter. Prolated divisions -- tuplets -- are rewritten
solely with respect to the duration of their contents, not to the prevailing
meter. That is, a 5:4 tuplet in a 4/8 measure is rewritten with a meter of 5/8,
not of 4/8.

\begin{comment}
<abjadextract dissertation.py.time_tools:rewrite_meters />[strip_prompt]
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
def rewrite_meters(phrase, meters, meter_boundaries):
    pairs = list(zip(meters, meter_boundaries))
    for division in phrase:
        division_offset = inspect_(division).get_timespan().start_offset
        while 1 < len(pairs) and pairs[1][1] <= division_offset:
            pairs.pop(0)
        if isinstance(division, scoretools.Tuplet):
            contents_duration = division._contents_duration
            meter = metertools.Meter(contents_duration)
            mutate(division).rewrite_meter(
                meter,
                boundary_depth=1,
                )
        else:
            meter, meter_boundary = pairs[0]
            initial_offset = division_offset - meter_boundary
            mutate(division).rewrite_meter(
                meter,
                boundary_depth=1,
                initial_offset=initial_offset,
                )
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent The final step in this score building process adds a
\enquote{floating time signature context} to the score, filled with typographic
spacer skips and time signature commands, one for each of the fitted meters.
This context appears as a row of time signatures floating above the topmost
staff in the score, allowing time signatures to be omitted from every staff in
the score and thereby improving proportional notation spacing. The time
signature context's \texttt{context\_name} property instructs LilyPond to look
for a context definition with that name and apply any typographic overrides
found there during the typesetting process. While LilyPond does not come
packaged with a \texttt{TimeSignatureContext} definition, examples of what such
a definition looks like can be found in the various \texttt{stylesheet}
sections of the source code appendices to this document.

\begin{comment}
<abjadextract dissertation.py.time_tools:add_time_signature_context />[strip_prompt]
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
def add_time_signature_context(score, meters):
    time_signatures = [_.implied_time_signature for _ in meters]
    measures = scoretools.make_spacer_skip_measures(time_signatures)
    time_signature_context = scoretools.Context(
        [measures],
        context_name='TimeSignatureContext',
        name='TimeSignatureContext',
        )
    score.insert(0, time_signature_context)
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Calling the \texttt{build\_score()} function generates a score as
described above. In this example, the function's arguments comprise a talea
rhythm-maker, an inventory of meters, as well as the previously defined score
template and timespan inventory.

\begin{comment}
<abjad>
permitted_meters = metertools.MeterInventory([
    (2, 4), (4, 8), (3, 4), (6, 8), (7, 8), (4, 4),
    ])
performed_rhythm_maker = rhythmmakertools.TaleaRhythmMaker(
    beam_specifier=rhythmmakertools.BeamSpecifier(
        beam_each_division=True,
        beam_divisions_together=True,
        ),
    extra_counts_per_division=(0, 1),
    talea=rhythmmakertools.Talea([1, 2, 3, 4, 5], 16),
    )
show(performed_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> permitted_meters = metertools.MeterInventory([
...     (2, 4), (4, 8), (3, 4), (6, 8), (7, 8), (4, 4),
...     ])
>>> performed_rhythm_maker = rhythmmakertools.TaleaRhythmMaker(
...     beam_specifier=rhythmmakertools.BeamSpecifier(
...         beam_each_division=True,
...         beam_divisions_together=True,
...         ),
...     extra_counts_per_division=(0, 1),
...     talea=rhythmmakertools.Talea([1, 2, 3, 4, 5], 16),
...     )
>>> show(performed_rhythm_maker, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-12a3ce90ede7ebf565493e80cd2b641b.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent For clarity, the phrases and their internal divisions have been
annotated via Consort's \texttt{annotate} function. This function draws thick
brackets underneath each staff, with the lower bracket indicating the overall
phrase grouping and the inner brackets indicating divisions within each phrase.
Entirely silent phrasing brackets are drawn with dashed rather than solid
lines.

\begin{comment}
<abjad>[stylesheet=../consort-small.ily]
score = build_score(
    performed_rhythm_maker=performed_rhythm_maker,
    permitted_meters=permitted_meters,
    score_template=score_template,
    timespan_inventory=timespan_inventory,
    )
consort.annotate(score)
show(score)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> score = build_score(
...     performed_rhythm_maker=performed_rhythm_maker,
...     permitted_meters=permitted_meters,
...     score_template=score_template,
...     timespan_inventory=timespan_inventory,
...     )
>>> consort.annotate(score)
>>> show(score)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-8ece1468ead3048f49429d2eead03474.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Large-scale variations are possible simply by altering the arguments
to the \texttt{build\_score()} function. For example, the timespan inventory
can be reflected around its axis and stretched from a duration of 19/4 to 25/4.
This will change the overall duration and phrase density of the resulting score
while maintaining the character of its surface rhythms.

\begin{comment}
<abjad>[stylesheet=../consort-small.ily]
multiplier = Duration(24, 4) / Duration(19, 4)
timespan_inventory = timespan_inventory.reflect()
timespan_inventory = timespan_inventory.stretch(multiplier)
timespan_inventory = timespan_inventory.round_offsets(Duration(1, 8))
show(timespan_inventory, key='voice_name')
score = build_score(
    performed_rhythm_maker=performed_rhythm_maker,
    permitted_meters=permitted_meters,
    score_template=score_template,
    timespan_inventory=timespan_inventory,
    )
consort.annotate(score)
show(score)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> multiplier = Duration(24, 4) / Duration(19, 4)
>>> timespan_inventory = timespan_inventory.reflect()
>>> timespan_inventory = timespan_inventory.stretch(multiplier)
>>> timespan_inventory = timespan_inventory.round_offsets(Duration(1, 8))
>>> show(timespan_inventory, key='voice_name')
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-2946788e9f258035fb10f3011cd4a737.pdf}
\begin{lstlisting}
>>> score = build_score(
...     performed_rhythm_maker=performed_rhythm_maker,
...     permitted_meters=permitted_meters,
...     score_template=score_template,
...     timespan_inventory=timespan_inventory,
...     )
>>> consort.annotate(score)
>>> show(score)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-95fbbd917e003934806c4cf066250909.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Many other variations and extensions to the basic score-building
algorithm outlined above are possible. The input rhythm-maker could be varied
or replaced by a composite rhythm-maker. The score generation process could be
extended so that rhythm-makers could be stored on the performed timespans
themselves, allowing each performed timespan to specify its local rhythmic
language. Multiple timespan inventories could be combined together using the
various logical operations to implement masking or fusing when timespans from
one inventory overlap those from another. In fact, all of these extensions and
variations are employed in Consort's own score generation process.