%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Tools for modeling time, rhythm and meter}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{comment}
<abjad>[hide=true]
import collections
import consort
</abjad>
\end{comment}

Consort implements a model of composition which relies on a number of
interrelated but distinct approaches to working with musical time. Abjad's
\emph{\index{timespan}} object suggests a \enquote{coarse} approach to musical
time. Timespans represent arbitrary durated events on a timeline, without
respect for score hierarchy or meter. They are well-suited for modeling large
scale phrasing or gestural density structures and can handle overlap,
splitting, stretching and other transformations without requiring any
notational reality. Annotated \index{timespan}s allow composers to position
metadata anywhere on a timeline, much like arranging audio regions in a DAW.
Moreover, every durated object in a score hierarchy can be described as a
\index{timespan}, allowing score components to engage in abstract time
relations. In contrast, notated rhythms, composed of note, rest, tie and tuplet
objects -- among others, provide the most \enquote{fine-grained} approach to
musical time. While incredibly expressive, fully notated rhythms are
potentially complex to create, and must ultimately be anchored in a score
hierarchy. Rhythm-maker classes ameliorate the complexity of creating notated
rhythms by providing a high-level interface to the process of rhythmic
generation. Meter coordinates time and rhythm vertically across score
hierarchy, and bridges the coarse and fine stages of rhythmic interpretation.
Meter sequences can be generated from \index{timespan}-based phrase structures,
and those meter sequences used to transform notated rhythms in turn. A thorough
discussion of the implementations of time models and their implications will
clarify a later analysis of Consort's score interpretation stage.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Timespans}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\emph{Timespans} model left-closed / right-open intervals of time positioned
absolutely along a timeline. This means that every \index{timespan} describes
an interval of time starting with -- and including -- some start offset and
leading up to -- but not including -- some stop offset. Note that all leaves in
a score describe such half-bounded interval of time. Adjacent notes in a score
do not overlap, but rather abut one another because their timespans do not
overlap. In fact, every durated object in a score -- every note, chord, rest,
measure, staff, and even the score itself -- can be described in terms of
timespans. Yet while score objects can always be described in terms of
timespans, timespans themselved do not -- by definition -- refer to any score
objects. Abjad implements timespans as immutable constants, much like Abjad's
\texttt{Pitch} and \texttt{Duration} objects, and similarly to Python's
implementation of numbers or strings. Constancy allows timespans to avoid a
variety of computational reference problems. Multiple objects can reference the
same timespan without fear of that timespan changing state, much as multiple
objects can reference the integer 11 without fear that it will change into the
integer 5.

Abjad implements timespans via the \texttt{timespantools.Timespan} class. The
following timespan begins at the offset 1/4 and continues up until the offset
3/2:

\begin{comment}
<abjad>
timespan = timespantools.Timespan(
    start_offset=Offset(1, 4),
    stop_offset=Offset(3, 2),
    )
print(timespan)
show(timespan)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespan = timespantools.Timespan(
...     start_offset=Offset(1, 4),
...     stop_offset=Offset(3, 2),
...     )
>>> print(timespan)
Timespan(start_offset=Offset(1, 4), stop_offset=Offset(3, 2))
\end{lstlisting}
\begin{lstlisting}
>>> show(timespan)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-3197d8ddef560bdde0c460c116b33801.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent The \texttt{Timespan} class provides a large number of methods and
properties for inspecting timespans, comparing them to other timespans or
offsets, and for operating on timespans to generate new timespans. Once
instantiated, the timespan can be examined for its start offset, stop offset
and duration. Because of the \texttt{Timespan} class' immutability, these
properties are read-only and therefore can only be accessed, but not changed.

\begin{comment}
<abjad>
timespan.start_offset
timespan.stop_offset
timespan.duration
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespan.start_offset
Offset(1, 4)
\end{lstlisting}
\begin{lstlisting}
>>> timespan.stop_offset
Offset(3, 2)
\end{lstlisting}
\begin{lstlisting}
>>> timespan.duration
Duration(5, 4)
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent A timespan's start offset must be equal to or less than its stop
offset. Timespans with identical start and stop offsets have a duration of 0
and effectively model a single time-point. Such timespans are considered not
\enquote{well-formed}:

\begin{comment}
<abjad>
timepoint_timespan = timespantools.Timespan(1, 1)
timepoint_timespan.duration
timepoint_timespan.is_well_formed
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timepoint_timespan = timespantools.Timespan(1, 1)
>>> timepoint_timespan.duration
Duration(0, 1)
\end{lstlisting}
\begin{lstlisting}
>>> timepoint_timespan.is_well_formed
False
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Both the \texttt{start\_offset} and \texttt{stop\_offset} keywords to
the \texttt{Timespan} class' initializer are optional, and default to Abjad's
built-in rational constants \texttt{NegativeInfinity} and \texttt{Infinity}
respectively. A timespan created without specifying either a start or stop
offset effectively describes the timespan which encompasses all possible
offsets in time:

\begin{comment}
<abjad>
infinite_timespan = timespantools.Timespan()
infinite_timespan.start_offset
infinite_timespan.stop_offset
infinite_timespan.duration
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> infinite_timespan = timespantools.Timespan()
>>> infinite_timespan.start_offset
NegativeInfinity
\end{lstlisting}
\begin{lstlisting}
>>> infinite_timespan.stop_offset
Infinity
\end{lstlisting}
\begin{lstlisting}
>>> infinite_timespan.duration
Infinity
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent By specifying only a start or stop offset, timespans can also be
created which encompass the infinite set of offsets up until some stop offset,
or the infinite set of offsets starting at and following some start-offset:

\begin{comment}
<abjad>
timespantools.Timespan(stop_offset=0)
timespantools.Timespan(start_offset=0)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespantools.Timespan(stop_offset=0)
Timespan(start_offset=NegativeInfinity, stop_offset=Offset(0, 1))
\end{lstlisting}
\begin{lstlisting}
>>> timespantools.Timespan(start_offset=0)
Timespan(start_offset=Offset(0, 1), stop_offset=Infinity)
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent \texttt{Timespan} objects also partake in Abjad's templating regime.
New timespans can be created from old ones through the use of the top-level
\texttt{new()} function:

\begin{comment}
<abjad>
new(timespan, stop_offset=(5, 16))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> new(timespan, stop_offset=(5, 16))
Timespan(start_offset=Offset(1, 4), stop_offset=Offset(5, 16))
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\subsection{Annotated timespans} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

While the \texttt{Timespan} class only has two configurable properties -- its
start offset and stop offset -- subclassing allows for the creation of new
classes with the same core functionality as \texttt{Timespan} but expanded to
allow for other configurable properties. As an example, \texttt{timespantools}
provides an \texttt{AnnotatedTimespan} class which subclasses \texttt{Timespan}
and adds a third read-only \texttt{annotation} property:

\begin{comment}
<abjad>
annotated_timespan = timespantools.AnnotatedTimespan(
    start_offset=(1, 8),
    stop_offset=(7, 8),
    annotation='Any arbitrary object can act as an annotation.'
    )
annotated_timespan.annotation
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> annotated_timespan = timespantools.AnnotatedTimespan(
...     start_offset=(1, 8),
...     stop_offset=(7, 8),
...     annotation='Any arbitrary object can act as an annotation.'
...     )
>>> annotated_timespan.annotation
'Any arbitrary object can act as an annotation.'
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Annotated timespans let composers position annotations or other
metadata arbitrarily along a timeline. If the annotation is itself a mutable
datastructure like a dictionary, that annotation can be used to store
increasing amounts of arbitrary information during the compositional process.
Abjad's top-level \texttt{new()} function can also be used to template new
annotated timespans from old ones, replacing one annotation with another:

\begin{comment}
<abjad>
metadata_timespan = new(annotated_timespan,
    stop_offset=(3, 2),
    annotation={
        'durations': ((1, 8), (1, 8), (3, 16)),
        'dynamic': indicatortools.Dynamic('ppp'),
        'pitch_segment': pitchtools.PitchSegment([0, 1, 4, 7]),
        },
    )
metadata_timespan.annotation['bow_contact_point'] = Multiplier(1, 3)
print(format(metadata_timespan))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> metadata_timespan = new(annotated_timespan,
...     stop_offset=(3, 2),
...     annotation={
...         'durations': ((1, 8), (1, 8), (3, 16)),
...         'dynamic': indicatortools.Dynamic('ppp'),
...         'pitch_segment': pitchtools.PitchSegment([0, 1, 4, 7]),
...         },
...     )
>>> metadata_timespan.annotation['bow_contact_point'] = Multiplier(1, 3)
>>> print(format(metadata_timespan))
timespantools.AnnotatedTimespan(
    start_offset=durationtools.Offset(1, 8),
    stop_offset=durationtools.Offset(3, 2),
    annotation={
        'bow_contact_point': durationtools.Multiplier(1, 3),
        'durations': (
            (1, 8),
            (1, 8),
            (3, 16),
            ),
        'dynamic': indicatortools.Dynamic(
            name='ppp',
            ),
        'pitch_segment': pitchtools.PitchSegment(
            (
                pitchtools.NumberedPitch(0),
                pitchtools.NumberedPitch(1),
                pitchtools.NumberedPitch(4),
                pitchtools.NumberedPitch(7),
                ),
            item_class=pitchtools.NumberedPitch,
            ),
        },
    )
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Other subclasses are also possible, allowing for even more
configurable properties, as well as new methods. Two \texttt{Timespan}
subclasses discussed later, \texttt{consort.PerformedTimespan} and
\texttt{consort.SilentTimespan}, are core components in Consort's score
interpretation algorithm.

\subsection{Time relations} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Abjad's \texttt{timespantools} provides a \texttt{TimeRelation} class and a
collection of factory methods for configuring \texttt{TimeRelation} instances
which formalize all possible dispositions of a timespan relative another
timespan or relative an offset\footnote{ The thirty-three time relation factory
functions contained in \texttt{timespantools} are
\texttt{offset\_happens\_after\_timespan\_starts()},
\texttt{offset\_happens\_after\_timespan\_stops()},
\texttt{offset\_happens\_before\_timespan\_starts()},
\texttt{offset\_happens\_before\_timespan\_stops()},
\texttt{offset\_happens\_during\_timespan()},
\texttt{offset\_happens\_when\_timespan\_starts()},
\texttt{offset\_happens\_when\_timespan\_stops()},
\texttt{timespan\_2\_contains\_timespan\_1\_improperly()},
\texttt{timespan\_2\_curtails\_timespan\_1()},
\texttt{timespan\_2\_delays\_timespan\_1()},
\texttt{timespan\_2\_happens\_during\_timespan\_1()},
\texttt{timespan\_2\_intersects\_timespan\_1()},
\texttt{timespan\_2\_is\_congruent\_to\_timespan\_1()},
\texttt{timespan\_2\_overlaps\_all\_of\_timespan\_1()},
\texttt{timespan\_2\_overlaps\_only\_start\_of\_timespan\_1()},
\texttt{timespan\_2\_overlaps\_only\_stop\_of\_timespan\_1()},
\texttt{timespan\_2\_overlaps\_start\_of\_timespan\_1()},
\texttt{timespan\_2\_overlaps\_stop\_of\_timespan\_1()},
\texttt{timespan\_2\_starts\_after\_timespan\_1\_starts()},
\texttt{timespan\_2\_starts\_after\_timespan\_1\_stops()},
\texttt{timespan\_2\_starts\_before\_timespan\_1\_starts()},
\texttt{timespan\_2\_starts\_before\_timespan\_1\_stops()},
\texttt{timespan\_2\_starts\_during\_timespan\_1()},
\texttt{timespan\_2\_starts\_when\_timespan\_1\_starts()},
\texttt{timespan\_2\_starts\_when\_timespan\_1\_stops()},
\texttt{timespan\_2\_stops\_after\_timespan\_1\_starts()},
\texttt{timespan\_2\_stops\_after\_timespan\_1\_stops()},
\texttt{timespan\_2\_stops\_before\_timespan\_1\_starts()},
\texttt{timespan\_2\_stops\_before\_timespan\_1\_stops()},
\texttt{timespan\_2\_stops\_during\_timespan\_1()},
\texttt{timespan\_2\_stops\_when\_timespan\_1\_starts()},
\texttt{timespan\_2\_stops\_when\_timespan\_1\_stops()} and
\texttt{timespan\_2\_trisects\_timespan\_1()}. }. Time relations may be
configured with or without reference to any timespans or offsets at all,
allowing for the possibility of modeling a purely abstract time relationship.

\begin{comment}
<abjad>
time_relation_1 = timespantools.timespan_2_intersects_timespan_1()
print(format(time_relation_1))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> time_relation_1 = timespantools.timespan_2_intersects_timespan_1()
>>> print(format(time_relation_1))
timespantools.TimespanTimespanTimeRelation(
    inequality=timespantools.CompoundInequality(
        [
            timespantools.CompoundInequality(
                [
                    timespantools.SimpleInequality('timespan_1.start_offset <= timespan_2.start_offset'),
                    timespantools.SimpleInequality('timespan_2.start_offset < timespan_1.stop_offset'),
                    ],
                logical_operator='and',
                ),
            timespantools.CompoundInequality(
                [
                    timespantools.SimpleInequality('timespan_2.start_offset <= timespan_1.start_offset'),
                    timespantools.SimpleInequality('timespan_1.start_offset < timespan_2.stop_offset'),
                    ],
                logical_operator='and',
                ),
            ],
        logical_operator='or',
        ),
    )
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent A \enquote{half-configured} time relation is also possible. Such
object acts like a kind of \enquote{frozen} predicate function, and can be
called like a function on another timespan or offset to return a truth value.

\begin{comment}
<abjad>
time_relation_2 = timespantools.timespan_2_intersects_timespan_1(
    timespan_1=timespantools.Timespan(0, 10),
    )
time_relation_2(timespan_2=timespantools.Timespan(5, 15))
time_relation_2(timespan_2=timespantools.Timespan(30, 45))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> time_relation_2 = timespantools.timespan_2_intersects_timespan_1(
...     timespan_1=timespantools.Timespan(0, 10),
...     )
>>> time_relation_2(timespan_2=timespantools.Timespan(5, 15))
True
\end{lstlisting}
\begin{lstlisting}
>>> time_relation_2(timespan_2=timespantools.Timespan(30, 45))
False
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Time relations which are \enquote{fully loaded} will be evaluated
immediately:

\begin{comment}
<abjad>
timespantools.timespan_2_intersects_timespan_1(
    timespan_1=timespantools.Timespan(1, 3),
    timespan_2=timespantools.Timespan(2, 4),
    )
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespantools.timespan_2_intersects_timespan_1(
...     timespan_1=timespantools.Timespan(1, 3),
...     timespan_2=timespantools.Timespan(2, 4),
...     )
True
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent The time relation factory functions in \texttt{timespantools} are
also implemented as methods on the \texttt{Timespan} class itself, allowing
composers to determine the various relations of any timespan relative any other
timespan or offset in an object-oriented fashion. The \texttt{Timespan} object
automatically \enquote{fills in} the \texttt{timespan\_1} argument to the
\texttt{TimeRelation} with itself, and can pass the optional argument to its
method call as the other object in the relation, allowing for the immediate
evaluation of the relation as either true or false.

Consider the following three timespans:

\begin{comment}
<abjad>
timespan_1 = timespantools.Timespan(0, 10)
timespan_2 = timespantools.Timespan(5, 15)
timespan_3 = timespantools.Timespan(10, 20)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespan_1 = timespantools.Timespan(0, 10)
>>> timespan_2 = timespantools.Timespan(5, 15)
>>> timespan_3 = timespantools.Timespan(10, 20)
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent These three timespans could be represented together visually like
this:

\begin{comment}
<abjad>[hide=true]
timespan_inventory = timespantools.TimespanInventory([
    timespan_1,
    timespan_2,
    timespan_3,
    ])
show(timespan_inventory)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-2bec073ccb80642bed69b2ea98034628.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent We can test for intersection between these three timespans via the
\texttt{intersects\_timespan()} method. Two timespans are considered to
intersect if any part of one timespan overlaps any part of another, and is
therefore commutative. Note that \texttt{timespan\_1} and \texttt{timespan\_3}
do not overlap even though they share the offset 10. As discussed earlier,
timespans are left-closed / right-open, meaning that while their start offset is
contained in the infinite set of offsets they cover, their stop offset is not.

\begin{comment}
<abjad>
timespan_1.intersects_timespan(timespan_2)
timespan_1.intersects_timespan(timespan_3)
timespan_2.intersects_timespan(timespan_1)
timespan_2.intersects_timespan(timespan_3)
timespan_3.intersects_timespan(timespan_1)
timespan_3.intersects_timespan(timespan_2)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespan_1.intersects_timespan(timespan_2)
True
\end{lstlisting}
\begin{lstlisting}
>>> timespan_1.intersects_timespan(timespan_3)
False
\end{lstlisting}
\begin{lstlisting}
>>> timespan_2.intersects_timespan(timespan_1)
True
\end{lstlisting}
\begin{lstlisting}
>>> timespan_2.intersects_timespan(timespan_3)
True
\end{lstlisting}
\begin{lstlisting}
>>> timespan_3.intersects_timespan(timespan_1)
False
\end{lstlisting}
\begin{lstlisting}
>>> timespan_3.intersects_timespan(timespan_2)
True
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Congruency tests whether two timespans share the same start and stop
offset. Every timespan is congruent with itself:

\begin{comment}
<abjad>
timespan_1.is_congruent_to_timespan(timespan_2)
timespan_1.is_congruent_to_timespan(timespan_1)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespan_1.is_congruent_to_timespan(timespan_2)
False
\end{lstlisting}
\begin{lstlisting}
>>> timespan_1.is_congruent_to_timespan(timespan_1)
True
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Tangency tests whether one timespan's stop offset is the same as
another timespan's start offset, or vice versa. Tangency can be used to
determine if a sorted collection of timespans are all contiguous together.

\begin{comment}
<abjad>
timespan_1.is_tangent_to_timespan(timespan_2)
timespan_1.is_tangent_to_timespan(timespan_3)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespan_1.is_tangent_to_timespan(timespan_2)
False
\end{lstlisting}
\begin{lstlisting}
>>> timespan_1.is_tangent_to_timespan(timespan_3)
True
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent A wide variety of other time relation predicates are also possible,
such as testing if a timespan intersects with a specific offset, testing if a
timespan overlaps only the beginning or end of another timespan, or testing if
a timespan contains another timespan entirely. These predicates make possible
many of the generative operations carried out on timespans.

\subsection{Operations on timespans} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Many \texttt{Timespan} methods provide transformations, such as translation,
scaling or offset rounding. Because timespans are immutable, these methods
create a new timespan based on the old one and then return the new, leaving
the old exactly as it was:

\begin{comment}
<abjad>
timespan = timespantools.Timespan(0, 15)
timespan.translate(3)
timespan.scale(3)
timespan.round_offsets(2)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespan = timespantools.Timespan(0, 15)
>>> timespan.translate(3)
Timespan(start_offset=Offset(3, 1), stop_offset=Offset(18, 1))
\end{lstlisting}
\begin{lstlisting}
>>> timespan.scale(3)
Timespan(start_offset=Offset(0, 1), stop_offset=Offset(45, 1))
\end{lstlisting}
\begin{lstlisting}
>>> timespan.round_offsets(2)
Timespan(start_offset=Offset(0, 1), stop_offset=Offset(16, 1))
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Internally, these generative methods are implemented via templating
as described earlier, allowing annotated timespan subclasses to partake in the
same templating functionality -- templating their start and / or stop offsets,
but maintaining all other previously configured properties:

\begin{comment}
<abjad>
annotated_timespan = timespantools.AnnotatedTimespan(0, 5, 'an annotation')
scaled_annotated_timespan = annotated_timespan.translate((-1, 3))
print(format(scaled_annotated_timespan))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> annotated_timespan = timespantools.AnnotatedTimespan(0, 5, 'an annotation')
>>> scaled_annotated_timespan = annotated_timespan.translate((-1, 3))
>>> print(format(scaled_annotated_timespan))
timespantools.AnnotatedTimespan(
    start_offset=durationtools.Offset(-1, 3),
    stop_offset=durationtools.Offset(14, 3),
    annotation='an annotation',
    )
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Some generative operations may return zero or more timespans,
aggregated in a datastructure called a \emph{timespan inventory}, which is
discussed at length in the following section. Splitting a timespan by an offset
is one such operation. If the offset to be split by is \emph{properly
contained}\footnote{\emph{Proper containment} of an offset means that the
offset is greater than the timespan's start offset and less than the timespan's
stop offset. \emph{Improper containment} would indicated the offset is greater
than or equal to the timespan's start offset and less than or equal to its stop
offset.} by the timespan to be split, two new timespans will be returned,
otherwise a \index{timespan inventory} containing a copy of the original input timespan
will be returned:

\begin{comment}
<abjad>
two_shards = timespan.split_at_offset(5)
print(format(two_shards))
one_shard = timespan.split_at_offset(10000)
print(format(one_shard))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> two_shards = timespan.split_at_offset(5)
>>> print(format(two_shards))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(0, 1),
            stop_offset=durationtools.Offset(5, 1),
            ),
        timespantools.Timespan(
            start_offset=durationtools.Offset(5, 1),
            stop_offset=durationtools.Offset(15, 1),
            ),
        ]
    )
\end{lstlisting}
\begin{lstlisting}
>>> one_shard = timespan.split_at_offset(10000)
>>> print(format(one_shard))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(0, 1),
            stop_offset=durationtools.Offset(15, 1),
            ),
        ]
    )
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent More complex operations between timespans which result in timespan
inventories include subtraction, as well as logical \texttt{AND}, \texttt{OR}
and \texttt{XOR}. These generative operations are conceptually \emph{set}
operations -- union, difference, intersection, symmetric difference, etc. --
performed on the two sets of offsets contained by the two timespan operands.
Consider these same set operations -- union, difference, intersection,
symmetric difference -- carried out on trivial sets in Python:

\begin{comment}
<abjad>
set([1, 2, 3]) | set([2, 3, 4])  # union
set([1, 2, 3]) - set([2, 3, 4])  # difference
set([1, 2, 3]) & set([2, 3, 4])  # intersection
set([1, 2, 3]) ^ set([2, 3, 4])  # symmetric difference
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> set([1, 2, 3]) | set([2, 3, 4])  # union
set([1, 2, 3, 4])
\end{lstlisting}
\begin{lstlisting}
>>> set([1, 2, 3]) - set([2, 3, 4])  # difference
set([1])
\end{lstlisting}
\begin{lstlisting}
>>> set([1, 2, 3]) & set([2, 3, 4])  # intersection
set([2, 3])
\end{lstlisting}
\begin{lstlisting}
>>> set([1, 2, 3]) ^ set([2, 3, 4])  # symmetric difference
set([1, 4])
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Set operations performed on timespans are conceptually identical, but
operate on infinite but bounded sets of offsets instead of discrete sets of
objects such as integers. For example, subtracting one timespan from another
computes the set difference of the offsets contained by both. This operation is
not commutative -- subtracting one timespan from another will not result in the
same ouput as subtract the latter from the former. Subtracting a timespan from
itself always results in the empty set of offsets: no timespan at all:

\begin{comment}
<abjad>
result = timespantools.Timespan(0, 10) - timespantools.Timespan(0, 10)
print(format(result))
result = timespantools.Timespan(0, 10) - timespantools.Timespan(5, 15)
print(format(result))
result = timespantools.Timespan(0, 10) - timespantools.Timespan(10, 20)
print(format(result))
result = timespantools.Timespan(5, 15) - timespantools.Timespan(0, 10)
print(format(result))
result = timespantools.Timespan(5, 15) - timespantools.Timespan(5, 15)
print(format(result))
result = timespantools.Timespan(5, 15) - timespantools.Timespan(10, 20)
print(format(result))
result = timespantools.Timespan(10, 20) - timespantools.Timespan(0, 10)
print(format(result))
result = timespantools.Timespan(10, 20) - timespantools.Timespan(5, 15)
print(format(result))
result = timespantools.Timespan(10, 20) - timespantools.Timespan(10, 20)
print(format(result))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> result = timespantools.Timespan(0, 10) - timespantools.Timespan(0, 10)
>>> print(format(result))
timespantools.TimespanInventory(
    []
    )
\end{lstlisting}
\begin{lstlisting}
>>> result = timespantools.Timespan(0, 10) - timespantools.Timespan(5, 15)
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(0, 1),
            stop_offset=durationtools.Offset(5, 1),
            ),
        ]
    )
\end{lstlisting}
\begin{lstlisting}
>>> result = timespantools.Timespan(0, 10) - timespantools.Timespan(10, 20)
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(0, 1),
            stop_offset=durationtools.Offset(10, 1),
            ),
        ]
    )
\end{lstlisting}
\begin{lstlisting}
>>> result = timespantools.Timespan(5, 15) - timespantools.Timespan(0, 10)
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(10, 1),
            stop_offset=durationtools.Offset(15, 1),
            ),
        ]
    )
\end{lstlisting}
\begin{lstlisting}
>>> result = timespantools.Timespan(5, 15) - timespantools.Timespan(5, 15)
>>> print(format(result))
timespantools.TimespanInventory(
    []
    )
\end{lstlisting}
\begin{lstlisting}
>>> result = timespantools.Timespan(5, 15) - timespantools.Timespan(10, 20)
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(5, 1),
            stop_offset=durationtools.Offset(10, 1),
            ),
        ]
    )
\end{lstlisting}
\begin{lstlisting}
>>> result = timespantools.Timespan(10, 20) - timespantools.Timespan(0, 10)
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(10, 1),
            stop_offset=durationtools.Offset(20, 1),
            ),
        ]
    )
\end{lstlisting}
\begin{lstlisting}
>>> result = timespantools.Timespan(10, 20) - timespantools.Timespan(5, 15)
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(15, 1),
            stop_offset=durationtools.Offset(20, 1),
            ),
        ]
    )
\end{lstlisting}
\begin{lstlisting}
>>> result = timespantools.Timespan(10, 20) - timespantools.Timespan(10, 20)
>>> print(format(result))
timespantools.TimespanInventory(
    []
    )
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Computing the logical \texttt{OR} of two timespans results in an
offset set union -- a commutative operation, effectively fusing the timespans
together if they overlap:

\begin{comment}
<abjad>
result = timespantools.Timespan(0, 10) | timespantools.Timespan(5, 15)
print(format(result))
result = timespantools.Timespan(0, 10) | timespantools.Timespan(10, 20)
print(format(result))
result = timespantools.Timespan(5, 15) | timespantools.Timespan(10, 20)
print(format(result))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> result = timespantools.Timespan(0, 10) | timespantools.Timespan(5, 15)
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(0, 1),
            stop_offset=durationtools.Offset(15, 1),
            ),
        ]
    )
\end{lstlisting}
\begin{lstlisting}
>>> result = timespantools.Timespan(0, 10) | timespantools.Timespan(10, 20)
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(0, 1),
            stop_offset=durationtools.Offset(20, 1),
            ),
        ]
    )
\end{lstlisting}
\begin{lstlisting}
>>> result = timespantools.Timespan(5, 15) | timespantools.Timespan(10, 20)
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(5, 1),
            stop_offset=durationtools.Offset(20, 1),
            ),
        ]
    )
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Unioning guarantees that all of the offsets contained in the two
input timespans will appear in the output timespan(s), whether or not any
overlap occurred:

\begin{comment}
<abjad>
result = timespantools.Timespan(10, 20) | timespantools.Timespan(25, 50)
print(format(result))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> result = timespantools.Timespan(10, 20) | timespantools.Timespan(25, 50)
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(10, 1),
            stop_offset=durationtools.Offset(20, 1),
            ),
        timespantools.Timespan(
            start_offset=durationtools.Offset(25, 1),
            stop_offset=durationtools.Offset(50, 1),
            ),
        ]
    )
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent The logical \texttt{AND} -- set intersection -- results in the
intersection of the two input timespans:

\begin{comment}
<abjad>
result = timespantools.Timespan(0, 10) & timespantools.Timespan(5, 15)
print(format(result))
result = timespantools.Timespan(0, 10) & timespantools.Timespan(10, 20)
print(format(result))
result = timespantools.Timespan(5, 15) & timespantools.Timespan(10, 20)
print(format(result))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> result = timespantools.Timespan(0, 10) & timespantools.Timespan(5, 15)
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(5, 1),
            stop_offset=durationtools.Offset(10, 1),
            ),
        ]
    )
\end{lstlisting}
\begin{lstlisting}
>>> result = timespantools.Timespan(0, 10) & timespantools.Timespan(10, 20)
>>> print(format(result))
timespantools.TimespanInventory(
    []
    )
\end{lstlisting}
\begin{lstlisting}
>>> result = timespantools.Timespan(5, 15) & timespantools.Timespan(10, 20)
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(10, 1),
            stop_offset=durationtools.Offset(15, 1),
            ),
        ]
    )
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Logical \texttt{XOR} -- also known as exclusive \texttt{OR} --
results in the symmetric difference of the two input timespans. Only those
offsets which are contained by only one of the two input timespans will occur
in the output:

\begin{comment}
<abjad>
result = timespantools.Timespan(0, 10) ^ timespantools.Timespan(5, 15)
print(format(result))
result = timespantools.Timespan(0, 10) ^ timespantools.Timespan(10, 20)
print(format(result))
result = timespantools.Timespan(5, 15) ^ timespantools.Timespan(10, 20)
print(format(result))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> result = timespantools.Timespan(0, 10) ^ timespantools.Timespan(5, 15)
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(0, 1),
            stop_offset=durationtools.Offset(5, 1),
            ),
        timespantools.Timespan(
            start_offset=durationtools.Offset(10, 1),
            stop_offset=durationtools.Offset(15, 1),
            ),
        ]
    )
\end{lstlisting}
\begin{lstlisting}
>>> result = timespantools.Timespan(0, 10) ^ timespantools.Timespan(10, 20)
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(0, 1),
            stop_offset=durationtools.Offset(10, 1),
            ),
        timespantools.Timespan(
            start_offset=durationtools.Offset(10, 1),
            stop_offset=durationtools.Offset(20, 1),
            ),
        ]
    )
\end{lstlisting}
\begin{lstlisting}
>>> result = timespantools.Timespan(5, 15) ^ timespantools.Timespan(10, 20)
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(5, 1),
            stop_offset=durationtools.Offset(10, 1),
            ),
        timespantools.Timespan(
            start_offset=durationtools.Offset(15, 1),
            stop_offset=durationtools.Offset(20, 1),
            ),
        ]
    )
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent These operations, while perhaps initially rather abstract, are
incredibly powerful and artistically useful. They afford composers with the
procedural building blocks to mask temporal objects with one another, fuse them
together, or create lacunae. When extended to operate on many timespans at
once, wholesale transformations on massed timespans becomes practical.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Timespan inventories}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Abjad provides a \texttt{TimespanInventory} class specifically for aggregating
together a collection of \texttt{Timespan} objects.\footnote{ Consort provides
its own timespan collection class -- the \texttt{TimespanCollection}. This
class stores timespans internally not as a list, but in a balanced
\emph{interval tree}. An interval tree is an augmented, self-balancing binary
tree which stores start offsets and stop offsets. Such a datastructure
guarantees its contents are always sorted, and allows for highly optimized
lookups for timespan matching various search criteria. The
\texttt{TimespanCollection} class is used at crucial points during Consort's
interpretation stage simply for purposes of speed, and should be considered an
implementation detail. It provides only a few methods, specifically for
affording rapid search and retrieval of timespans intersecting other timespans
or offsets. With work, its internal datastructure may eventually be merged into
Abjad's own \texttt{TimespanInventory} class.} Timespan inventories implement
Python's \emph{mutable sequence protocol} which allow them to behave exactly
like lists, supporting appension, extension, insertion, indexing, sorting,
iteration and other procedures pertinent to list-like objects. They also
provide a wide variety of properties and methods for interacting with massed
groups of timespans such as searching for timespans matching a time relation,
splitting all timespans which interact with a given offset or partitioning one
inventory into multiple separate inventories of overlapping timespans.

A \index{timespan inventory} can be created with a list of zero or more
timespans as an argument, be appended to, or extended into:

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(0, 16),
    ])
timespan_inventory.append(timespantools.Timespan(5, 12))
timespan_inventory.extend([
    timespantools.Timespan(-2, 8),
    timespantools.Timespan(15, 20),
    ])
print(format(timespan_inventory))
show(timespan_inventory)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespan_inventory = timespantools.TimespanInventory([
...     timespantools.Timespan(0, 16),
...     ])
>>> timespan_inventory.append(timespantools.Timespan(5, 12))
>>> timespan_inventory.extend([
...     timespantools.Timespan(-2, 8),
...     timespantools.Timespan(15, 20),
...     ])
>>> print(format(timespan_inventory))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(0, 1),
            stop_offset=durationtools.Offset(16, 1),
            ),
        timespantools.Timespan(
            start_offset=durationtools.Offset(5, 1),
            stop_offset=durationtools.Offset(12, 1),
            ),
        timespantools.Timespan(
            start_offset=durationtools.Offset(-2, 1),
            stop_offset=durationtools.Offset(8, 1),
            ),
        timespantools.Timespan(
            start_offset=durationtools.Offset(15, 1),
            stop_offset=durationtools.Offset(20, 1),
            ),
        ]
    )
\end{lstlisting}
\begin{lstlisting}
>>> show(timespan_inventory)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-334f7faa0ec05aeb7fa5ff0a1269aca8.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Timespan inventories can also be queried for their length -- just
like any other sequence in Python --, be indexed into, or iterated over:

\begin{comment}
<abjad>
len(timespan_inventory)
timespan_inventory[1]
for timespan in timespan_inventory:
    timespan

</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> len(timespan_inventory)
4
\end{lstlisting}
\begin{lstlisting}
>>> timespan_inventory[1]
Timespan(start_offset=Offset(5, 1), stop_offset=Offset(12, 1))
\end{lstlisting}
\begin{lstlisting}
>>> for timespan in timespan_inventory:
...     timespan
...
Timespan(start_offset=Offset(0, 1), stop_offset=Offset(16, 1))
Timespan(start_offset=Offset(5, 1), stop_offset=Offset(12, 1))
Timespan(start_offset=Offset(-2, 1), stop_offset=Offset(8, 1))
Timespan(start_offset=Offset(15, 1), stop_offset=Offset(20, 1))
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Similarly, one timespan inventory can be created from another -- just
like one can create a Python list simply by calling \texttt{list()} on another
iterable object -- by passing the first \index{timespan inventory} as an
instantiation argument to the second. As many of the mutating methods
implemented on timespan inventories operate in place, this instantiation
pattern provides a simple means of \enquote{copying}, allowing composers to
duplicate a timespan structure before operating on it, thereby preserving the
original.

\begin{comment}
<abjad>
duplicate = timespantools.TimespanInventory(timespan_inventory)
duplicate == timespan_inventory
duplicate is timespan_inventory
print(format(duplicate))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> duplicate = timespantools.TimespanInventory(timespan_inventory)
>>> duplicate == timespan_inventory
True
\end{lstlisting}
\begin{lstlisting}
>>> duplicate is timespan_inventory
False
\end{lstlisting}
\begin{lstlisting}
>>> print(format(duplicate))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(0, 1),
            stop_offset=durationtools.Offset(16, 1),
            ),
        timespantools.Timespan(
            start_offset=durationtools.Offset(5, 1),
            stop_offset=durationtools.Offset(12, 1),
            ),
        timespantools.Timespan(
            start_offset=durationtools.Offset(-2, 1),
            stop_offset=durationtools.Offset(8, 1),
            ),
        timespantools.Timespan(
            start_offset=durationtools.Offset(15, 1),
            stop_offset=durationtools.Offset(20, 1),
            ),
        ]
    )
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Timespan inventories can be treated as timespans themselves, having a
start offset equal to the minimum start offset of any of their contained
timespans, and a stop offset equal to the maximum stop offset of any of their
contained timespans. Their start and stop offset properties allow them to
express a duration, as well as provide a concrete timespan representation.
Because timespan inventories can be modeled as timespans, they can even be
inserted into other timespan inventories.

\begin{comment}
<abjad>
timespan_inventory.start_offset
timespan_inventory.stop_offset
timespan_inventory.duration
timespan_inventory.timespan
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespan_inventory.start_offset
Offset(-2, 1)
\end{lstlisting}
\begin{lstlisting}
>>> timespan_inventory.stop_offset
Offset(20, 1)
\end{lstlisting}
\begin{lstlisting}
>>> timespan_inventory.duration
Duration(22, 1)
\end{lstlisting}
\begin{lstlisting}
>>> timespan_inventory.timespan
Timespan(start_offset=Offset(-2, 1), stop_offset=Offset(20, 1))
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Because timespan inventories aggregate multiple timespans together,
they also provide properties for describing collective qualities of those
timespans. \emph{Contiguity} tests if every timespan in the inventory is
tangent to another timespan, and does not overlap any other timespan,
\emph{overlap} tests if any timespan intersects any other timespan, and
\emph{well-formedness} tests that all timespans' durations are greater than 0.
A \index{timespan inventory} whose timespans are contiguous is necessarily
also non-overlapping.

\begin{comment}
<abjad>
timespan_inventory.all_are_contiguous
timespan_inventory.all_are_nonoverlapping
timespan_inventory.all_are_well_formed
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespan_inventory.all_are_contiguous
False
\end{lstlisting}
\begin{lstlisting}
>>> timespan_inventory.all_are_nonoverlapping
False
\end{lstlisting}
\begin{lstlisting}
>>> timespan_inventory.all_are_well_formed
True
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent The following timespan inventory's timespans are non-overlapping but
also non-contiguous:

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(0, 10),
    timespantools.Timespan(10, 20),
    timespantools.Timespan(30, 40),
    ])
show(timespan_inventory)
timespan_inventory.all_are_contiguous
timespan_inventory.all_are_nonoverlapping
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespan_inventory = timespantools.TimespanInventory([
...     timespantools.Timespan(0, 10),
...     timespantools.Timespan(10, 20),
...     timespantools.Timespan(30, 40),
...     ])
>>> show(timespan_inventory)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-a70ee4d73e99262ce1f5b0d756fdd03b.pdf}
\begin{lstlisting}
>>> timespan_inventory.all_are_contiguous
False
\end{lstlisting}
\begin{lstlisting}
>>> timespan_inventory.all_are_nonoverlapping
True
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent In contrast, this timespan inventory's timespans are both
non-overlapping and contiguous:

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(0, 10),
    timespantools.Timespan(10, 20),
    timespantools.Timespan(20, 30),
    ])
show(timespan_inventory)
timespan_inventory.all_are_contiguous
timespan_inventory.all_are_nonoverlapping
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespan_inventory = timespantools.TimespanInventory([
...     timespantools.Timespan(0, 10),
...     timespantools.Timespan(10, 20),
...     timespantools.Timespan(20, 30),
...     ])
>>> show(timespan_inventory)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-b3f55aeb2663321d68249a5274bfbcd4.pdf}
\begin{lstlisting}
>>> timespan_inventory.all_are_contiguous
True
\end{lstlisting}
\begin{lstlisting}
>>> timespan_inventory.all_are_nonoverlapping
True
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\subsection{Operations on timespan inventories} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Timespan inventory implement unioning, differencing and splitting methods which
parallel those implemented on timespans themselves. These methods
map the desired operation onto the contents of the inventory by, for example,
splitting every timespan contained in a given inventory by some offset. All of
these operations act in place. The intersection of all of the timespans in a
\index{timespan inventory} relative another timespan can be computed with the
\texttt{\&} operator, just like with single timespans:

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(0, 16),
    timespantools.Timespan(5, 12),
    timespantools.Timespan(-2, 8),
    ])
show(timespan_inventory)
timespan_operand = timespantools.Timespan(6, 10)
result = timespan_inventory & timespan_operand
show(result, range_=(-2, 16))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespan_inventory = timespantools.TimespanInventory([
...     timespantools.Timespan(0, 16),
...     timespantools.Timespan(5, 12),
...     timespantools.Timespan(-2, 8),
...     ])
>>> show(timespan_inventory)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-9b42007deeb7b033ec210fb673117f16.pdf}
\begin{lstlisting}
>>> timespan_operand = timespantools.Timespan(6, 10)
>>> result = timespan_inventory & timespan_operand
>>> show(result, range_=(-2, 16))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-780a4eb96f5a2ab70bd4ee332cb4121f.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Likewise, the offsets bound by a given timespan can be subtracted
from all of the timespans in a \index{timespan inventory}, effectively cutting a hole
in that inventory's timeline:

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(0, 16),
    timespantools.Timespan(5, 12),
    timespantools.Timespan(-2, 8),
    ])
show(timespan_inventory)
timespan_operand = timespantools.Timespan(6, 10)
result = timespan_inventory - timespan_operand
show(result)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespan_inventory = timespantools.TimespanInventory([
...     timespantools.Timespan(0, 16),
...     timespantools.Timespan(5, 12),
...     timespantools.Timespan(-2, 8),
...     ])
>>> show(timespan_inventory)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-9b42007deeb7b033ec210fb673117f16.pdf}
\begin{lstlisting}
>>> timespan_operand = timespantools.Timespan(6, 10)
>>> result = timespan_inventory - timespan_operand
>>> show(result)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-093cdaf46f6b94446ef82999702eda1c.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent As with a single timespan and an offset, an entire timespan inventory
can be split into two separate inventories via the \texttt{split\_at\_offset()}
method:

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(0, 3),
    timespantools.Timespan(3, 6),
    timespantools.Timespan(6, 10),
    ])
show(timespan_inventory)
left, right = timespan_inventory.split_at_offset(4)
show(left, range_=(0, 10))
show(right, range_=(0, 10))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespan_inventory = timespantools.TimespanInventory([
...     timespantools.Timespan(0, 3),
...     timespantools.Timespan(3, 6),
...     timespantools.Timespan(6, 10),
...     ])
>>> show(timespan_inventory)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-dc1472aa97e4c5d099167a69c04c00f6.pdf}
\begin{lstlisting}
>>> left, right = timespan_inventory.split_at_offset(4)
>>> show(left, range_=(0, 10))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-316a5eb07621d2627596f5326675ad66.pdf}
\begin{lstlisting}
>>> show(right, range_=(0, 10))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-d06f648bf6c12655be313c93786f9531.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent The \texttt{TimespanInventory} class also provides the convenience
method \texttt{split\_at\_offsets()} for splitting an inventory by an arbitrary
number of offsets at once:

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(0, 3),
    timespantools.Timespan(3, 6),
    timespantools.Timespan(6, 10),
    ])
show(timespan_inventory)
shards = timespan_inventory.split_at_offsets((2, 4, 7))
for shard in shards:
    show(shard, range_=(0, 10))

</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespan_inventory = timespantools.TimespanInventory([
...     timespantools.Timespan(0, 3),
...     timespantools.Timespan(3, 6),
...     timespantools.Timespan(6, 10),
...     ])
>>> show(timespan_inventory)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-dc1472aa97e4c5d099167a69c04c00f6.pdf}
\begin{lstlisting}
>>> shards = timespan_inventory.split_at_offsets((2, 4, 7))
>>> for shard in shards:
...     show(shard, range_=(0, 10))
...
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-352a5111f35bca1be6c7ff229f3ccf80.pdf}\\
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-9a4dc172fcf9ff904688085a13b8056c.pdf}\\
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-5d9e98d9c3963af4d0e090991c6f03f1.pdf}\\
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-430eaccdb8c664619fba4358c2edaec4.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

The mutating methods described above modify a timespan inventory
by mapping some procedure against its contents and some outside timespan or
offset. However, timespan inventories may also be modified by applying a
procedure solely against the contents of the inventory itself, mapping each
timespan in the collection against each other timespan in that collection.

For example, a timespan inventory can be modified by computing the logical
\texttt{OR} -- the set union -- of every timespan in the inventory relative
every other timespan, effectively fusing all overlapping timespans together:

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(-2, 2),
    timespantools.Timespan(0, 10),
    timespantools.Timespan(5, 12),
    ])
show(timespan_inventory)
result = timespan_inventory.compute_logical_or()
print(format(result))
show(result)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespan_inventory = timespantools.TimespanInventory([
...     timespantools.Timespan(-2, 2),
...     timespantools.Timespan(0, 10),
...     timespantools.Timespan(5, 12),
...     ])
>>> show(timespan_inventory)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-ddb69738dd7250f40ad276ee1dd102e0.pdf}
\begin{lstlisting}
>>> result = timespan_inventory.compute_logical_or()
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(-2, 1),
            stop_offset=durationtools.Offset(12, 1),
            ),
        ]
    )
\end{lstlisting}
\begin{lstlisting}
>>> show(result)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-3f810a28d4b1a316daea09727ada2da7.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent A timespan inventory can also be modified by computing the logical
\texttt{AND} of every timespan in the inventory relative every other timespan.
This procedure leaves only those offsets where every single timespan
overlaps:

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(-2, 8),
    timespantools.Timespan(0, 10),
    timespantools.Timespan(5, 12),
    ])
show(timespan_inventory)
result = timespan_inventory.compute_logical_and()
print(format(result))
show(result, range_=(-2, 12))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespan_inventory = timespantools.TimespanInventory([
...     timespantools.Timespan(-2, 8),
...     timespantools.Timespan(0, 10),
...     timespantools.Timespan(5, 12),
...     ])
>>> show(timespan_inventory)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-e523698cbed9e80d8d2d668c81490c34.pdf}
\begin{lstlisting}
>>> result = timespan_inventory.compute_logical_and()
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(5, 1),
            stop_offset=durationtools.Offset(8, 1),
            ),
        ]
    )
\end{lstlisting}
\begin{lstlisting}
>>> show(result, range_=(-2, 12))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-6c46cea5de76a50856a8dcc8e4ac39c2.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Lastly, computing the in-place logical \texttt{XOR} removes all
overlap from the timespan inventory, leaving only those offsets occupied by
only one timespan:

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(-2, 2),
    timespantools.Timespan(0, 10),
    timespantools.Timespan(5, 12),
    ])
show(timespan_inventory)
result = timespan_inventory.compute_logical_xor()
print(format(result))
show(result, range_=(-2, 12))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespan_inventory = timespantools.TimespanInventory([
...     timespantools.Timespan(-2, 2),
...     timespantools.Timespan(0, 10),
...     timespantools.Timespan(5, 12),
...     ])
>>> show(timespan_inventory)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-ddb69738dd7250f40ad276ee1dd102e0.pdf}
\begin{lstlisting}
>>> result = timespan_inventory.compute_logical_xor()
>>> print(format(result))
timespantools.TimespanInventory(
    [
        timespantools.Timespan(
            start_offset=durationtools.Offset(-2, 1),
            stop_offset=durationtools.Offset(0, 1),
            ),
        timespantools.Timespan(
            start_offset=durationtools.Offset(2, 1),
            stop_offset=durationtools.Offset(5, 1),
            ),
        timespantools.Timespan(
            start_offset=durationtools.Offset(10, 1),
            stop_offset=durationtools.Offset(12, 1),
            ),
        ]
    )
\end{lstlisting}
\begin{lstlisting}
>>> show(result, range_=(-2, 12))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-579456be41236bcc4c6f3ef2d8b96dad.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

Timespan partitioning separates a timespan inventory into groups of overlapping
and optionally tangent timespans, aggregated into new timespan inventories.
This procedure allows composers to isolate contiguous blocks of activity.

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(0, 10),
    timespantools.Timespan(5, 15),
    timespantools.Timespan(15, 20),
    timespantools.Timespan(25, 30),
    ])
show(timespan_inventory)
for shard in timespan_inventory.partition():
    show(shard, range_=(0, 30))

for shard in timespan_inventory.partition(include_tangent_timespans=True):
    show(shard, range_=(0, 30))

</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespan_inventory = timespantools.TimespanInventory([
...     timespantools.Timespan(0, 10),
...     timespantools.Timespan(5, 15),
...     timespantools.Timespan(15, 20),
...     timespantools.Timespan(25, 30),
...     ])
>>> show(timespan_inventory)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-529696911567b1b55dfc7ba216d6e59d.pdf}
\begin{lstlisting}
>>> for shard in timespan_inventory.partition():
...     show(shard, range_=(0, 30))
...
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-d6ab9da0c9636474e745d5612bb7bbbb.pdf}\\
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-b9c1bfc79717ac2213b1c37e123446e9.pdf}\\
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-0ab1942bf11e9b386e0aafdb9cd22edb.pdf}
\begin{lstlisting}
>>> for shard in timespan_inventory.partition(include_tangent_timespans=True):
...     show(shard, range_=(0, 30))
...
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-fa4b2285bd55e802c98578492760a139.pdf}\\
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-0ab1942bf11e9b386e0aafdb9cd22edb.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

Explosion separates a timespan inventory into one or more new inventories in an
attempt to limit the amount of overlap in each inventory. The number of output
inventories can be left unspecified, in which case explosion will generate as
many inventories as necessary to remove all overlap in every output inventory.
Explosion is also one the techniques used to create all of the timespan
inventory illustrations in this document.

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(-2, 8),
    timespantools.Timespan(-2, 1),
    timespantools.Timespan(0, 16),
    timespantools.Timespan(4, 7),
    timespantools.Timespan(4, 11),
    timespantools.Timespan(5, 12),
    timespantools.Timespan(11, 13),
    timespantools.Timespan(14, 17),
    timespantools.Timespan(15, 20),
    ])
show(timespan_inventory)
for shard in timespan_inventory.explode():
    show(shard, range_=(-2, 20))

</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespan_inventory = timespantools.TimespanInventory([
...     timespantools.Timespan(-2, 8),
...     timespantools.Timespan(-2, 1),
...     timespantools.Timespan(0, 16),
...     timespantools.Timespan(4, 7),
...     timespantools.Timespan(4, 11),
...     timespantools.Timespan(5, 12),
...     timespantools.Timespan(11, 13),
...     timespantools.Timespan(14, 17),
...     timespantools.Timespan(15, 20),
...     ])
>>> show(timespan_inventory)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-359034e786ace6978d7c8d20de502af4.pdf}
\begin{lstlisting}
>>> for shard in timespan_inventory.explode():
...     show(shard, range_=(-2, 20))
...
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-5d4e226e47ac141094425b650893d8a1.pdf}\\
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-6750ebe2d0c1709b9fe1980042e00494.pdf}\\
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-f3d09a846f0cc1685cd3cd6921b42e8f.pdf}\\
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-47efa4599636cbf16a928f0de48493c3.pdf}\\
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-0a98e35488893ff699bd7277aedd58a2.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent The number of output inventories can also be set explicitly, in which
case explosion will attempt to limit the amount of overlap as much as possible
while maintaining a similar level of overlap or density in each output
inventory.

\begin{comment}
<abjad>
for shard in timespan_inventory.explode(inventory_count=2):
    show(shard, range_=(-2, 20))

</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> for shard in timespan_inventory.explode(inventory_count=2):
...     show(shard, range_=(-2, 20))
...
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-26e209ed37cb9f072b01f0ec5988e380.pdf}\\
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-d2712905433a02c121f7cb8c4a6d47b6.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

The procedures outlined above provide high-level tools for interacting with
large numbers of timespans at once. All of the techniques described in later
chapters with regards to Consort's score interpretation algorithm -- timespan
consolidation, cascading overlap resolution, multiplexing multiple inventories
into one, demultiplexing one inventory into many, and so forth -- build on and
extend these techniques.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Annotated timespans in Consort}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

While the above datastructures and operations are potentially very useful, a
larger question remains: how can composers create enough timespans, and in
various patterns, to be musically interesting? Consort approaches this problem
by providing a collection of factory classes -- \emph{timespan-makers} -- which
can be configured and called to create arbitrarily large amounts of timespans.
However, before turning to a detailed discussion of timespan-makers, we must
discuss the products of the timespan themselves: Consort's annotated timespan
subclasses.

Consort provides two separate timespan subclasses which are integral, if
transient, components of its score interpretation algorithm: the
\texttt{PerformedTimespan} and \texttt{SilentTimespan} classes. These classes
are never created \enquote{by hand} during Consort's specification stage --
this is, explicitly instantiated by a composer while specifying a score segment
--, but are instead generated as transitory objects during interpretation.
Consort uses \texttt{PerformedTimespan} objects to specify locations in the
score timeline where some active musical material should appear, while
\texttt{SilentTimespan} objects specify tacet passages.

As will be described in more detail in the following chapters, Consort requires
composers to specify musical materials in \emph{layers}, and to specify
specifically in which voices in the score -- vertically -- that material should
occur in. During the course of interpretation, Consort separates out generated
timespans by voice name and layer into separate timespan inventories, and then
progressively masks out timespans in timespan inventories with lower layer
numbers by timespans in timespan inventories with higher layer numbers. This
process is somewhat analogous to the use of opaque layers in image editing
software. Both the \texttt{PerformedTimespan} and \texttt{SilentTimespan}
classes provide configurable properties for layer and voice name, in addition
to the start offset and stop offset properties provided by their parent
\texttt{Timespan} class. These properties allow the processes that generate
them to record \emph{when} they were created, as well as \emph{where} the
should appear in the score, should they survive the masking process.

Silent timespans do not appear in the score, but can be created for a
particular layer and used to simply erase any timespan in a lower layer by
masking.

\begin{comment}
<abjad>
performed_timespan = consort.PerformedTimespan(
    layer=1,
    start_offset=(1, 2),
    stop_offset=(7, 8),
    voice_name='Clarinet Voice',
    )
silent_timespan = consort.SilentTimespan(
    layer=2,
    start_offset=Offset(0, 1),
    stop_offset=Offset(1, 4),
    voice_name='Oboe Voice',
    )
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> performed_timespan = consort.PerformedTimespan(
...     layer=1,
...     start_offset=(1, 2),
...     stop_offset=(7, 8),
...     voice_name='Clarinet Voice',
...     )
>>> silent_timespan = consort.SilentTimespan(
...     layer=2,
...     start_offset=Offset(0, 1),
...     stop_offset=Offset(1, 4),
...     voice_name='Oboe Voice',
...     )
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\begin{comment}
<abjad>
performed_timespan = consort.PerformedTimespan(
    layer=1,
    minimum_duration=Duration(1, 8),
    music_specifier=consort.MusicSpecifier(),
    start_offset=Offset(1, 4),
    stop_offset=Offset(2, 1),
    voice_name='Violin 1 LH Voice',
    )
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> performed_timespan = consort.PerformedTimespan(
...     layer=1,
...     minimum_duration=Duration(1, 8),
...     music_specifier=consort.MusicSpecifier(),
...     start_offset=Offset(1, 4),
...     stop_offset=Offset(2, 1),
...     voice_name='Violin 1 LH Voice',
...     )
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

- forbid fusing

- forbid splitting

- minimum duration

- (additionally, music specifier: minimum phrase duration)

- divisions

- music

- music specifier

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Timespan-makers}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Consort provides a family of factory classes for producing timespans, each
implementing a different strategy for populating timespan inventories, but all
unified via the same callable interface. Timespan-makers take as input a mapping of
voice-names to \emph{music specifiers} -- arbitrary objects specifying how a
given timespan might be rendered as notation --, a \emph{target} timespan
indicating the minimum and maximum start offsets of any timespan created by the
timespan-maker, as well as an optional timespan inventory to modify in-place
and a \emph{layer} identifier indicating in which pass a particular timespan
was created,\footnote{Layer identifiers allow timespans to be sorted not only
by their position in time or by their associated voice name, but also by at
which point -- which \emph{layer} -- during some compositional process they
were created. Layer ordering allows masking processes to mask \enquote{earlier}
timespans with \enquote{later} ones.} and produce a timespan inventory as
output.

Timespan-makers fall into two broad categories: independent and dependent.
Independent timespan-makers create timespans without regard for any
pre-existing timespans, and therefore do not require being called with a
timespan inventory instance. Dependent timespan-makers create their timespans
based on the contents of a pre-existing timespan inventory, basing their output
on various aspects of the structure of their input.

All timespan-makers can be configured with \texttt{padding} and
\texttt{timespan\_specifier} keywords. Padding allows the timespan-maker to
force \enquote{silence} -- in the form of \texttt{SilentTimespan} objects --
around the beginnings and ends of contiguous groups of timespans it creates.
Timespan specifiers provide templates for some of the configurable properties
specific to performed timespans, such as \texttt{minimum\_duration} and
\texttt{forbid\_splitting}.

\subsection{Flooded timespan-makers} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Flooded timespan-makers are perhaps the simplest in the timespan-maker class
family. Their name derives from ubiquitous graphic-design \enquote{flood fill}
tools, used for filling an entire connected area.\footnote{Find a nice
reference to MacPaint, better than https://en.wikipedia.org/wiki/Flood\_fill}.
Flooded timespan-makers create one timespan for each voice in the input
voice-name-to-music-specifier mapping, filling the entirety of the provide
target timespan from beginning to end.

The following flooded timespan-maker will create a timespan inventory populated
by a single performed timespan associated with a \enquote{Violin Voice}
context, completely filling the span of 1/4 to 11/8.

\begin{comment}
<abjad>
music_specifiers = {'Violin Voice': 'violin music'}
target_timespan = timespantools.Timespan((1, 4), (11, 8))
flooded_timespan_maker = consort.FloodedTimespanMaker()
timespan_inventory = flooded_timespan_maker(
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
print(format(timespan_inventory))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> music_specifiers = {'Violin Voice': 'violin music'}
>>> target_timespan = timespantools.Timespan((1, 4), (11, 8))
>>> flooded_timespan_maker = consort.FloodedTimespanMaker()
>>> timespan_inventory = flooded_timespan_maker(
...     music_specifiers=music_specifiers,
...     target_timespan=target_timespan,
...     )
>>> print(format(timespan_inventory))
timespantools.TimespanInventory(
    [
        consort.tools.PerformedTimespan(
            start_offset=durationtools.Offset(1, 4),
            stop_offset=durationtools.Offset(11, 8),
            music_specifier='violin music',
            voice_name='Violin Voice',
            ),
        ]
    )
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Adding a second entry to the music specifier mapping results in two
timespans in the output. Likewise, calling the timespan-maker with a
\texttt{layer} keyword configures the output timespans with that layer number.
The layer is indicated in the illustration just above and to the right of the
beginning of each timespan.

\begin{comment}
<abjad>
music_specifiers = {
    'Violin Voice': 'violin music',
    'Cello Voice': 'cello music',
    }
timespan_inventory = flooded_timespan_maker(
    layer=3,
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
print(format(timespan_inventory))
show(timespan_inventory, key='voice_name')
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> music_specifiers = {
...     'Violin Voice': 'violin music',
...     'Cello Voice': 'cello music',
...     }
>>> timespan_inventory = flooded_timespan_maker(
...     layer=3,
...     music_specifiers=music_specifiers,
...     target_timespan=target_timespan,
...     )
>>> print(format(timespan_inventory))
timespantools.TimespanInventory(
    [
        consort.tools.PerformedTimespan(
            start_offset=durationtools.Offset(1, 4),
            stop_offset=durationtools.Offset(11, 8),
            layer=3,
            music_specifier='cello music',
            voice_name='Cello Voice',
            ),
        consort.tools.PerformedTimespan(
            start_offset=durationtools.Offset(1, 4),
            stop_offset=durationtools.Offset(11, 8),
            layer=3,
            music_specifier='violin music',
            voice_name='Violin Voice',
            ),
        ]
    )
\end{lstlisting}
\begin{lstlisting}
>>> show(timespan_inventory, key='voice_name')
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-f746878bb77dae0baec37bbeb02cb34f.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Configuring the timespan-maker with padding creates silent timespans
around the beginning and end of each group of output timespans on a per-voice
basis. The timespan-maker will also configure these silent timespans with any
specified layer number. Silent timespans are illustrated with dashed line, for
clarity.

\begin{comment}
<abjad>
flooded_timespan_maker = consort.FloodedTimespanMaker(
    padding=Duration(1, 4),
    timespan_specifier=consort.TimespanSpecifier(
        minimum_duration=Duration(1, 8),
        ),
    )
timespan_inventory = flooded_timespan_maker(
    layer=5,
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
print(format(timespan_inventory))
show(timespan_inventory, key='voice_name')
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> flooded_timespan_maker = consort.FloodedTimespanMaker(
...     padding=Duration(1, 4),
...     timespan_specifier=consort.TimespanSpecifier(
...         minimum_duration=Duration(1, 8),
...         ),
...     )
>>> timespan_inventory = flooded_timespan_maker(
...     layer=5,
...     music_specifiers=music_specifiers,
...     target_timespan=target_timespan,
...     )
>>> print(format(timespan_inventory))
timespantools.TimespanInventory(
    [
        consort.tools.SilentTimespan(
            start_offset=durationtools.Offset(0, 1),
            stop_offset=durationtools.Offset(1, 4),
            layer=5,
            voice_name='Violin Voice',
            ),
        consort.tools.SilentTimespan(
            start_offset=durationtools.Offset(0, 1),
            stop_offset=durationtools.Offset(1, 4),
            layer=5,
            voice_name='Cello Voice',
            ),
        consort.tools.PerformedTimespan(
            start_offset=durationtools.Offset(1, 4),
            stop_offset=durationtools.Offset(11, 8),
            layer=5,
            minimum_duration=durationtools.Duration(1, 8),
            music_specifier='cello music',
            voice_name='Cello Voice',
            ),
        consort.tools.PerformedTimespan(
            start_offset=durationtools.Offset(1, 4),
            stop_offset=durationtools.Offset(11, 8),
            layer=5,
            minimum_duration=durationtools.Duration(1, 8),
            music_specifier='violin music',
            voice_name='Violin Voice',
            ),
        consort.tools.SilentTimespan(
            start_offset=durationtools.Offset(11, 8),
            stop_offset=durationtools.Offset(13, 8),
            layer=5,
            voice_name='Violin Voice',
            ),
        consort.tools.SilentTimespan(
            start_offset=durationtools.Offset(11, 8),
            stop_offset=durationtools.Offset(13, 8),
            layer=5,
            voice_name='Cello Voice',
            ),
        ]
    )
\end{lstlisting}
\begin{lstlisting}
>>> show(timespan_inventory, key='voice_name')
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-b922fd9d63818b0a3f22a0377c8e95d3.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\subsection{Talea timespan-makers} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Consort's \texttt{TaleaTimespanMaker} class creates rich timespan textures
through the use of \emph{talea} -- infinitely cyclic duration patterns. Abjad
implements the concept of talea via the \texttt{Talea} class in its
\texttt{rhythmmakertools} subpackage. \texttt{Talea} defines a sequence of
durations in terms of a finite sequence of numerators paired with a
denominator. Once defined, they can be iterated over and indexed like an
infinite sequence.

\begin{comment}
<abjad>
talea = rhythmmakertools.Talea(
    counts=[1, 2, 3, 4],
    denominator=16,
    )
for index in range(10):
    talea[index]

</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> talea = rhythmmakertools.Talea(
...     counts=[1, 2, 3, 4],
...     denominator=16,
...     )
>>> for index in range(10):
...     talea[index]
...
NonreducedFraction(1, 16)
NonreducedFraction(2, 16)
NonreducedFraction(3, 16)
NonreducedFraction(4, 16)
NonreducedFraction(1, 16)
NonreducedFraction(2, 16)
NonreducedFraction(3, 16)
NonreducedFraction(4, 16)
NonreducedFraction(1, 16)
NonreducedFraction(2, 16)
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Talea timespan-makers make use of talea to control patterns of
performed duration and silences. These timespan-makers can create timespan in
\emph{synchronized} or \emph{unsynchronized} fashions. Unsynchronized timespan
generation proceeds voice-by-voice through the input
voice-name-to-music-specifier mapping, creating timespans from the start of the
target timespan until its stop, then wrapping around to the next voice. Such
unsynchronized timespan creation is ideal for creating massed textures of
seemingly-unrelated timespans. Careful management of silence patterns and
contiguous timespan grouping during synchronized creation can create dense,
overlapping textures or sparse, pointillistic ones. Contrastingly, synchronized
creation provides a mechanism for creating moments of shared attack across
voices, followed by shared silences.

All of the timespan inventories created in the following talea
timespan-maker examples will use the same music specifier mapping and target
timespan. An ordered dictionary from Python's \texttt{collections} module
guarantees that the timespan-makers process the music specifier entries in the
same order, from \enquote{Voice 1} through \enquote{Voice 4}.

\begin{comment}
<abjad>
import collections
music_specifiers = collections.OrderedDict([
    ('Voice 1', None),
    ('Voice 2', None),
    ('Voice 3', None),
    ('Voice 4', None),
    ])
target_timespan = timespantools.Timespan(0, (19, 4))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> import collections
>>> music_specifiers = collections.OrderedDict([
...     ('Voice 1', None),
...     ('Voice 2', None),
...     ('Voice 3', None),
...     ('Voice 4', None),
...     ])
>>> target_timespan = timespantools.Timespan(0, (19, 4))
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Without any manual configuration, talea timespan-makers generate
unsynchronized 1-length groups of 1/4-duration timespans, separated by
1/4-duration silences, creating the appearance of synchronization across
voices.

\begin{comment}
<abjad>
talea_timespan_maker = consort.TaleaTimespanMaker()
print(format(talea_timespan_maker))
result = talea_timespan_maker(
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
show(result, key='voice_name')
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> talea_timespan_maker = consort.TaleaTimespanMaker()
>>> print(format(talea_timespan_maker))
consort.tools.TaleaTimespanMaker(
    playing_talea=rhythmmakertools.Talea(
        counts=(4,),
        denominator=16,
        ),
    playing_groupings=(1,),
    repeat=True,
    silence_talea=rhythmmakertools.Talea(
        counts=(4,),
        denominator=16,
        ),
    step_anchor=Right,
    synchronize_groupings=False,
    synchronize_step=False,
    )
\end{lstlisting}
\begin{lstlisting}
>>> result = talea_timespan_maker(
...     music_specifiers=music_specifiers,
...     target_timespan=target_timespan,
...     )
>>> show(result, key='voice_name')
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-ebfd8c880740e50dc088f6304e30f973.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Changing the talea timespan-maker's \texttt{playing\_talea} from a
series of 1/4-durations to 1/4, 2/4, 3/4, 4/4 reveals the timespan-maker's
voice-wrapping behavior. Note how \enquote{Voice 1}'s timespans receive the
durations 1/4, 2/4, 3/4, 4/4, 1/4 and 2/4. \enquote{Voice 2} continues the
duration sequence with 3/4, 4/4 and so forth. The playing-duration talea
continues to wrap around the end of each voice's timespans to the beginning of
the next voice's.

\begin{comment}
<abjad>
talea_timespan_maker = new(
    talea_timespan_maker,
    playing_talea=rhythmmakertools.Talea(
        counts=(1, 2, 3, 4),
        denominator=4,
        )
    )
result = talea_timespan_maker(
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
show(result, key='voice_name')
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> talea_timespan_maker = new(
...     talea_timespan_maker,
...     playing_talea=rhythmmakertools.Talea(
...         counts=(1, 2, 3, 4),
...         denominator=4,
...         )
...     )
>>> result = talea_timespan_maker(
...     music_specifiers=music_specifiers,
...     target_timespan=target_timespan,
...     )
>>> show(result, key='voice_name')
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-a6702ee36d43cf93ba5728eaa6773fd1.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent The talea timespan-maker's \texttt{playing\_groupings} property
controls how many timespans are created together as contiguous groups. When a
grouping would run beyond the stop offset provided by the target timespan, that
grouping's length is chosen again for the first timespan group of the next
voice's timespans. Note how \enquote{Voice 2}'s final timespan, from 13/4 to
4/1, should -- according to the following talea timespan-maker's groupings
pattern -- begin a group of length 2. Because that grouping would run beyond
the target timespan's 19/4 stop offset, the following voice's first timespan
group receives the 2-length grouping instead.

\begin{comment}
<abjad>
talea_timespan_maker = new(
    talea_timespan_maker,
    playing_groupings=(1, 2),
    )
result = talea_timespan_maker(
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
show(result, key='voice_name')
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> talea_timespan_maker = new(
...     talea_timespan_maker,
...     playing_groupings=(1, 2),
...     )
>>> result = talea_timespan_maker(
...     music_specifiers=music_specifiers,
...     target_timespan=target_timespan,
...     )
>>> show(result, key='voice_name')
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-7f1b78377186311548aec873e02a00b0.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Reconfiguring the above talea timespan-maker with a different
\texttt{silence\_talea} produces patterned variations in the durations of
silences between timespan groups.

\begin{comment}
<abjad>
talea_timespan_maker = new(
    talea_timespan_maker,
    silence_talea=rhythmmakertools.Talea(
        counts=(3, 1, 1),
        denominator=8,
        ),
    )
result = talea_timespan_maker(
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
show(result, key='voice_name')
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> talea_timespan_maker = new(
...     talea_timespan_maker,
...     silence_talea=rhythmmakertools.Talea(
...         counts=(3, 1, 1),
...         denominator=8,
...         ),
...     )
>>> result = talea_timespan_maker(
...     music_specifiers=music_specifiers,
...     target_timespan=target_timespan,
...     )
>>> show(result, key='voice_name')
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-e7f5987861858d91a2809a56e791d1d1.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Likewise, changing the \texttt{initial\_silence\_talea} produces
varying amounts of silence at the beginning of each voice.

\begin{comment}
<abjad>
talea_timespan_maker = new(
    talea_timespan_maker,
    initial_silence_talea=rhythmmakertools.Talea(
        counts=(0, 1, 3),
        denominator=8,
        ),
    )
result = talea_timespan_maker(
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
show(result, key='voice_name')
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> talea_timespan_maker = new(
...     talea_timespan_maker,
...     initial_silence_talea=rhythmmakertools.Talea(
...         counts=(0, 1, 3),
...         denominator=8,
...         ),
...     )
>>> result = talea_timespan_maker(
...     music_specifiers=music_specifiers,
...     target_timespan=target_timespan,
...     )
>>> show(result, key='voice_name')
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-78aaaa427152e614120861752f4366e1.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Talea timespan-makers also provide for transformations derived from
the timespan inventory class itself. The \texttt{reflect} keyword configures
the timespan-maker to reflect its output timespan inventory around its own
axis, creating a \enquote{mirror image}.

\begin{comment}
<abjad>
talea_timespan_maker = new(
    talea_timespan_maker,
    reflect=True,
    )
result = talea_timespan_maker(
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
show(result, key='voice_name')
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> talea_timespan_maker = new(
...     talea_timespan_maker,
...     reflect=True,
...     )
>>> result = talea_timespan_maker(
...     music_specifiers=music_specifiers,
...     target_timespan=target_timespan,
...     )
>>> show(result, key='voice_name')
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-54d2fa8b64e488a84ee52a488caf28df.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Synchronized talea timespan-makers can be created simply by
configuring a new timespan-maker with its \texttt{synchronize\_step} flag set
to true. This option causes the timespan-maker to create all of the timespans
in every voice at once, then select some amount of silence between the end of
that vertically-synchronized group and the beginning of the next. Note here how
the duration of each timespan follows the timespan-maker's 1/4, 2/4, 3/4, 4/4,
5/4 pattern not from left-to-right by voice, but top-to-bottom by voice and
then left-to-right. The silence durations between these synchronized groups are
calculated from the end of the longest timespan in each group to the beginning
of the next group. Therefore the second group starts at 1/1 because the first
silence duration is 4/8 and the first group stops at 1/2. Similarly, the third
group starts at 5/2 (20/8) because the second silence duration is 7/8 and the
second group ended at 13/8. This silence \emph{stepping} can also be calculated
from the beginning of one group to the next, rather than from the end of one to
the beginning of the next, by changing the timespan-maker's
\texttt{step\_anchor} property from \texttt{Right} to \texttt{Left}. Such a
change helps guarantee the timing of initial attacks across synchronized
groups.

\begin{comment}
<abjad>
synchronized_talea_timespan_maker = consort.TaleaTimespanMaker(
    playing_talea=rhythmmakertools.Talea(
        counts=(1, 2, 3, 4, 5),
        denominator=8,
        ),
    silence_talea=rhythmmakertools.Talea(
        counts=(4, 7),
        denominator=8,
        ),
    synchronize_step=True,
    )
result = synchronized_talea_timespan_maker(
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
show(result, key='voice_name')
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> synchronized_talea_timespan_maker = consort.TaleaTimespanMaker(
...     playing_talea=rhythmmakertools.Talea(
...         counts=(1, 2, 3, 4, 5),
...         denominator=8,
...         ),
...     silence_talea=rhythmmakertools.Talea(
...         counts=(4, 7),
...         denominator=8,
...         ),
...     synchronize_step=True,
...     )
>>> result = synchronized_talea_timespan_maker(
...     music_specifiers=music_specifiers,
...     target_timespan=target_timespan,
...     )
>>> show(result, key='voice_name')
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-780df86ad9a6fb2424e5754f4ed917da.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Initial silences behave differently in synchronized talea
timespan-makers than with unsynchronized talea timespan-makers. Rather than
adding silences only at the very beginning of each voice's timespans, silences
are determined for each voice at the beginning of each synchronized group.

\begin{comment}
<abjad>
synchronized_talea_timespan_maker = new(
    synchronized_talea_timespan_maker,
    initial_silence_talea=rhythmmakertools.Talea(
        counts=(0, 1, 2),
        denominator=8,
        ),
    )
result = synchronized_talea_timespan_maker(
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
show(result, key='voice_name')
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> synchronized_talea_timespan_maker = new(
...     synchronized_talea_timespan_maker,
...     initial_silence_talea=rhythmmakertools.Talea(
...         counts=(0, 1, 2),
...         denominator=8,
...         ),
...     )
>>> result = synchronized_talea_timespan_maker(
...     music_specifiers=music_specifiers,
...     target_timespan=target_timespan,
...     )
>>> show(result, key='voice_name')
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-baaa4c6ab62859d41728fefd33b4a778.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent And unlike flooded timespan-makers, padding durations are included in
the start offset and step duration calculations for talea timespan-makers.

\begin{comment}
<abjad>
synchronized_talea_timespan_maker = new(
    synchronized_talea_timespan_maker,
    padding=(1, 8),
    )
result = synchronized_talea_timespan_maker(
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
show(result, key='voice_name')
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> synchronized_talea_timespan_maker = new(
...     synchronized_talea_timespan_maker,
...     padding=(1, 8),
...     )
>>> result = synchronized_talea_timespan_maker(
...     music_specifiers=music_specifiers,
...     target_timespan=target_timespan,
...     )
>>> show(result, key='voice_name')
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-d2009fad335e628aa2ba715e8ff1bc54.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\subsection{Dependent timespan-makers} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Dependent timespan-makers create timespans based on the disposition of
timespans in an input timespan inventory, selecting the start and stop offsets
of their generated timespans by filtering and inspecting timespans from the
input according to their voice name or music specifier label. This behavior
helps model how timespans used to generate phrasing for a pianists's pedaling
voice can be derived by selecting only those timespans in a timespan inventory
for entire ensemble which pertain to the pianists right and left-hand voices.

Consider the following timespan inventory, comprised of overlapping and
nonoverlapping timespans created for the contexts \enquote{Voice 1},
\enquote{Voice 2} and \enquote{Ignored Voice}.

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    consort.PerformedTimespan(0, 10, voice_name='Voice 1'),
    consort.PerformedTimespan(0, 10, voice_name='Voice 2'),
    consort.PerformedTimespan(5, 20, voice_name='Ignored Voice'),
    consort.PerformedTimespan(10, 20, voice_name='Voice 1'),
    consort.PerformedTimespan(15, 35, voice_name='Voice 2'),
    consort.PerformedTimespan(25, 30, voice_name='Voice 1'),
    consort.PerformedTimespan(30, 45, voice_name='Ignored Voice'),
    consort.PerformedTimespan(40, 45, voice_name='Voice 2'),
    consort.PerformedTimespan(45, 75, voice_name='Voice 2'),
    consort.PerformedTimespan(50, 80, voice_name='Ignored Voice'),
    consort.PerformedTimespan(50, 60, voice_name='Voice 1'),
    ])
show(timespan_inventory, key='voice_name')
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespan_inventory = timespantools.TimespanInventory([
...     consort.PerformedTimespan(0, 10, voice_name='Voice 1'),
...     consort.PerformedTimespan(0, 10, voice_name='Voice 2'),
...     consort.PerformedTimespan(5, 20, voice_name='Ignored Voice'),
...     consort.PerformedTimespan(10, 20, voice_name='Voice 1'),
...     consort.PerformedTimespan(15, 35, voice_name='Voice 2'),
...     consort.PerformedTimespan(25, 30, voice_name='Voice 1'),
...     consort.PerformedTimespan(30, 45, voice_name='Ignored Voice'),
...     consort.PerformedTimespan(40, 45, voice_name='Voice 2'),
...     consort.PerformedTimespan(45, 75, voice_name='Voice 2'),
...     consort.PerformedTimespan(50, 80, voice_name='Ignored Voice'),
...     consort.PerformedTimespan(50, 60, voice_name='Voice 1'),
...     ])
>>> show(timespan_inventory, key='voice_name')
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-7bde2c56ce3e058e09f98d245ffed630.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent A dependent timespan-maker can be configured to depend on timespans
created for the \enquote{Voice 1} and \enquote{Voice 2} contexts by specifying
a tuple of voice names during instantiation. Passing the previously defined
timespan inventory as an argument when calling the dependent timespan-maker
adds the newly-created dependent timespans to it. For the sake of brevity and
because timespan-makers modify any timespan inventory passed as an argument to
\texttt{\_\_call\_\_()} in-place, we pass a copy of this timespan inventory,
created via a call to \texttt{new()}, instead of the original.

\begin{comment}
<abjad>
music_specifiers = {'Dependent Voice': None}
dependent_timespan_maker = consort.DependentTimespanMaker(
    voice_names=(
        'Voice 1',
        'Voice 2',
        )
    )
result = dependent_timespan_maker(
    music_specifiers=music_specifiers,
    timespan_inventory=new(timespan_inventory),
    )
show(result, key='voice_name')
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> music_specifiers = {'Dependent Voice': None}
>>> dependent_timespan_maker = consort.DependentTimespanMaker(
...     voice_names=(
...         'Voice 1',
...         'Voice 2',
...         )
...     )
>>> result = dependent_timespan_maker(
...     music_specifiers=music_specifiers,
...     timespan_inventory=new(timespan_inventory),
...     )
>>> show(result, key='voice_name')
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-d84a2c5076bc15e57217374c119dbda8.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Note how the above timespan inventory shows the timespans for
\enquote{Dependent Voice} outlining the start and stop offset for partitioned
shards of the timespans for \enquote{Voice 1} and \enquote{Voice 2}, but
ignoring the boundaries outlined by the timespans for the \enquote{Ignored
Voice} context. Dependent timespans first select all timespans from their input
timespan inventory matching their voice-names criteria, then partition them
into shards in order to determine which offsets to use for timespan creation.
Partitioning guarantees that the created dependent timespans do not exceed the
bounds of the timespans they depend upon.

Configuring the dependent timespan-maker with its
\texttt{include\_inner\_starts} flag set to true causes it to create contiguous
groups of dependent timespans, as though splitting at every moment when a
timespan it depends upon starts.

\begin{comment}
<abjad>
new_dependent_timespan_maker = new(
    dependent_timespan_maker,
    include_inner_starts=True,
    )
result = new_dependent_timespan_maker(
    music_specifiers=music_specifiers,
    timespan_inventory=new(timespan_inventory),
    )
show(result, key='voice_name')
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> new_dependent_timespan_maker = new(
...     dependent_timespan_maker,
...     include_inner_starts=True,
...     )
>>> result = new_dependent_timespan_maker(
...     music_specifiers=music_specifiers,
...     timespan_inventory=new(timespan_inventory),
...     )
>>> show(result, key='voice_name')
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-655c639619ff0812649e0d2c34a28117.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Likewise, the \texttt{include\_inner\_stops} flag causes the
dependent timespan-maker to take into account the stop offsets of any timespan
it depends upon.

\begin{comment}
<abjad>
new_dependent_timespan_maker = new(
    dependent_timespan_maker,
    include_inner_stops=True,
    )
result = new_dependent_timespan_maker(
    music_specifiers=music_specifiers,
    timespan_inventory=new(timespan_inventory),
    )
show(result, key='voice_name')
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> new_dependent_timespan_maker = new(
...     dependent_timespan_maker,
...     include_inner_stops=True,
...     )
>>> result = new_dependent_timespan_maker(
...     music_specifiers=music_specifiers,
...     timespan_inventory=new(timespan_inventory),
...     )
>>> show(result, key='voice_name')
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-7bfff0fff12a4fed37c9d3b032378ee4.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Both options can be combined together, resulting in dependent
timespans outlining all offsets from the collection of timespans they depend
upon.

\begin{comment}
<abjad>
new_dependent_timespan_maker = new(
    dependent_timespan_maker,
    include_inner_starts=True,
    include_inner_stops=True,
    )
result = new_dependent_timespan_maker(
    music_specifiers=music_specifiers,
    timespan_inventory=new(timespan_inventory),
    )
show(result, key='voice_name')
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> new_dependent_timespan_maker = new(
...     dependent_timespan_maker,
...     include_inner_starts=True,
...     include_inner_stops=True,
...     )
>>> result = new_dependent_timespan_maker(
...     music_specifiers=music_specifiers,
...     timespan_inventory=new(timespan_inventory),
...     )
>>> show(result, key='voice_name')
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-7deb68434b102f489e182b7dd824f01a.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Note that in the previous dependent timespan-maker examples no target
timespan was specified. When passed a non-empty timespan inventory during
calling, timespan-makers can treat that inventory's timespan as their target
timespan if no target timespan was specified explicitly. However, passing a
target timespan to a dependent timespan-maker causes that timespan-maker to
perform a logical \texttt{AND} of the target timespan with any selected
timespans in the input inventory.

\begin{comment}
<abjad>
result = new_dependent_timespan_maker(
    music_specifiers=music_specifiers,
    target_timespan=timespantools.Timespan(17, 58),
    timespan_inventory=new(timespan_inventory),
    )
show(result, key='voice_name', range_=(0, 75))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> result = new_dependent_timespan_maker(
...     music_specifiers=music_specifiers,
...     target_timespan=timespantools.Timespan(17, 58),
...     timespan_inventory=new(timespan_inventory),
...     )
>>> show(result, key='voice_name', range_=(0, 75))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-eed8f0800343d386847212c7a2dd79e8.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Finally, dependent timespan-makers are capable of performing simple
transformations on the offsets they extract from their input timespan
inventory. Rotation allows the timespan-maker to rotate the durations outlined
by the offsets extracted from the timespans they select. Specifying a rotation
index of 1 causes each created group of dependent timespans to rotate its
internal durations by that index.

\begin{comment}
<abjad>
rotated_dependent_timespan_maker = new(
    new_dependent_timespan_maker,
    rotation_indices=(1,),
    )
result = rotated_dependent_timespan_maker(
    music_specifiers=music_specifiers,
    timespan_inventory=new(timespan_inventory),
    )
show(result, key='voice_name', range_=(0, 75))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> rotated_dependent_timespan_maker = new(
...     new_dependent_timespan_maker,
...     rotation_indices=(1,),
...     )
>>> result = rotated_dependent_timespan_maker(
...     music_specifiers=music_specifiers,
...     timespan_inventory=new(timespan_inventory),
...     )
>>> show(result, key='voice_name', range_=(0, 75))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-823ed74b320470ddf828bf90bdd24b28.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent More than one rotation index can be specified, allowing for each
group of dependent timespans -- as created from each shard of the partitioned
selected timespans -- to be rotated independently.

\begin{comment}
<abjad>
rotated_dependent_timespan_maker = new(
    new_dependent_timespan_maker,
    rotation_indices=(1, -1),
    )
result = rotated_dependent_timespan_maker(
    music_specifiers=music_specifiers,
    timespan_inventory=new(timespan_inventory),
    )
show(result, key='voice_name', range_=(0, 75))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> rotated_dependent_timespan_maker = new(
...     new_dependent_timespan_maker,
...     rotation_indices=(1, -1),
...     )
>>> result = rotated_dependent_timespan_maker(
...     music_specifiers=music_specifiers,
...     timespan_inventory=new(timespan_inventory),
...     )
>>> show(result, key='voice_name', range_=(0, 75))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-57ce3dce1f7346f365183d8abb73e3a2.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Rhythm-makers}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Abjad's rhythm-makers, like Consort's timespan-makers, are highly-configurable
factory classes which behave like partially evaluated functions, taking
as input sequences of \emph{divisions} -- positive duration tokens representing
the divisions in some phrase of music -- and producing selections of score
components as output. Abjad's \texttt{rhythmmakertools} subpackage contains a
variety of such classes, each providing a different strategy for rhythm
generation, but unified by the same callable interface. Additionally,
\texttt{rhythmmakertools} provides a collection of \emph{specifier} classes
which group related configuration values together for controlling the behavior
of ties, beams, duration spelling and other notational aspects of each
rhythm-maker's output. Like many other classes in Abjad -- timespans, for
example -- both these specifiers and the rhythm-makers themselves can be
templated via calls to \texttt{new()}. A tour of these rhythm-maker classes
demonstrates how a wide range of rhythmic textures can be produced.

\subsection{Note rhythm-makers}

Note rhythm-makers, arguably the simplest class of rhythm-maker, take a
sequence of input divisions and \enquote{fill} them with notes, tied as
necessary, such that the duration of each logical tie in each output division
equals the duration of each input division.

\begin{comment}
<abjad>
note_rhythm_maker = rhythmmakertools.NoteRhythmMaker()
divisions = [(3, 8), (4, 8), (3, 16), (4, 16), (5, 8), (2, 4)]
show(note_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> note_rhythm_maker = rhythmmakertools.NoteRhythmMaker()
>>> divisions = [(3, 8), (4, 8), (3, 16), (4, 16), (5, 8), (2, 4)]
>>> show(note_rhythm_maker, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-d0f66021e4860194d32ee0fa226ed174.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Like many objects implemented in Abjad and its extensions,
rhythm-makers can be illustrated via a call to \texttt{show()}. Rhythm-maker
illustrations take an optional \texttt{divisions} argument, specifying what
durations should be used for the generated rhythmic output, grouping each of
those divisions into measures for ease of visualization.

Rhythm-makers can be configured with a variety of specifiers, allowing for
optional customization of their rhythm-generating behavior. For example, a
\texttt{TieSpecifier} can be used to force a rhythm-maker to tie the last note
of each output division to the first note of the next output division. When
used with a note rhythm-maker, this effectively ties all notes in the output
together.

\begin{comment}
<abjad>
note_rhythm_maker = new(
    note_rhythm_maker,
    tie_specifier=rhythmmakertools.TieSpecifier(
        tie_across_divisions=True,
        ),
    )
show(note_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> note_rhythm_maker = new(
...     note_rhythm_maker,
...     tie_specifier=rhythmmakertools.TieSpecifier(
...         tie_across_divisions=True,
...         ),
...     )
>>> show(note_rhythm_maker, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-1c2192761535f741178fd5fc2ed22ed7.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Other rhythm-maker specifiers influence beaming, tuplet spelling, or
can cause a rhythm-maker to convert patterned groups of leaves in its output
from notes to rests or vice versa. Rhythm-makers configured with \emph{output
masks} replace the contents of their output divisions with rests in a patterned
per-division basis. A sequence of one or more \texttt{BooleanPattern} instances
control the masking pattern. These patterns partition the rhythm-maker's output
divisions into segments of a given period, and then mask out divisions
specified by indices within that period. For example, a note rhythm-maker
configured with a single output mask of a period of length 2 and a masking
index 0 will cause the first of every two divisions to be silenced.

\begin{comment}
<abjad>
mask = rhythmmakertools.BooleanPattern(indices=[0], period=2)
note_rhythm_maker = rhythmmakertools.NoteRhythmMaker(output_masks=[mask])
show(note_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> mask = rhythmmakertools.BooleanPattern(indices=[0], period=2)
>>> note_rhythm_maker = rhythmmakertools.NoteRhythmMaker(output_masks=[mask])
>>> show(note_rhythm_maker, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-fb60261fce39a6a8bed29c6bc1a39b14.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Reducing the period of the boolean pattern from 2 to 1 silences every
output division, effectively turning a note-generating rhythm-maker into a
rest-generating rhythm-maker.

\begin{comment}
<abjad>
mask = rhythmmakertools.BooleanPattern(indices=[0], period=1)
note_rhythm_maker = rhythmmakertools.NoteRhythmMaker(output_masks=[mask])
show(note_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> mask = rhythmmakertools.BooleanPattern(indices=[0], period=1)
>>> note_rhythm_maker = rhythmmakertools.NoteRhythmMaker(output_masks=[mask])
>>> show(note_rhythm_maker, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-b8d4d2abe1d0cabd1dba685a0e5a2bcc.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\subsection{Talea rhythm-makers}

Talea rhythm-makers, like talea timespan-makers, create rhythmic output through
the use of a talea -- an infinitely cyclic pattern of durations. Talea
rhythm-makers fill their output divisions with durations from their talea,
splitting those durations across division boundaries when the divisions are
overful. The following trivial talea rhythm-maker uses a length-1 talea
comprised of a single 1/16 duration.

\begin{comment}
<abjad>
talea_rhythm_maker = rhythmmakertools.TaleaRhythmMaker(
    talea=rhythmmakertools.Talea(
        counts=[1],
        denominator=16,
        ),
    )
show(talea_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> talea_rhythm_maker = rhythmmakertools.TaleaRhythmMaker(
...     talea=rhythmmakertools.Talea(
...         counts=[1],
...         denominator=16,
...         ),
...     )
>>> show(talea_rhythm_maker, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-a8d7d6245553b2c4f5d2e404e62ae27b.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Extending the talea counts to a sequence of alternating 1/16 and 1/8
notes produces more complex results. Note how the 1/8 durations break over the
boundaries of the 3/16 measure, but remain tied together. Talea rhythm-makers
handle talea splitting and tying transparently.

\begin{comment}
<abjad>
talea_rhythm_maker = new(
    talea_rhythm_maker,
    talea__counts=[1, 2],
    )
show(talea_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> talea_rhythm_maker = new(
...     talea_rhythm_maker,
...     talea__counts=[1, 2],
...     )
>>> show(talea_rhythm_maker, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-a91e80c7459af113e517ef98d44608db.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent With the talea counts changed to a descending sequence of durations,
the pattern of split and tied durations also changes.

\begin{comment}
<abjad>
talea_rhythm_maker = new(
    talea_rhythm_maker,
    talea__counts=[4, 3, 2, 1],
    )
show(talea_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> talea_rhythm_maker = new(
...     talea_rhythm_maker,
...     talea__counts=[4, 3, 2, 1],
...     )
>>> show(talea_rhythm_maker, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-8d6fdf555decf2c32991c6d1f43307af.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Talea rhythm-makers can be configured to treat input divisions as
though they had more counts than they actually do via their
\texttt{extra\_counts\_per\_division} property, potentially causing tuplets to
appear in the output. The following talea, reconfigured from the previous, adds
an extra count to every second and third input division. This causes the 4/8
and 3/16 as well as the 5/8 and 2/4 divisions to become tuplets, each with a
pre-prolated duration 1/16 longer than their prolated duration. That is, the
4/8 division contains a tuplet whose contents sum to 9/16, but scaled into a
duration of 8/16. Likewise, the 3/16 division contains a tuplet whose contents
sum to 4/16, but scaled into a duration of 3/16. Note how this tupletting
causes the pattern of split and tied talea durations to shift. In the previous
example, the second instance of the talea's 3/16 duration occurred entirely
during the 3/16 division. Here, that same 3/16 talea duration begins on the
final 1/16 of the 4/8 divisions's 9:8 tuplet, tied into the 4:3 tuplet in the
following division.

\begin{comment}
<abjad>
talea_rhythm_maker = new(
    talea_rhythm_maker,
    extra_counts_per_division=[0, 1, 1],
    )
show(talea_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> talea_rhythm_maker = new(
...     talea_rhythm_maker,
...     extra_counts_per_division=[0, 1, 1],
...     )
>>> show(talea_rhythm_maker, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-f868ef7342d21df2f091666e876b44e7.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Like note rhythm-makers, talea rhythm-makers can be configured with a
tie specifier, causing the last note of each division to be tied to the first
note of the next division. In note rhythm-makers, the contents of each
un-masked division is guaranteed to be a single logical tie and tying across
divisions results in the entire output of the note rhythm-maker merging into
the same logical tie. The output divisions of talea rhythm-makers generally
contain more than one logical tie, and therefore tying across divisions tends
to produce the effect of ellided downbeats with intermittent attacks.

\begin{comment}
<abjad>
talea_rhythm_maker = new(
    talea_rhythm_maker,
    tie_specifier=rhythmmakertools.TieSpecifier(
        tie_across_divisions=True,
        ),
    )
show(talea_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> talea_rhythm_maker = new(
...     talea_rhythm_maker,
...     tie_specifier=rhythmmakertools.TieSpecifier(
...         tie_across_divisions=True,
...         ),
...     )
>>> show(talea_rhythm_maker, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-0aa7f18c24b9676851fc7ace0fbb408e.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Talea rhythm-makers can also be configured to produce intermittent
silences, either by specifying negative count values in the rhythm-maker's
talea, or by configuring the rhythm-maker with a special \emph{burnish}
specifier which casts logical ties generated by the rhythm-maker as either
notes or rests, in a patterned way. Here, the 3-count in the talea
rhythm-maker's talea is changed to -3, resulting in the production of
3/16-duration silences.

\begin{comment}
<abjad>
talea_rhythm_maker_with_rests = new(
    talea_rhythm_maker,
    talea__counts=[4, -3, 2, 1],
    )
show(talea_rhythm_maker_with_rests, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> talea_rhythm_maker_with_rests = new(
...     talea_rhythm_maker,
...     talea__counts=[4, -3, 2, 1],
...     )
>>> show(talea_rhythm_maker_with_rests, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-f4acf8cc0f640f8afb7dbc701a8bbc82.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Alternatively, configuring the rhythm-maker with the following
\texttt{BurnishSpecifier} allows the first logical tie of every other division
to be converted to rests.

\begin{comment}
<abjad>
talea_rhythm_maker_with_rests = new(
    talea_rhythm_maker,
    burnish_specifier=rhythmmakertools.BurnishSpecifier(
        left_classes=[Rest],
        left_counts=[1, 0],
        ),
    )
show(talea_rhythm_maker_with_rests, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> talea_rhythm_maker_with_rests = new(
...     talea_rhythm_maker,
...     burnish_specifier=rhythmmakertools.BurnishSpecifier(
...         left_classes=[Rest],
...         left_counts=[1, 0],
...         ),
...     )
>>> show(talea_rhythm_maker_with_rests, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-56c4a8d2c9d313021bf1f182ccb3a96e.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\subsection{Incised rhythm-makers}

Incised rhythm-makers behave similarly to note rhythm-makers, but allow for
\emph{incising} patterned sequences of notes and rests from the beginnings and
ends of each output division, or even from the beginning and end of the entire
sequence of divisions -- the rhythm-maker \emph{output}. Configuring an incised
rhythm-maker to perform incision requires an \texttt{InciseSpecifier} instance.
An unconfigured incised rhythm-maker behaves identically to unconfigured note
rhythm-maker.

\begin{comment}
<abjad>
incised_rhythm_maker = rhythmmakertools.IncisedRhythmMaker()
show(incised_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> incised_rhythm_maker = rhythmmakertools.IncisedRhythmMaker()
>>> show(incised_rhythm_maker, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-d0f66021e4860194d32ee0fa226ed174.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Incise specifiers define talea and group counts for prefix and suffix
incision. The talea -- as determined by the numerators given in the
\texttt{prefix\_talea} and \texttt{suffix\_talea} sequences combined with the
\texttt{talea\_denominator} -- define the durations to be selected from, as
well as the \emph{sign} of the component to be incised. Negative talea items
indicate rests, while positive talea items indicate notes. The count properties
-- \texttt{suffix\_counts} and \texttt{prefix\_counts} -- indicate how many
talea durations should be selected at each pass. The following incised
rhythm-maker incises a single 1/16 rest at the end of each division.

\begin{comment}
<abjad>
incised_rhythm_maker = rhythmmakertools.IncisedRhythmMaker(
    incise_specifier=rhythmmakertools.InciseSpecifier(
        suffix_counts=[1],
        suffix_talea=[-1],
        talea_denominator=16,
        ),
    )
show(incised_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> incised_rhythm_maker = rhythmmakertools.IncisedRhythmMaker(
...     incise_specifier=rhythmmakertools.InciseSpecifier(
...         suffix_counts=[1],
...         suffix_talea=[-1],
...         talea_denominator=16,
...         ),
...     )
>>> show(incised_rhythm_maker, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-f21215b14c3e76d687060a020bdca52a.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Extending the suffix talea results in a more complex incision
pattern.

\begin{comment}
<abjad>
incised_rhythm_maker = new(
    incised_rhythm_maker,
    incise_specifier__suffix_talea=[-1, -2, -3],
    )
show(incised_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> incised_rhythm_maker = new(
...     incised_rhythm_maker,
...     incise_specifier__suffix_talea=[-1, -2, -3],
...     )
>>> show(incised_rhythm_maker, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-fafb95028809a8071ef2a59e4da26ec9.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Prefix incision occurs in an identical fashion, by specifying
sequences of group counts and talea numerators. Here, alternating groups of
length-1 and length-2 are incised from the beginning of each division.

\begin{comment}
<abjad>
incised_rhythm_maker = rhythmmakertools.IncisedRhythmMaker(
    incise_specifier=rhythmmakertools.InciseSpecifier(
        prefix_counts=[2, 1],
        prefix_talea=[2, 1],
        talea_denominator=16,
        ),
    )
show(incised_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> incised_rhythm_maker = rhythmmakertools.IncisedRhythmMaker(
...     incise_specifier=rhythmmakertools.InciseSpecifier(
...         prefix_counts=[2, 1],
...         prefix_talea=[2, 1],
...         talea_denominator=16,
...         ),
...     )
>>> show(incised_rhythm_maker, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-c2461da064af411639e8a2608af00305.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Setting the incise specifier's \texttt{fill\_with\_notes} property to
false causes the rhythm-maker to fill the unincised durations of its divisions
with rests rather notes.

\begin{comment}
<abjad>
incised_rhythm_maker = new(
    incised_rhythm_maker,
    incise_specifier__fill_with_notes=False,
    )
show(incised_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> incised_rhythm_maker = new(
...     incised_rhythm_maker,
...     incise_specifier__fill_with_notes=False,
...     )
>>> show(incised_rhythm_maker, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-25581a22cd4059e8966b0ff386bbbcc6.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Incised rhythm-makers can be configured to only incise the outer
divisions of their output. The following rhythm-maker cuts 1/8 rests from the
beginning of the first division in its output, and the end of the last
division.

\begin{comment}
<abjad>
incised_rhythm_maker = rhythmmakertools.IncisedRhythmMaker(
    incise_specifier=rhythmmakertools.InciseSpecifier(
        outer_divisions_only=True,
        prefix_counts=[1],
        prefix_talea=[-1],
        suffix_counts=[1],
        suffix_talea=[-1],
        talea_denominator=8,
        ),
    )
show(incised_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> incised_rhythm_maker = rhythmmakertools.IncisedRhythmMaker(
...     incise_specifier=rhythmmakertools.InciseSpecifier(
...         outer_divisions_only=True,
...         prefix_counts=[1],
...         prefix_talea=[-1],
...         suffix_counts=[1],
...         suffix_talea=[-1],
...         talea_denominator=8,
...         ),
...     )
>>> show(incised_rhythm_maker, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-8245f754d4c0b647786ba2c3e22988f3.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Incised rhythm-makers also respect many of the same rhythm-maker
specifiers as the other rhythm-maker classes defined in Abjad's
\texttt{rhythmmakertools} subpackage. Like note rhythm-makers, they can be
configured to tie the last note of each output division to the first note of
the next output division via an instance of the \texttt{TieSpecifier} class.

\begin{comment}
<abjad>
incised_rhythm_maker = new(
    incised_rhythm_maker,
    tie_specifier=rhythmmakertools.TieSpecifier(
        tie_across_divisions=True,
        ),
    )
show(incised_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> incised_rhythm_maker = new(
...     incised_rhythm_maker,
...     tie_specifier=rhythmmakertools.TieSpecifier(
...         tie_across_divisions=True,
...         ),
...     )
>>> show(incised_rhythm_maker, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-9890ffbc1115862a9479f6a97bf677e3.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\subsection{Even-division rhythm-makers}

Even-division rhythm-makers attempt to divide each input division into runs of
notes with a basic duration \texttt{1/denominator}, where the \texttt{denominator}
is specified on a per-division basis by the rhythm-maker's configurable
\texttt{denominator} sequence property. When an input division does not
exactly fit some multiple of this basic duration, some combination of
augmentation or tupletting will be used to produce notes with durations as
close to that basic duration as possible.

\begin{comment}
<abjad>
even_division_rhythm_maker = rhythmmakertools.EvenDivisionRhythmMaker()
show(even_division_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> even_division_rhythm_maker = rhythmmakertools.EvenDivisionRhythmMaker()
>>> show(even_division_rhythm_maker, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-2bcea48859d1e8378a750341c3315103.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Extending the even-division rhythm-maker's denominator sequence to a
2-length pattern produces divisions filled alternatingly with 1/8 and 1/16
notes. Note that the 3/16 measure is filled with a dotted 1/8 note.

\begin{comment}
<abjad>
even_division_rhythm_maker = new(
    even_division_rhythm_maker,
    denominators=[8, 16],
    )
show(even_division_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> even_division_rhythm_maker = new(
...     even_division_rhythm_maker,
...     denominators=[8, 16],
...     )
>>> show(even_division_rhythm_maker, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-042a232c8ba3c9adb624c404980efe18.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Extending the denominator sequence even further results in more
complex output. Note here how the 5/8 division is rendered as a tuplet.

\begin{comment}
<abjad>
even_division_rhythm_maker = new(
    even_division_rhythm_maker,
    denominators=[8, 4, 16],
    )
show(even_division_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> even_division_rhythm_maker = new(
...     even_division_rhythm_maker,
...     denominators=[8, 4, 16],
...     )
>>> show(even_division_rhythm_maker, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-18b3464ab66c7d829de5417e6e668687.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Like the talea rhythm-maker, even-division rhythm-makers can be
configured with a \texttt{extra\_counts\_per\_division} property, forcing the
rhythm-maker to treat input divisions as longer than the actually. Artificially
lengthened divisions are rendered as tuplets. With the following rhythm-maker,
every other division is extended by one count, causing the 4/8 and 2/4
divisions to be rendered as 5:4 tuplets, and the 4/16 division to be rendered
as a 3:2 tuplet.

\begin{comment}
<abjad>
even_division_rhythm_maker = new(
    even_division_rhythm_maker,
    denominators=[8],
    extra_counts_per_division=(0, 1),
    )
show(even_division_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> even_division_rhythm_maker = new(
...     even_division_rhythm_maker,
...     denominators=[8],
...     extra_counts_per_division=(0, 1),
...     )
>>> show(even_division_rhythm_maker, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-7bd6867c75e18e48ebf2c898a35a53b9.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent When configured with a tie specifier, the even-division rhythm-maker
obscures the downbeat of every output division.

\begin{comment}
<abjad>
even_division_rhythm_maker = new(
    even_division_rhythm_maker,
    tie_specifier=rhythmmakertools.TieSpecifier(
        tie_across_divisions=True,
        ),
    )
show(even_division_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> even_division_rhythm_maker = new(
...     even_division_rhythm_maker,
...     tie_specifier=rhythmmakertools.TieSpecifier(
...         tie_across_divisions=True,
...         ),
...     )
>>> show(even_division_rhythm_maker, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-4cc7ba58b448cb7add8a0024b1e90f9b.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent And when reconfigured with the earlier 8-4-16 denominator pattern,
the even-division rhythm-maker produces rich tupletted rhythmic output.

\begin{comment}
<abjad>
even_division_rhythm_maker = new(
    even_division_rhythm_maker,
    denominators=[8, 4, 16],
    )
show(even_division_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> even_division_rhythm_maker = new(
...     even_division_rhythm_maker,
...     denominators=[8, 4, 16],
...     )
>>> show(even_division_rhythm_maker, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-af43995b8651db6fd08d7d3e42ff809b.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\subsection{Composite rhythm-makers} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Consort provides a class for aggregating multiple rhythm-maker instances
together into a \emph{composite} rhythm-maker, which applies its aggregated
rhythm-makers conditionally against input divisions to generate rhythmic
output. The following contrived composite rhythm-maker uses the previously note
rhythm-maker -- which only generates rests -- for the last of any sequence of
input divisions, the previously defined incised rhythm-maker for the first of
any sequence of input divisions, and the previously defined talea rhythm-maker
for all other input divisions.

\begin{comment}
<abjad>
composite_rhythm_maker = consort.CompositeRhythmMaker(
    default=talea_rhythm_maker,
    last=note_rhythm_maker,
    first=incised_rhythm_maker,
    )
show(composite_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> composite_rhythm_maker = consort.CompositeRhythmMaker(
...     default=talea_rhythm_maker,
...     last=note_rhythm_maker,
...     first=incised_rhythm_maker,
...     )
>>> show(composite_rhythm_maker, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-b1e38a72e659f0b2878d87c5401d2cd5.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Modeling meter}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Abjad models meter as a \emph{rhythm-tree} of nested, durated nodes which
outline a series of strongly and weakly accented offsets. The accent strength
of a particular offset found in a meter's rhythm-tree derives from the number
of nodes in that tree sharing that offset as a start or stop. The more nodes in
the rhythm-tree which share an offset, the greater the weight -- the
accentedness -- of that offset is taken to be. Abjad can construct the rhythm
tree for any meter from a numerator / denominator pair such as a rational
duration or time signature. Meter construction involves the progressive
division of the numerator of the input pair into groups of two and
threes\footnote{The factors 4 and 5 are also used in meter rhythm-tree
generation as they provide better typical results during meter rewriting.}, and
the decomposition of any other prime factors into groups of threes and twos.
Division by two always occurs before division by three, giving preference to
even metrical structures above odd or otherwise prime divisions. Constructing
rhythm-trees in this fashion gives results which generally align with common
practice expectations.

Consider the following 6/8 meter and its graph representation:

\begin{comment}
<abjad>
six_eight_meter = metertools.Meter((6, 8))
graph(six_eight_meter)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> six_eight_meter = metertools.Meter((6, 8))
>>> graph(six_eight_meter)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,scale=0.333,]{assets/graphviz-476d0f5c7605cc762b9e3a391835548f.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent The triangular and rectangular boxes indicate nodes in the
rhythm-tree itself. Rectangular boxes represent \enquote{beats} -- the leaves
of the rhythm-tree -- while triangular boxes indicate larger metrical
groupings. The ovals at the bottom of the graph indicate -- at their top -- the
start or stop offset of the nodes connected to them from above and -- at their
bottom -- the relative weight of their accent. The final oval on the right
indicates the offset and accent weight of the \enquote{next} downbeat.

The topmost triangle in the above graph represent the \enquote{highest}
metrical grouping in a 6/8 meter. Tracing the leftmost and rightmost arrows
down through the topmost node's children gives the offsets 0 and 3/4: the first
downbeat and next downbeat in a 6/8 meter. Offsets 0 and 3/4 also have the
strongest accent weights as they occur as either the start offset or stop
offset of nodes at three levels of hierarchy in the rhythm tree. At the second
level the 6/8 grouping divides into two 3/8 groupings, following common
practice expectations: metrical groupings tend to subdivide into groups of two
before they subdivide into groups of three\footnote{Consider a 12/8 meter.
Western musicians tend to subdivide twelve into either two groups of six or
four groups of three rather than into three groups of four.}. Both second-level
nodes share the offset of 3/8, which also occurs in the third level, giving 3/8
a weight of two. The third level contains the 1/8 duration beats, grouped by
their parents in the second level into two groups three 1/8 duration nodes. The
offsets 1/8, 1/4, 1/2 and 5/8 are not shared by any nodes except at the lowest
metrical level and therefore all receive an accent weight of one.

\subsection{Examples of meter} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Consider the following examples of meters modeled in Abjad.

A 3/4 meter consists of a top-level 3/4 metrical grouping divided into three
1/4 duration beats:

\begin{comment}
<abjad>
three_four_meter = metertools.Meter((3, 4))
graph(three_four_meter)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> three_four_meter = metertools.Meter((3, 4))
>>> graph(three_four_meter)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,scale=0.333,]{assets/graphviz-27e6f78f37c92f763186b4aaae59c563.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent By default, a 7/8 meter subdivides its top-level metrical grouping
into 3/8+2/8+2/8 groupings:

\begin{comment}
<abjad>
seven_eight_meter = metertools.Meter((7, 8))
graph(seven_eight_meter)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> seven_eight_meter = metertools.Meter((7, 8))
>>> graph(seven_eight_meter)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,scale=0.333,]{assets/graphviz-aa33afdcb82327be8e33e7587b5b7fb5.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent A 12/8 meter subdivides into four 3/8 duration groupings, each
containining three 1/8 duration beats:

\begin{comment}
<abjad>
twelve_eight_meter = metertools.Meter((12, 8))
graph(twelve_eight_meter)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> twelve_eight_meter = metertools.Meter((12, 8))
>>> graph(twelve_eight_meter)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,scale=0.333,]{assets/graphviz-c2a676a2bd53c91042417caefc7efaa9.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\subsection{Alternate meter representations} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Abjad permits alternate representations of meters with the same numerator and
denominator. The default interpretation of 4/4 generates a top-level rhythmic
grouping with a duration of 4/4 and four 1/4 beats as children\footnote{A
\enquote{flat} 4/4 metrical structure is useful for meter rewriting as it
allows the meter rewriting algorithm to ignore many common rhythmic idioms like
1/4+1/2+1/4 and 1/4+3/4.}.

\begin{comment}
<abjad>
four_four_meter = metertools.Meter((4, 4))
graph(four_four_meter)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> four_four_meter = metertools.Meter((4, 4))
>>> graph(four_four_meter)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,scale=0.333,]{assets/graphviz-1e7a83f7d35a8732ccfa1919e9c8f64f.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent While meter objects are usually instantiated from numerator /
denominator pairs, with their rhythm-tree structure determined programmatically
from that input pair, they can also be instantiated from strings parseable as
rhythm-trees, or from RhythmTree objects themselves. All meters, because they
are implemented in terms of rhythm-trees, can be represented by a Lisp-like
rhythm-tree syntax:

\begin{comment}
<abjad>
print(four_four_meter.pretty_rtm_format)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> print(four_four_meter.pretty_rtm_format)
(4/4 (
	1/4
	1/4
	1/4
	1/4))
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

Instantiating meters from explicit rhythm tree syntax allows composers to
choose alternate representations of metrical structures. For example, a 4/4
meter which strongly emphasizes beat three is possible by subdividing the
top-level 4/4 metrical grouping into two 2/4 duration groupings, which are then
subdivided each into two 1/4 duration beats:

\begin{comment}
<abjad>
arbitrary_meter_1 = metertools.Meter('(4/4 ((2/4 (1/4 1/4)) (2/4 (1/4 1/4))))')
graph(arbitrary_meter_1)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> arbitrary_meter_1 = metertools.Meter('(4/4 ((2/4 (1/4 1/4)) (2/4 (1/4 1/4))))')
>>> graph(arbitrary_meter_1)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,scale=0.333,]{assets/graphviz-538350f4d574238c7fe14b0bc2fcd602.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Unusual metrical structures are also possible, such as the following
4/4 meter which divides into two parts, with the first part dividing into two
again, and the second grouping of that divided into two again:

\begin{comment}
<abjad>
arbitrary_meter_2 = metertools.Meter('(4/4 ((2/4 (1/4 (1/4 (1/8 1/8)))) 1/2))')
graph(arbitrary_meter_2)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> arbitrary_meter_2 = metertools.Meter('(4/4 ((2/4 (1/4 (1/4 (1/8 1/8)))) 1/2))')
>>> graph(arbitrary_meter_2)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,scale=0.333,]{assets/graphviz-c0c488f838ef576f45131546e93310fa.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Rewriting meters}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Notated rhythms can be expressed in multiple ways while maintaining the same
attack-point and duration structure. \emph{Meter rewriting} formalizes the
process of re-notating a rhythm according to the offset structure inherent to
some meter while maintaining the original attack-points and durations.

Consider the following rhythm:

\begin{comment}
<abjad>
parseable = "abj: | 2/4 c'2 ~ |"
parseable += "| 4/4 c'32 d'2.. ~ d'16 e'32 ~ |"
parseable += "| 2/4 e'2 |"
staff = Staff(parseable)
show(staff)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> parseable = "abj: | 2/4 c'2 ~ |"
>>> parseable += "| 4/4 c'32 d'2.. ~ d'16 e'32 ~ |"
>>> parseable += "| 2/4 e'2 |"
>>> staff = Staff(parseable)
>>> show(staff)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-329490b244b088f012cb5146859cdab0.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent The middle measure is notated in a perfectly valid manner. However,
the double-dotted D does not align with or break against any of the offsets of
a 4/4 metrical structure: 0/4, 1/4, 2/4, 3/4 or 4/4.

\begin{comment}
<abjad>
four_four_meter = metertools.Meter((4, 4))
graph(four_four_meter)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> four_four_meter = metertools.Meter((4, 4))
>>> graph(four_four_meter)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,scale=0.333,]{assets/graphviz-1e7a83f7d35a8732ccfa1919e9c8f64f.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\begin{comment}
<abjad>
mutate(staff[1][:]).rewrite_meter(four_four_meter)
show(staff)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> mutate(staff[1][:]).rewrite_meter(four_four_meter)
>>> show(staff)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-52ed3c73b623b7b0d9a2c6230084a264.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\begin{comment}
<abjad>
two_two_meter = metertools.Meter((2, 2))
staff = Staff(parseable)
mutate(staff[1][:]).rewrite_meter(two_two_meter)
show(staff)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> two_two_meter = metertools.Meter((2, 2))
>>> staff = Staff(parseable)
>>> mutate(staff[1][:]).rewrite_meter(two_two_meter)
>>> show(staff)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-467c7a453dd4de93da0cc1c7acbe0a87.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\subsection{Dot count} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Meter rewriting can control for various qualities of how rhythms are notated.
For example, the maximum number of dots allowed for any notated rhythmic value
can be constrained. Consider this series of progressively rewritten rhythms,
beginning with the following unrewritten 3/4 measure.

\begin{comment}
<abjad>
measure = Measure((3, 4), "c'32 d'8 e'8 fs'4...")
show(measure)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> measure = Measure((3, 4), "c'32 d'8 e'8 fs'4...")
>>> show(measure)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-8d4bc784b86bdade27d371532ab358a2.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent After meter rewriting, the final F-sharp is notated as a
triple-dotted quarter note, valid because its stop offset aligns perfectly with
the containing measure's stop offset.

\begin{comment}
<abjad>
mutate(measure[:]).rewrite_meter((3, 4))
show(measure)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> mutate(measure[:]).rewrite_meter((3, 4))
>>> show(measure)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-d4d52cf91b08080c4067643d24faaf2a.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Capping the maximum number of dots to 2 causes the F-sharp to be
rewritten with as a double-dotted eighth note tied to a quarter note.

\begin{comment}
<abjad>
measure = Measure((3, 4), "c'32 d'8 e'8 fs'4...")
mutate(measure[:]).rewrite_meter((3, 4), maximum_dot_count=2)
show(measure)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> measure = Measure((3, 4), "c'32 d'8 e'8 fs'4...")
>>> mutate(measure[:]).rewrite_meter((3, 4), maximum_dot_count=2)
>>> show(measure)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-40b68312fd44f949b40de163b21588c3.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Constraining the maximum number of dots to 1 further subdivides the
F-sharp logical tie.

\begin{comment}
<abjad>
measure = Measure((3, 4), "c'32 d'8 e'8 fs'4...")
mutate(measure[:]).rewrite_meter((3, 4), maximum_dot_count=1)
show(measure)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> measure = Measure((3, 4), "c'32 d'8 e'8 fs'4...")
>>> mutate(measure[:]).rewrite_meter((3, 4), maximum_dot_count=1)
>>> show(measure)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-5fba6e827130a27fefae4843d2b21248.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

Finally, with no dots permitted at all, the rhythmic presentation of the
measure changes considerably.

\begin{comment}
<abjad>
measure = Measure((3, 4), "c'32 d'8 e'8 fs'4...")
mutate(measure[:]).rewrite_meter((3, 4), maximum_dot_count=0)
show(measure)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> measure = Measure((3, 4), "c'32 d'8 e'8 fs'4...")
>>> mutate(measure[:]).rewrite_meter((3, 4), maximum_dot_count=0)
>>> show(measure)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-2ca50ee6f27ae56bae476fb9dc1faafa.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\subsection{Boundary depth} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{comment}
<abjad>
nine_eight_meter = metertools.Meter((9, 8))
graph(nine_eight_meter)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> nine_eight_meter = metertools.Meter((9, 8))
>>> graph(nine_eight_meter)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,scale=0.333,]{assets/graphviz-9a650c94101f81b5350bc7b0edcf43a1.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\begin{comment}
<abjad>
measure = Measure((9, 8), "c'2 d'2 e'8")
show(measure)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> measure = Measure((9, 8), "c'2 d'2 e'8")
>>> show(measure)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-f459f8c64dd96ba762e4bdebba6f4680.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\begin{comment}
<abjad>
mutate(measure[:]).rewrite_meter(nine_eight_meter)
show(measure)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> mutate(measure[:]).rewrite_meter(nine_eight_meter)
>>> show(measure)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-63f30ee6e2e244440af9d6f1e0f84a02.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\begin{comment}
<abjad>
measure = Measure((9, 8), "c'2 d'2 e'8")
mutate(measure[:]).rewrite_meter(
    nine_eight_meter,
    boundary_depth=1,
    )
show(measure)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> measure = Measure((9, 8), "c'2 d'2 e'8")
>>> mutate(measure[:]).rewrite_meter(
...     nine_eight_meter,
...     boundary_depth=1,
...     )
>>> show(measure)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-93c0260083a9ae2ad25a3c7c064e3024.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\subsection{Recursive meter rewriting} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{comment}
<abjad>
parseable = "abj: | 4/4 c'16 ~ c'4 d'8. ~ "
parseable += "2/3 { d'8. ~ 3/5 { d'16 e'8 ~ e'16 f'16 ~ } } "
parseable += "f'4 |"
measure = parse(parseable)
show(measure)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> parseable = "abj: | 4/4 c'16 ~ c'4 d'8. ~ "
>>> parseable += "2/3 { d'8. ~ 3/5 { d'16 e'8 ~ e'16 f'16 ~ } } "
>>> parseable += "f'4 |"
>>> measure = parse(parseable)
>>> show(measure)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-270f471c0052391c9bf1a5df2ccc4474.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\begin{comment}
<abjad>
mutate(measure[:]).rewrite_meter(
    measure,
    boundary_depth=1,
    )
show(measure)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> mutate(measure[:]).rewrite_meter(
...     measure,
...     boundary_depth=1,
...     )
>>> show(measure)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-f7aa660690e64db249ef36ea1eac5ace.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\subsection{Examples} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{comment}
<abjad>
staff = Staff(context_name='RhythmicStaff')
staff.extend("{ c'2 c'4 } { c'4. c'4. } { c'2 ~ c'8 c'8 }")
attach(TimeSignature((3, 4)), staff)
show(staff)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> staff = Staff(context_name='RhythmicStaff')
>>> staff.extend("{ c'2 c'4 } { c'4. c'4. } { c'2 ~ c'8 c'8 }")
>>> attach(TimeSignature((3, 4)), staff)
>>> show(staff)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-b4a2116ab0031b6068b1112932629bac.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\begin{comment}
<abjad>
for container in staff:
    mutate(container[:]).rewrite_meter((3, 4), boundary_depth=1)

show(staff)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> for container in staff:
...     mutate(container[:]).rewrite_meter((3, 4), boundary_depth=1)
...
>>> show(staff)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-0cef77f45f31e31ad271d15c9c32edf8.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\begin{comment}
<abjad>
staff = Staff(context_name='RhythmicStaff')
staff.extend("{ c'2 c'4 } { c'4. c'4. } { c'2 ~ c'8 c'8 }")
attach(TimeSignature((6, 8)), staff)
for container in staff:
    mutate(container[:]).rewrite_meter((6, 8), boundary_depth=1)

show(staff)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> staff = Staff(context_name='RhythmicStaff')
>>> staff.extend("{ c'2 c'4 } { c'4. c'4. } { c'2 ~ c'8 c'8 }")
>>> attach(TimeSignature((6, 8)), staff)
>>> for container in staff:
...     mutate(container[:]).rewrite_meter((6, 8), boundary_depth=1)
...
>>> show(staff)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-58a85c4734fd2a15643aa2409cbff0e5.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\begin{comment}
<abjad>
selections = talea_rhythm_maker(divisions)
lilypond_file = rhythmmakertools.make_lilypond_file(selections, divisions)
show(staff)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> selections = talea_rhythm_maker(divisions)
>>> lilypond_file = rhythmmakertools.make_lilypond_file(selections, divisions)
>>> show(staff)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-58a85c4734fd2a15643aa2409cbff0e5.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Finding meters}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Not only can meters be used to alter rhythmic structures, they can also be
derived from them. A meter's weighted-offset pattern can be used as
one-dimensional kernel, or convolution matrix, to determine how strongly an
arbitrary collection of offsets appears to express that meter. Given a
collection of meters to choose from, each meter can be matched against those
offsets and the meter most closely aligning selected as the winner. This
process is called \emph{meter fitting}.

\subsection{Offset counters} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Before convolving a meter with a collection of offsets, those offsets need to
be extracted and counted. Abjad's \texttt{metertools} provides an
\texttt{OffsetCounter} class which maps offsets against counts. Offset counters
can be instantiated from any expression containing offsets or whose elements
can be expressed as timespans and therefore possess both start and stop
offsets. Offsets which appear multiple times in the input expression will
result in a higher count in the offset counter, and will in turn have a greater
influence during meter fitting.

Consider the following score example:

\begin{comment}
<abjad>
upper_staff = Staff("c'8 d'4. e'8 f'4.")
lower_staff = Staff(r'\clef bass c4 b,4 a,2')
piano_staff = scoretools.StaffGroup(
    [upper_staff, lower_staff],
    context_name='PianoStaff',
    )
show(piano_staff)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> upper_staff = Staff("c'8 d'4. e'8 f'4.")
>>> lower_staff = Staff(r'\clef bass c4 b,4 a,2')
>>> piano_staff = scoretools.StaffGroup(
...     [upper_staff, lower_staff],
...     context_name='PianoStaff',
...     )
>>> show(piano_staff)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-bf3a249e2b4eac93b1884bab1a122a10.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent The start and stop offsets of all of the leaves of this score can be
counted by selecting the score's leaves and instantiating an offset counter
from them. Because all score components can be expressed as timespans via
\texttt{inspect\_(some\_component).get\_timespan()} the offset counter can
retrieve both their start and stop offsets within the score.

\begin{comment}
<abjad>
leaves = piano_staff.select_leaves(allow_discontiguous_leaves=True)
piano_staff_counter = metertools.OffsetCounter(leaves)
print(format(piano_staff_counter))
show(piano_staff_counter)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> leaves = piano_staff.select_leaves(allow_discontiguous_leaves=True)
>>> piano_staff_counter = metertools.OffsetCounter(leaves)
>>> print(format(piano_staff_counter))
metertools.OffsetCounter(
    {
        durationtools.Offset(0, 1): 2,
        durationtools.Offset(1, 8): 2,
        durationtools.Offset(1, 4): 2,
        durationtools.Offset(1, 2): 4,
        durationtools.Offset(5, 8): 2,
        durationtools.Offset(1, 1): 2,
        }
    )
\end{lstlisting}
\begin{lstlisting}
>>> show(piano_staff_counter)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-b2c45afc4a29ecdf622c76195f1251ae.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Note that the offset 1/2 shows a count of 4. This is because 1/2 acts
as both the start or stop offset for four separate leaves in the score.

Offset counters can also be generated from timespan inventories, allowing meter
convolution to be used without reference to any score objects at all.

\begin{comment}
<abjad>
timespans = timespantools.TimespanInventory([
    timespantools.Timespan(-1, 10),
    timespantools.Timespan(5, 15),
    timespantools.Timespan(15, 20),
    timespantools.Timespan(10, 15),
    ])
timespan_counter = metertools.OffsetCounter(timespans)
show(timespan_counter)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespans = timespantools.TimespanInventory([
...     timespantools.Timespan(-1, 10),
...     timespantools.Timespan(5, 15),
...     timespantools.Timespan(15, 20),
...     timespantools.Timespan(10, 15),
...     ])
>>> timespan_counter = metertools.OffsetCounter(timespans)
>>> show(timespan_counter)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-92e87e63b34df27878f535ac2f8e07ac.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\subsection{Metric accent kernels} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

As demonstrated earlier, Abjad's model of meter describes a sequence of offsets
with varying degrees of weight -- accentedness -- attributed to each offset, as
determined by the hierarchical tree structure of that meter. This model allows
us to explain how downbeats have a stronger weight than upbeats, and how the
3/8 offset in a 6/8 measure is less strong than its downbeat but still stronger
than the offsets at 1/8, 2/8, 4/8 or 5/8. However, the default model of a 6/8
meter makes no explicit reference to offsets such as 1/16 or 3/16. A common
practice understanding of meter tells us that these offsets should be taken as
less accented than those at 1/8, 2/8, 3/8 and so forth. They effectively
represent an even lower level of leaves on the rhythm-tree for 6/8. Likewise,
offsets with a denominator of 32 or 64 should be explainable in an identical
fashion.

Abjad's \texttt{MetricAccentKernel} provides an object model for both the act
of progressively subdividing the weighted offsets of a meter down to some
arbitrary denominator, and for convolving those offsets as a one-dimensional
convolution kernel against an offset counter. This allows meters to be fitted
against offset counters containing offsets not explicitly modeled by those same
meters. Here a metric accent kernel is generated from a 4/4 meter, extending
its denominator to a limit of 1/16. The weights at each offset are normalized
such that they sum to 1. Normalization prevents very long meters from having
undue influence during meter fitting.

\begin{comment}
<abjad>
meter = metertools.Meter((4, 4))
kernel_44 = metertools.MetricAccentKernel.from_meter(meter, denominator=16)
for offset, weight in sorted(kernel_44.kernel.items()):
    print('{!s}\t{!s}'.format(offset, weight))

</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> meter = metertools.Meter((4, 4))
>>> kernel_44 = metertools.MetricAccentKernel.from_meter(meter, denominator=16)
>>> for offset, weight in sorted(kernel_44.kernel.items()):
...     print('{!s}\t{!s}'.format(offset, weight))
...
0	4/33
1/16	1/33
1/8	2/33
3/16	1/33
1/4	1/11
5/16	1/33
3/8	2/33
7/16	1/33
1/2	1/11
9/16	1/33
5/8	2/33
11/16	1/33
3/4	1/11
13/16	1/33
7/8	2/33
15/16	1/33
1	4/33
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent The 4/4 metric accent kernel can be called against an offset counter
-- as though it were a function -- to generate the convolution response. The
count at each offset in the input offset counter is multiplied against the
weight at the corresponding offset in the metric accent kernel. If no
corresponding offset exists in the kernel, the weight is taken as 0. The
weighted counts are then added together and returned.

\begin{comment}
<abjad>
response = kernel_44(piano_staff_counter)
float(response)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> response = kernel_44(piano_staff_counter)
>>> float(response)
0.5454545454545454
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent The following loop demonstrates the logic underlying the above meter
convolution process example:

\begin{comment}
<abjad>
total = Multiplier(0, 1)
for offset, count in sorted(piano_staff_counter.items()):
    weight = Multiplier(0, 1)
    if offset in kernel_44.kernel:
        weight = kernel_44.kernel[offset]
    weighted_count = weight * count
    total += weighted_count
    message = '{!s}:\tcount: {}, weight: {!s}, multiplied: {!s}, total: {!s}'
    message = message.format(offset, count, weight, weighted_count, total)
    print(message)

</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> total = Multiplier(0, 1)
>>> for offset, count in sorted(piano_staff_counter.items()):
...     weight = Multiplier(0, 1)
...     if offset in kernel_44.kernel:
...         weight = kernel_44.kernel[offset]
...     weighted_count = weight * count
...     total += weighted_count
...     message = '{!s}:\tcount: {}, weight: {!s}, multiplied: {!s}, total: {!s}'
...     message = message.format(offset, count, weight, weighted_count, total)
...     print(message)
...
0:	count: 2, weight: 4/33, multiplied: 8/33, total: 8/33
1/8:	count: 2, weight: 2/33, multiplied: 4/33, total: 4/11
1/4:	count: 2, weight: 1/11, multiplied: 2/11, total: 6/11
1/2:	count: 4, weight: 1/11, multiplied: 4/11, total: 10/11
5/8:	count: 2, weight: 2/33, multiplied: 4/33, total: 34/33
1:	count: 2, weight: 4/33, multiplied: 8/33, total: 14/11
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Now consider the metric accent kernels for 3/4, 7/8 and 5/4 meters:

\begin{comment}
<abjad>
kernel_34 = metertools.MetricAccentKernel.from_meter((3, 4), denominator=16)
kernel_78 = metertools.MetricAccentKernel.from_meter((7, 8), denominator=16)
kernel_54 = metertools.MetricAccentKernel.from_meter((5, 4), denominator=16)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> kernel_34 = metertools.MetricAccentKernel.from_meter((3, 4), denominator=16)
>>> kernel_78 = metertools.MetricAccentKernel.from_meter((7, 8), denominator=16)
>>> kernel_54 = metertools.MetricAccentKernel.from_meter((5, 4), denominator=16)
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent We can generate an response for each of these kernels against the
piano staff offset counter.

\begin{comment}
<abjad>
float(kernel_34(piano_staff_counter))
float(kernel_78(piano_staff_counter))
float(kernel_54(piano_staff_counter))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> float(kernel_34(piano_staff_counter))
0.5384615384615384
\end{lstlisting}
\begin{lstlisting}
>>> float(kernel_78(piano_staff_counter))
0.4482758620689655
\end{lstlisting}
\begin{lstlisting}
>>> float(kernel_54(piano_staff_counter))
0.425
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Note that the previously recorded response for a 4/4 meter is still
higher than any of these three responses.

\subsection{Meter fitting} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Meter fitting involves the progressive comparison of a collection of permitted
meters against the offsets and counts in an offset counter. Starting from the
lowest offset, the metric accent kernel for each meter is convolved with all
those offsets in the offset counter with which it overlaps. The response from
each convolution is recorded and the meter with the highest associated response
is selected to represent those offsets. The process repeats, starting at the
right-most offset of the last meter selected, until no more offsets remain to
compare against.

Consider the following offsets, which are separated from one another by the
duration of a whole note, outlining the start and stop offsets of a series of
4/4 meters.

\begin{comment}
<abjad>
offset_counter = metertools.OffsetCounter([
    (0, 4), (4, 4), (8, 4), (12, 4), (16, 4),
    ])
show(offset_counter, range_=(0, 5))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> offset_counter = metertools.OffsetCounter([
...     (0, 4), (4, 4), (8, 4), (12, 4), (16, 4),
...     ])
>>> show(offset_counter, range_=(0, 5))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-c74006582b28efb1d61d9a6f219c91c8.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Given the following collection of meters, after meter fitting is
performed only 4/4 meters should be selected as they perfectly align with
the previously defined collection of offsets.

\begin{comment}
<abjad>
permitted_meters = metertools.MeterInventory([(3, 4), (4, 4), (5, 4)])
show(permitted_meters, range_=(0, 5))
fitted_meters = metertools.Meter.fit_meters_to_expr(
    expr=offset_counter,
    meters=permitted_meters,
    )
show(fitted_meters, range_=(0, 5))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> permitted_meters = metertools.MeterInventory([(3, 4), (4, 4), (5, 4)])
>>> show(permitted_meters, range_=(0, 5))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-e862fa00da35d33ab02699b7f058c648.pdf}
\begin{lstlisting}
>>> fitted_meters = metertools.Meter.fit_meters_to_expr(
...     expr=offset_counter,
...     meters=permitted_meters,
...     )
>>> show(fitted_meters, range_=(0, 5))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-96511fa6cd9448347d5f584042ff653c.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent If we change the input offsets to no longer outline only 4/4 meters,
the meter fitting process will arrive at a different solution. Note how the
following fitted meters emphasize the 3/4 and 5/4 durations inherent to the new
input offsets. The initial 3/4 fitted meter perfectly matches the offsets 0/1
and 3/4, while the 4/4 meter after it matches the 5/4 offset against its
third beat. The next meter's end-beat offset aligns against the offset
counter's 5/2 offset allowing the meter fitting process to perfectly match the
remaining offsets against a pair of 5/4 meters.

\begin{comment}
<abjad>
offset_counter = metertools.OffsetCounter([
    (0, 4), (3, 4), (5, 4), (10, 4), (15, 4), (20, 4),
    ])
fitted_meters = metertools.Meter.fit_meters_to_expr(
    expr=offset_counter,
    meters=permitted_meters,
    )
show(offset_counter, range_=(0, 5))
show(fitted_meters, range_=(0, 5))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> offset_counter = metertools.OffsetCounter([
...     (0, 4), (3, 4), (5, 4), (10, 4), (15, 4), (20, 4),
...     ])
>>> fitted_meters = metertools.Meter.fit_meters_to_expr(
...     expr=offset_counter,
...     meters=permitted_meters,
...     )
>>> show(offset_counter, range_=(0, 5))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-51cf25a6929362a969d24f3932cb3e52.pdf}
\begin{lstlisting}
>>> show(fitted_meters, range_=(0, 5))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-dd55e0279284ea18fd6b62df64b34865.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Meter fitting can also control for how many times meters are
permitted to immediately repeat. The above example ends with two 5/4 meters in
a row. If desired, this repetition can be prevented entirely by the
\texttt{maximum\_run\_length} keyword to
\texttt{Meter.fit\_meters\_to\_expr()}. With \texttt{maximum\_run\_length} set
to 1, the meter fitting process can no longer select two 5/4 meters for the end
of the fitted meter sequence. Instead, a pair of 3/4 and 4/4 meters replace the
previously final 5/4 meter.

\begin{comment}
<abjad>
fitted_meters = metertools.Meter.fit_meters_to_expr(
    expr=offset_counter,
    meters=permitted_meters,
    maximum_run_length=1,
    )
show(fitted_meters, range_=(0, 5))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> fitted_meters = metertools.Meter.fit_meters_to_expr(
...     expr=offset_counter,
...     meters=permitted_meters,
...     maximum_run_length=1,
...     )
>>> show(fitted_meters, range_=(0, 5))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-ab7c3eddad3d28cb19706ae50e024b17.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\subsection{Meter fitting in practice}

The output of timespan-makers motivates meter fitting more forcefully than the
above trivial examples. Densely layered timespan textures often involve
hundreds or even thousands of offsets with many points of simultaneity or
overlap. Careful management of meter fitting can result in convincing metrical
solutions to such textures.

Recall the quartet timespan texture from earlier in this chapter.

\begin{comment}
<abjad>
music_specifiers = collections.OrderedDict([
    ('Voice 1', None),
    ('Voice 2', None),
    ('Voice 3', None),
    ('Voice 4', None),
    ])
target_timespan = timespantools.Timespan(0, (19, 4))
timespan_inventory = talea_timespan_maker(
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
show(timespan_inventory, key='voice_name')
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> music_specifiers = collections.OrderedDict([
...     ('Voice 1', None),
...     ('Voice 2', None),
...     ('Voice 3', None),
...     ('Voice 4', None),
...     ])
>>> target_timespan = timespantools.Timespan(0, (19, 4))
>>> timespan_inventory = talea_timespan_maker(
...     music_specifiers=music_specifiers,
...     target_timespan=target_timespan,
...     )
>>> show(timespan_inventory, key='voice_name')
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-54d2fa8b64e488a84ee52a488caf28df.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Constructing an offset counter from this timespan inventory shows
several offsets with strong simultaneities, notably at 11/8, 13/8, 17/8 and
25/8.

\begin{comment}
<abjad>
offset_counter = metertools.OffsetCounter(timespan_inventory)
show(offset_counter, range_=(0, (19, 4)))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> offset_counter = metertools.OffsetCounter(timespan_inventory)
>>> show(offset_counter, range_=(0, (19, 4)))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-0be2900a4872bf90fe9bfb22c1e66b72.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent As before, a collection of permitted meters are fit against the
offset counter. Compare the weights in the counter to the meter sequence below
it. Offsets in the counter with weights greater than 1 tend to have been fitted
against strong beats in each meter. The initial 6/8 meter receive a 2-count
accent on its half-way 3/8 offset. The second 6/8 meter is matches strong
accents on both its downbeat, its half-beat and on its end-beat. Likewise, the
7/8 meter matches strong accents on its down-beat and end-beat, as well as its
inner 2-count groupings.

\begin{comment}
<abjad>
permitted_meters = metertools.MeterInventory([
    (5, 8), (3, 4), (6, 8), (7, 8), (4, 4),
    ])
fitted_meters = metertools.Meter.fit_meters_to_expr(
    expr=offset_counter,
    meters=permitted_meters,
    maximum_run_length=1,
    )
show(offset_counter, range_=(0, (19, 4)))
show(fitted_meters, range_=(0, (19, 4)))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> permitted_meters = metertools.MeterInventory([
...     (5, 8), (3, 4), (6, 8), (7, 8), (4, 4),
...     ])
>>> fitted_meters = metertools.Meter.fit_meters_to_expr(
...     expr=offset_counter,
...     meters=permitted_meters,
...     maximum_run_length=1,
...     )
>>> show(offset_counter, range_=(0, (19, 4)))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-0be2900a4872bf90fe9bfb22c1e66b72.pdf}
\begin{lstlisting}
>>> show(fitted_meters, range_=(0, (19, 4)))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-4252566a868aa8669a597a9b20a09b83.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Removing the 5/8 meter from the permitted meters inventory gives less
convincing results. Notably, the strong simultaneities at offsets 11/8 and 17/8
no longer align with any downbeats in the fitted meters.

\begin{comment}
<abjad>
permitted_meters = metertools.MeterInventory([
    (3, 4), (6, 8), (7, 8), (4, 4),
    ])
fitted_meters = metertools.Meter.fit_meters_to_expr(
    expr=offset_counter,
    maximum_run_length=1,
    meters=permitted_meters,
    )
show(offset_counter, range_=(0, (19, 4)))
show(fitted_meters, range_=(0, (19, 4)))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> permitted_meters = metertools.MeterInventory([
...     (3, 4), (6, 8), (7, 8), (4, 4),
...     ])
>>> fitted_meters = metertools.Meter.fit_meters_to_expr(
...     expr=offset_counter,
...     maximum_run_length=1,
...     meters=permitted_meters,
...     )
>>> show(offset_counter, range_=(0, (19, 4)))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-0be2900a4872bf90fe9bfb22c1e66b72.pdf}
\begin{lstlisting}
>>> show(fitted_meters, range_=(0, (19, 4)))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-9a5158818ad5fbad7bdb5f19fd966315.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Lifting the constraint on meter repetition does not improve the
results. Both the 11/8 and 17/8 offsets still align with weak beats in the
fitted meters. The only real change is the swapping of 6/8 and 3/4 meters in
the first and last pairs of fitted meters.

\begin{comment}
<abjad>
fitted_meters = metertools.Meter.fit_meters_to_expr(
    expr=offset_counter,
    meters=permitted_meters,
    )
show(offset_counter, range_=(0, (19, 4)))
show(fitted_meters, range_=(0, (19, 4)))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> fitted_meters = metertools.Meter.fit_meters_to_expr(
...     expr=offset_counter,
...     meters=permitted_meters,
...     )
>>> show(offset_counter, range_=(0, (19, 4)))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-0be2900a4872bf90fe9bfb22c1e66b72.pdf}
\begin{lstlisting}
>>> show(fitted_meters, range_=(0, (19, 4)))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-4dea6222540afc3cf0b84d79ca2bc728.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent However, reinstating the repetition constraint and permitting a
greater variety of meters gives an even closer fitting than the very first
example. Not only do the 11/8 and 17/8 offsets align at downbeats, but the
three-weight offset at 25/8 matches the downbeat of a 3/4 meter with two-weight
accents on both its second and third beat as well as the following downbeat.

\begin{comment}
<abjad>
permitted_meters = metertools.MeterInventory([
    (2, 4), (4, 8), (3, 4), (6, 8), (7, 8), (4, 4),
    ])
fitted_meters = metertools.Meter.fit_meters_to_expr(
    expr=offset_counter,
    maximum_run_length=1,
    meters=permitted_meters,
    )
show(offset_counter, range_=(0, (19, 4)))
show(fitted_meters, range_=(0, (19, 4)))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> permitted_meters = metertools.MeterInventory([
...     (2, 4), (4, 8), (3, 4), (6, 8), (7, 8), (4, 4),
...     ])
>>> fitted_meters = metertools.Meter.fit_meters_to_expr(
...     expr=offset_counter,
...     maximum_run_length=1,
...     meters=permitted_meters,
...     )
>>> show(offset_counter, range_=(0, (19, 4)))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-0be2900a4872bf90fe9bfb22c1e66b72.pdf}
\begin{lstlisting}
>>> show(fitted_meters, range_=(0, (19, 4)))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-a1f558ce38e84f316c17684a30bd0fac.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Increasing the number of permitted offsets even further does not
necessarily improve results. A better initial meter fitting -- like the initial
9/8 here -- often diminishes the choices possible afterward.

\begin{comment}
<abjad>
permitted_meters = metertools.MeterInventory([
    (2, 4), (3, 16), (3, 4), (4, 4), (4, 8), (5, 16),
    (5, 4), (5, 8), (6, 8), (7, 8), (9, 8),
    ])
poorly_fitted_meters = metertools.Meter.fit_meters_to_expr(
    expr=offset_counter,
    maximum_run_length=1,
    meters=permitted_meters,
    )
show(offset_counter, range_=(0, (19, 4)))
show(poorly_fitted_meters, range_=(0, (19, 4)))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> permitted_meters = metertools.MeterInventory([
...     (2, 4), (3, 16), (3, 4), (4, 4), (4, 8), (5, 16),
...     (5, 4), (5, 8), (6, 8), (7, 8), (9, 8),
...     ])
>>> poorly_fitted_meters = metertools.Meter.fit_meters_to_expr(
...     expr=offset_counter,
...     maximum_run_length=1,
...     meters=permitted_meters,
...     )
>>> show(offset_counter, range_=(0, (19, 4)))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-0be2900a4872bf90fe9bfb22c1e66b72.pdf}
\begin{lstlisting}
>>> show(poorly_fitted_meters, range_=(0, (19, 4)))
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-78da5486599d2faeead3b3ce63e0ba05.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent The process of meter fitting described here is not perfect. While
useful for creating generally convincing metrical solutions to dense timespan
structures, meter fitting could probably be better solved through human
intervention. The fitting process often over-emphasizes local attack point
maxima while ignoring larger or more elegant metrical patterns. Likewise, the
process often provides an accurate fitting for the very first meter, but causes
a cascade of poor solutions for every following meter. Where procedural meter
fitting wins over human intervention is in speed. Solutions to enormous
timespan inventories with hundreds or thousands of timespans can be found in
less than a second, facilitating the rapid sketching and revising of
timespan-based musical structures.

Meter fitting can be considered as a kind of constraint problem. The set of
permitted meters act as a search space while each progressive selection of
offsets from the input offset counter act as the problem to solve against. In
that light, improvements might involve searching for meter solutions with
increased \emph{lookahead} -- that is, fitting the current meter based not only
on its response to a selection of offsets, but also on how well any meter
following it would score. Searching the offset counter for patterns, changing
the weighting algorithm of metric accent kernels, or jumping directly to the
attack point maxima in the input offset counter and solving forwards and
backwards from them are also possible avenues for improvement.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Synthesizing time techniques}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The techniques outlined in this chapter -- timespan inventories,
timespan-makers, rhythm-makers, meter fitting and rewriting -- describe various
ways of modeling, creating and manipulating aspects of musical score. Taken
separately, none of them can ever result in the rhythmic framework for a
polyphonic piece of music. However, by combining all of them together, it is
possible to construct powerful tools for generating arbitrarily large amounts
of notation.

The following \texttt{build\_score()} function outlines one possible approach
to combining these techniques. This function creates a score from a
rhythm-maker, a sequence of permitted meters, a score template and a timespan
inventory. The timespan inventory must contain performed timespans whose voice
names align with the voice names in the score produced by the score template.
For example, Abjad's \texttt{GroupedRhythmicStavesScoreTemplate} class can
produce scores containing voices with names like \enquote{Voice 1},
\enquote{Voice 2} and so forth. The timespan inventory used for this example --
created earlier in this chapter -- contains performed timespans with the voice
names \enquote{Voice 1}, \enquote{Voice 2}, \enquote{Voice 3} and
\enquote{Voice 4}, requiring a score template capabable of creating scores with
four staves of one voice each.

\begin{comment}
<abjad>
show(timespan_inventory, key='voice_name')
score_template = templatetools.GroupedRhythmicStavesScoreTemplate(
    staff_count=4, with_clefs=True,
    )
score = score_template()
print(format(score))
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> show(timespan_inventory, key='voice_name')
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-54d2fa8b64e488a84ee52a488caf28df.pdf}
\begin{lstlisting}
>>> score_template = templatetools.GroupedRhythmicStavesScoreTemplate(
...     staff_count=4, with_clefs=True,
...     )
>>> score = score_template()
>>> print(format(score))
\context Score = "Grouped Rhythmic Staves Score" <<
    \context StaffGroup = "Grouped Rhythmic Staves Staff Group" <<
        \context RhythmicStaff = "Staff 1" {
            \clef "percussion"
            \context Voice = "Voice 1" {
            }
        }
        \context RhythmicStaff = "Staff 2" {
            \clef "percussion"
            \context Voice = "Voice 2" {
            }
        }
        \context RhythmicStaff = "Staff 3" {
            \clef "percussion"
            \context Voice = "Voice 3" {
            }
        }
        \context RhythmicStaff = "Staff 4" {
            \clef "percussion"
            \context Voice = "Voice 4" {
            }
        }
    >>
>>
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

Score building proceeds by first fitting the permitted meters against the
timespan inventory and calculating their meter boundaries -- the offsets of
each downbeat, as well as the virtual downbeat, the \enquote{end-beat}, after
the final meter. Then the timespans in the input timespan inventory are
separated into new timespan inventories according to their associated voice
names, with these new inventories stored in a dictionary whose keys are those
same voice name. The score template generates an un-populated score and the
voice components in this score are iterated over. For each iterated voice, an
inventory of timespans is retrieved from the \texttt{all\_voicewise\_timespans}
dictionary. If no inventory exists, an empty one is created. The associated
performed timespans are partitioned into contiguous groups in order to
facilitate rhythm generation. Each partitioned group is passed, along with the
input rhythm-maker, the fitted meter boundaries, and a seed value -- the number
of performed timespan groups encountered so far -- to a rhythm generation
subroutine, with the resulting phrase container appended into the current
voice. If a gap is encountered between two partitioned groups, between the
beginning of the first partitioned group and the beginning of the score -- the
offset 0, or between the end of the last partitioned group and the final meter
boundary, "silent music" will be created in the form of rests grouped into a
container, with that container then inserted into the current voice.

\begin{comment}
<abjadextract dissertation.py.time_tools:build_score />[strip_prompt]
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
def build_score(
    performed_rhythm_maker,
    permitted_meters,
    score_template,
    timespan_inventory,
    ):
    fitted_meters, meter_boundaries = get_meters_and_meter_boundaries(
        timespan_inventory, permitted_meters)
    all_voicewise_timespans = get_all_voicewise_timespans(timespan_inventory)
    seed = 0
    score = score_template()
    for voice in iterate(score).by_class(Voice):
        if voice.name not in all_voicewise_timespans:
            all_voicewise_timespans[voice.name] = \
                timespantools.TimespanInventory()
        voice_timespans = all_voicewise_timespans[voice.name]
        previous_stop_offset = Offset(0)
        for shard in voice_timespans.partition(include_tangent_timespans=True):
            if shard.start_offset != previous_stop_offset:
                silent_music = make_silent_music(
                    meter_boundaries=meter_boundaries,
                    start_offset=previous_stop_offset,
                    stop_offset=shard.start_offset,
                    )
                voice.append(silent_music)
            performed_music = make_performed_music(
                meter_boundaries=meter_boundaries,
                rhythm_maker=performed_rhythm_maker,
                seed=seed,
                timespans=shard,
                )
            voice.append(performed_music)
            seed += 1
            previous_stop_offset = shard.stop_offset
        if previous_stop_offset != meter_boundaries[-1]:
            silent_music = make_silent_music(
                meter_boundaries=meter_boundaries,
                start_offset=previous_stop_offset,
                stop_offset=meter_boundaries[-1],
                )
            voice.append(silent_music)
        for phrase in voice:
            rewrite_meters(phrase, fitted_meters, meter_boundaries)
    add_time_signature_context(score, fitted_meters)
    return score
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent A meter sequence of equal or greater duration to the input timespan
inventory can be produced through fitting a collection of permitted meters
against that same input timespan inventory. The sequence of offsets found at
the boundaries of each fitted meter can then be determined by computing the
cumulative sums of the durations of the fitted meters. These boundary offsets
will be used to split timespans before they are fed to rhythm-makers for rhythm
generation in order to ensure that no generated rhythm crosses any barlines.

\begin{comment}
<abjadextract dissertation.py.time_tools:get_meters_and_meter_boundaries />[strip_prompt]
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
def get_meters_and_meter_boundaries(timespan_inventory, permitted_meters):
    offset_counter = metertools.OffsetCounter(timespan_inventory)
    fitted_meters = metertools.Meter.fit_meters_to_expr(
        expr=offset_counter,
        maximum_run_length=1,
        meters=permitted_meters,
        )
    meter_durations = [Duration(_) for _ in fitted_meters]
    meter_boundaries = mathtools.cumulative_sums(
        meter_durations,
        start=Offset(0),
        )
    return fitted_meters, meter_boundaries
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Each of the performed timespans in the input timespan inventory was
configured with a voice name, allowing that timespan to be associated with a
voice context in the score hierarchy produced by the input score template. As
demonstrated earlier, Abjad components can be indexed by context name
regardlesss of the depth of the named context in the score hierarchy.

\begin{comment}
<abjad>
timespan = timespan_inventory[0]
print(format(timespan))
score = score_template()
voice = score[timespan.voice_name]
for component in inspect_(voice).get_parentage():
    component

</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> timespan = timespan_inventory[0]
>>> print(format(timespan))
consort.tools.PerformedTimespan(
    start_offset=durationtools.Offset(0, 1),
    stop_offset=durationtools.Offset(1, 4),
    original_start_offset=durationtools.Offset(9, 2),
    original_stop_offset=durationtools.Offset(19, 4),
    voice_name='Voice 3',
    )
\end{lstlisting}
\begin{lstlisting}
>>> score = score_template()
>>> voice = score[timespan.voice_name]
>>> for component in inspect_(voice).get_parentage():
...     component
...
Voice()
<RhythmicStaff-"Staff 3"{1}>
<StaffGroup-"Grouped Rhythmic Staves Staff Group"<<4>>>
<Score-"Grouped Rhythmic Staves Score"<<1>>>
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent In order to populate each voice in the score, the timespans in the
timespan inventory need to be separated into \emph{voice-wise} timespan
inventories, each only containing timespans associated with the same voice.
This can be accomplished by building a dictionary whose keys are voice names
and whose values are timespan inventories.

\begin{comment}
<abjadextract dissertation.py.time_tools:get_all_voicewise_timespans />[strip_prompt]
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
def get_all_voicewise_timespans(timespan_inventory):
    voicewise_timespans = {}
    for timespan in timespan_inventory:
        voice_name = timespan.voice_name
        if voice_name not in voicewise_timespans:
            voicewise_timespans[voice_name] = timespantools.TimespanInventory()
        voicewise_timespans[voice_name].append(timespan)
    return voicewise_timespans
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Creating \emph{performed} music requires first splitting a contiguous
inventory of performed timespans by meter boundaries, collecting the shards
together into a new inventory and then calculating the durations of those
timespans. The resulting sequence of durations, along with an input
rhythm-maker and an optional seed value can be sent to another function for
rhythm generation.

\begin{comment}
<abjadextract dissertation.py.time_tools:make_performed_music />[strip_prompt]
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
def make_performed_music(rhythm_maker, timespans, meter_boundaries, seed=0):
    split_timespans = timespantools.TimespanInventory()
    for shard in timespans.split_at_offsets(meter_boundaries):
        split_timespans.extend(shard)
    durations = [_.duration for _ in split_timespans if _.duration]
    music = make_music(rhythm_maker, durations, seed=seed)
    return music
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Similarly, \emph{silent} music -- rests between groups of performed
timespans in each voice -- can be created by constructing a timespan which
outlines the gap between other performed timespans, splitting that timespan by
meter boundaries, collecting the durations of the split shards, and finally
passing those durations along with a rest-generating rhythm-maker to another
function for rhythm generation.

\begin{comment}
<abjadextract dissertation.py.time_tools:make_silent_music />[strip_prompt]
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
def make_silent_music(start_offset, stop_offset, meter_boundaries):
    silence_timespan = timespantools.Timespan(start_offset, stop_offset)
    shards = silence_timespan.split_at_offsets(meter_boundaries)
    durations = [_.duration for _ in shards if _.duration]
    mask = rhythmmakertools.mask_all()
    rhythm_maker = rhythmmakertools.NoteRhythmMaker(output_masks=[mask])
    music = make_music(rhythm_maker, durations)
    return music
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Both silent and performed music generation relies on the same core
rhythm generating function. This function calls its input rhythm-maker with a
sequence of durations and an optional seed value, which may be interpreted
variably depending on what kind of rhythm-maker was used, but which generally
results in the rotation of any sequence-like configured value in that
rhythm-maker, such as talea. The product of this first operation is a sequence
of component selections. Some massaging converts this selections into a
sequence of trivially-prolated containers and non-trivially prolated tuplets
which can then be wrapped inside a larger container representing a complete
phrase.

\begin{comment}
<abjadextract dissertation.py.time_tools:make_music />[strip_prompt]
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
def make_music(rhythm_maker, durations, seed=0):
    music = rhythm_maker(durations, seeds=seed)
    for i, division in enumerate(music):
        if len(division) == 1 and isinstance(division[0], scoretools.Tuplet):
            music[i] = division[0]
        else:
            music[i] = scoretools.Container(division)
    music = scoretools.Container(music)
    return music
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent After all phrases for a voice have been generated, their meters are
rewritten. This process involves simultaneously iterating through both the
divisions in each phrase along with pairs of meters and meter downbeat
offsets -- that is, the offset from the origin of the score where each meter
begins.\footnote{More optimizations to this joint container / meter iteration
are obviously possible. Some have even been implemented in Consort's source.
Such optimization include associating meters with their own timespans, and
storing these meter-timespans in an optimized interval-tree datastructure
allowing rapid retrieval by both offset and timespan intersection. For the sake
of pedagogical clarity, a more naive approach is used here.} Un-prolated
division containers are rewritten according to the meter active when they
begin. Because a division may start \emph{after} a meter has begun it is
necessary to calculate the difference between each un-prolated division's start
offset and each meter's start offset. This difference is passed to the
\texttt{MutationAgent}'s \texttt{rewrite\_meter()} method via the
\texttt{initial\_offset} keyword, allowing the division to be properly aligned
against the desired meter. Prolated divisions -- tuplets -- are rewritten
solely with respect to the duration of their contents, not to the prevailing
meter. That is, a 5:4 tuplet in a 4/8 measure is rewritten with a meter of 5/8,
not of 4/8.

\begin{comment}
<abjadextract dissertation.py.time_tools:rewrite_meters />[strip_prompt]
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
def rewrite_meters(phrase, meters, meter_boundaries):
    pairs = list(zip(meters, meter_boundaries))
    for division in phrase:
        division_offset = inspect_(division).get_timespan().start_offset
        while 1 < len(pairs) and pairs[1][1] <= division_offset:
            pairs.pop(0)
        if isinstance(division, scoretools.Tuplet):
            contents_duration = division._contents_duration
            meter = metertools.Meter(contents_duration)
            mutate(division[:]).rewrite_meter(
                meter,
                boundary_depth=1,
                )
        else:
            meter, meter_boundary = pairs[0]
            initial_offset = division_offset - meter_boundary
            mutate(division[:]).rewrite_meter(
                meter,
                boundary_depth=1,
                initial_offset=initial_offset,
                )
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent The final step in this score building process adds a \enquote{floating time
signature context} to the score, filled with typographic spacer skips and time
signature commands, one for each of the fitted meters. This context appears as
a row of time signatures floating above the topmost staff in the score,
allowing time signatures to be omitted from every staff in the score and
thereby improving proportional notation spacing. The time signature context's
\texttt{context\_name} property instructs LilyPond to look for a context
definition with that name and apply any typographic overrides found there
during the typesetting process. While LilyPond does not come packaged with a
\texttt{TimeSignatureContext} definition, examples of what such a definition
looks like can be found in the various \texttt{stylesheet} sections of the
source code appendices to this document.

\begin{comment}
<abjadextract dissertation.py.time_tools:add_time_signature_context />[strip_prompt]
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
def add_time_signature_context(score, meters):
    time_signatures = [_.implied_time_signature for _ in meters]
    measures = scoretools.make_spacer_skip_measures(time_signatures)
    time_signature_context = scoretools.Context(
        [measures],
        context_name='TimeSignatureContext',
        name='TimeSignatureContext',
        )
    score.insert(0, time_signature_context)
\end{lstlisting}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Calling the \texttt{build\_score()} function generates a score as
described above. In this example, the function's arguments comprise a talea
rhythm-maker, an inventory of meters, as well as the previously defined score
template and timespan inventory.

\begin{comment}
<abjad>
permitted_meters = metertools.MeterInventory([
    (2, 4), (4, 8), (3, 4), (6, 8), (7, 8), (4, 4),
    ])
performed_rhythm_maker = rhythmmakertools.TaleaRhythmMaker(
    beam_specifier=rhythmmakertools.BeamSpecifier(
        beam_each_division=True,
        beam_divisions_together=True,
        ),
    extra_counts_per_division=(0, 1),
    talea=rhythmmakertools.Talea([1, 2, 3, 4, 5], 16),
    )
show(performed_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> permitted_meters = metertools.MeterInventory([
...     (2, 4), (4, 8), (3, 4), (6, 8), (7, 8), (4, 4),
...     ])
>>> performed_rhythm_maker = rhythmmakertools.TaleaRhythmMaker(
...     beam_specifier=rhythmmakertools.BeamSpecifier(
...         beam_each_division=True,
...         beam_divisions_together=True,
...         ),
...     extra_counts_per_division=(0, 1),
...     talea=rhythmmakertools.Talea([1, 2, 3, 4, 5], 16),
...     )
>>> show(performed_rhythm_maker, divisions=divisions)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-12a3ce90ede7ebf565493e80cd2b641b.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent For clarity, the phrases and their internal divisions have been
annotated via Consort's \texttt{annotate} function. This function draws thick
brackets underneath each staff, with the lower bracket indicating the overall
phrase grouping and the inner brackets indicating divisions within each phrase.
Entirely silent phrasing brackets are drawn with dashed rather than solid
lines.

\begin{comment}
<abjad>[stylesheet=../consort-small.ily]
score = build_score(
    performed_rhythm_maker=performed_rhythm_maker,
    permitted_meters=permitted_meters,
    score_template=score_template,
    timespan_inventory=timespan_inventory,
    )
consort.annotate(score)
show(score)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> score = build_score(
...     performed_rhythm_maker=performed_rhythm_maker,
...     permitted_meters=permitted_meters,
...     score_template=score_template,
...     timespan_inventory=timespan_inventory,
...     )
>>> consort.annotate(score)
>>> show(score)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-8ece1468ead3048f49429d2eead03474.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Large-scale variations are possible simply by altering the arguments
to the \texttt{build\_score()} function. For example, the timespan inventory
can be reflected around its axis and stretched from a duration of 19/4 to 25/4.
This will change the overall duration and phrase density of the resulting score
while maintaining the character of its surface rhythms.

\begin{comment}
<abjad>[stylesheet=../consort-small.ily]
multiplier = Duration(24, 4) / Duration(19, 4)
timespan_inventory = timespan_inventory.reflect()
timespan_inventory = timespan_inventory.stretch(multiplier)
timespan_inventory = timespan_inventory.round_offsets(Duration(1, 8))
show(timespan_inventory, key='voice_name')
score = build_score(
    performed_rhythm_maker=performed_rhythm_maker,
    permitted_meters=permitted_meters,
    score_template=score_template,
    timespan_inventory=timespan_inventory,
    )
consort.annotate(score)
show(score)
</abjad>
\end{comment}

%%% ABJADBOOK START %%%
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{lstlisting}
>>> multiplier = Duration(24, 4) / Duration(19, 4)
>>> timespan_inventory = timespan_inventory.reflect()
>>> timespan_inventory = timespan_inventory.stretch(multiplier)
>>> timespan_inventory = timespan_inventory.round_offsets(Duration(1, 8))
>>> show(timespan_inventory, key='voice_name')
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-2946788e9f258035fb10f3011cd4a737.pdf}
\begin{lstlisting}
>>> score = build_score(
...     performed_rhythm_maker=performed_rhythm_maker,
...     permitted_meters=permitted_meters,
...     score_template=score_template,
...     timespan_inventory=timespan_inventory,
...     )
>>> consort.annotate(score)
>>> show(score)
\end{lstlisting}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-95fbbd917e003934806c4cf066250909.pdf}
\end{singlespacing}
%%% ABJADBOOK END %%%

\noindent Other variations and extensions are possible. The input rhythm-maker
could be varied or replaced by a composite rhythm-maker. The score generation
process could be extended so that rhythm-makers could be stored on the
performed timespans themselves, allowing each performed timespan to specify its
local rhythmic language. Multiple timespan inventories could be combined
together using the various logical operations to implement masking or fusing
when timespans from one inventory overlap those from another. In fact, all of
these extensions and variations are employed in Consort's own score generation
process.

\section{Implications}

\begin{markdown}

-   Timespans allow for large scale phrasing and density structures.

-   Timespan annotations allow for maquette-like composition techniques, or
    working in a way that conceptually mirrors working with a DAW, even though
    there is no real graphic output except for notation itself.

-   Annotations can act as a description of what sort of material should appear
    in what locations -- both horizontally in time and vertically in the score
    hierarchy.

-   Timespans also allow for overlap, and have affordances for masking.

-   This allows timespans to be created by a factories in layers, and those
    layers resolved down to a single non-overlapping layer via masking.

-   All of the maker tools described here (and in the next chapter) emphasize
    working with patterns.

-   Sufficiently complex patterns of discrete numbers (and combinations of
    patterns) are perceptually indistinguishable from randomness. It doesn't
    take much.

-   Likewise, randomness -- no matter how it is arrived at, windowed, weighted
    and so forth -- is a kind of maintenance burden. How can you know that
    your compositional machinery is behaving correctly when the results are
    always different by design?

-   Only a few recipes for timespan and rhythm creation have been outlined
    here. Obviously, many more are possible, with other paradigms. The models
    described here generally rely on patterns. Other work could create
    rhythm-makers which take pitches as input, or which follow breakpoints, or
    mimic some other external structure. Likewise with timespan-makers. More
    work could be done to create stronger intentional interrelations between
    timespans.

-   One of the strengths in the overall design philosophy described throughout
    this chapter is extensibility. Just because I *haven't* yet created a
    derived-from-bird-song rhythm-maker doesn't mean I can't. Such a maker
    could be created and follow the same interface as all other rhythm-makers,
    benefitting from their foundation of shared notational logics.

\end{markdown}