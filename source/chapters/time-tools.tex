%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Tools for modeling time, rhythm and meter}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{comment}
<abjad>[hide=true]
import consort
</abjad>
\end{comment}

Consort's implementation of a model of composition relies on a number of
different but interrelated models of musical time. A thorough discussion of
these time models here will clarify the analysis of Consort's implementation in
the following chapters.

Dichotomies: outside and inside the score hierarchy, with or without regard to
notation, "coarse" versus "fine" or "phrase" versus "event", vertical or
horizontal, metered and unmetered, potentially simultaneous or strictly
contiguous.

Timespans provide a coarse model of musical time, both in and outside of score
hierarchy.

Notated rhythm provides a fine model of musical time, from within score
hierarchy.

Meter coordinates time and rhythm vertically across score hierarchy, and
bridges the coarse and fine stages of rhythmic interpretation.

Meter is generated as a by-product of phrase-level composition. It is not
specified by-hand during composition. This is not out of any desire to valorize
automaticism, but simply because lacking any other compelling reason to
generate a series of meters I felt the best way for myself would be to have
those meters derive from some sort of pre-existent structure in my
compositional process.

A discussion of these time models and their implications will clarify a later
analysis of the implementation of Consort's score interpretation
stage.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Timespans}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

A timespan is simply a start offset paired with a stop offset as a closed/open
interval\footnote{Add a discussion of the mathematical definition of closed and
open intervals here.}. Timespans represent an interval of time, of duration 0
or greater, positioned somewhere along an arbitrary timeline. Every durated
object in a score \emph{has} a timespan -- including the score itself, but
timespans exist -- by definition -- without regard for any specific score, in
whole or part.

Abjad models timespans as the class \texttt{timespantools.Timespan}.

\begin{comment}
<abjad>
timespan = timespantools.Timespan(
    start_offset=Offset(1, 4),
    stop_offset=Offset(3, 2),
    )
</abjad>
\end{comment}

\subsection{Inspecting timespans}

\begin{comment}
<abjad>
timespan.start_offset
timespan.stop_offset
timespan.duration
</abjad>
\end{comment}

\begin{comment}
<abjad>
malformed_timespan = timespantools.Timespan(0, 0)
malformed_timespan.is_well_formed
</abjad>
\end{comment}

\begin{comment}
<abjad>
templated_timespan = new(timespan, stop_offset=(5, 16))
print(format(templated_timespan))
</abjad>
\end{comment}

\begin{comment}
<abjad>
annotated_timespan = timespantools.AnnotatedTimespan(
    start_offset=(1, 8),
    stop_offset=(7, 8),
    annotation='Any arbitrary object can act as an annotation.'
    )
annotated_timespan.annotation
</abjad>
\end{comment}

\subsection{Time relations}

- time relations: intersection, congruency etc.

\begin{comment}
<abjad>
timespan_1 = timespantools.Timespan(0, 10)
timespan_2 = timespantools.Timespan(5, 15)
timespan_3 = timespantools.Timespan(10, 15)
</abjad>
\end{comment}

\begin{comment}
<abjad>
timespan_1.intersects_timespan(timespan_2)
timespan_1.intersects_timespan(timespan_3)
timespan_2.intersects_timespan(timespan_1)
timespan_2.intersects_timespan(timespan_3)
timespan_3.intersects_timespan(timespan_1)
timespan_3.intersects_timespan(timespan_2)
</abjad>
\end{comment}

\begin{comment}
<abjad>
timespan_1.is_congruent_to_timespan(timespan_2)
timespan_1.is_congruent_to_timespan(timespan_1)
</abjad>
\end{comment}

\begin{comment}
<abjad>
timespan_1.is_tangent_to_timespan(timespan_2)
timespan_1.is_tangent_to_timespan(timespan_3)
</abjad>
\end{comment}

\subsection{Operations on timespans}

Consider the following three timespans again.

\begin{comment}
<abjad>
timespan_1 = timespantools.Timespan(0, 10)
timespan_2 = timespantools.Timespan(5, 15)
timespan_3 = timespantools.Timespan(10, 15)
</abjad>
\end{comment}

The logical AND of any two timespans can be computed.

\begin{comment}
<abjad>
timespan_1 & timespan_2
timespan_1 & timespan_3
timespan_2 & timespan_3
</abjad>
\end{comment}

The logical OR of any two timespans can be computed.

\begin{comment}
<abjad>
timespan_1 | timespan_2
timespan_1 | timespan_3
timespan_2 | timespan_3
</abjad>
\end{comment}

Timespan subtraction is another crucial operation.

\begin{comment}
<abjad>
timespan_1 = timespantools.Timespan(0, 15)
timespan_2 = timespantools.Timespan(5, 10)
timespan_3 = timespantools.Timespan(10, 20)
</abjad>
\end{comment}

\begin{comment}
<abjad>
print(format(timespan_1 - timespan_1))
print(format(timespan_1 - timespan_2))
print(format(timespan_1 - timespan_3))
print(format(timespan_2 - timespan_1))
print(format(timespan_2 - timespan_2))
print(format(timespan_2 - timespan_3))
print(format(timespan_3 - timespan_1))
print(format(timespan_3 - timespan_2))
print(format(timespan_3 - timespan_3))
</abjad>
\end{comment}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Timespan inventories}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Timespans can be aggregated together in an instance of the TimespanInventory
class. In addition to the protocol defined for ordered collections, timespan
inventories provide a variety of other methods and properties for working
specifically with timespans.

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory()
timespan_inventory.append(timespantools.Timespan(0, 16))
timespan_inventory.append(timespantools.Timespan(5, 12))
timespan_inventory.append(timespantools.Timespan(-2, 8))
timespan_inventory.append(timespantools.Timespan(15, 20))
print(format(timespan_inventory))
</abjad>
\end{comment}

\subsection{Inspecting timespan inventories}

\begin{comment}
<abjad>
len(timespan_inventory)
timespan_inventory[1]
for timespan in timespan_inventory:
    timespan
    
</abjad>
\end{comment}

\begin{comment}
<abjad>
timespan_inventory.start_offset
timespan_inventory.stop_offset
timespan_inventory.duration
timespan_inventory.timespan
timespan_inventory.all_are_contiguous
timespan_inventory.all_are_nonoverlapping
timespan_inventory.all_are_well_formed
</abjad>
\end{comment}

\subsection{Unioning, differencing and splitting}

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(0, 16),
    timespantools.Timespan(5, 12),
    timespantools.Timespan(-2, 8),
    ])
timespan = timespantools.Timespan(5, 10)
result = timespan_inventory & timespan
print(format(timespan_inventory))
</abjad>
\end{comment}

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(0, 16),
    timespantools.Timespan(5, 12),
    timespantools.Timespan(-2, 8),
    ])
timespan = timespantools.Timespan(5, 10)
result = timespan_inventory - timespan
print(format(timespan_inventory))
</abjad>
\end{comment}

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(0, 3),
    timespantools.Timespan(3, 6),
    timespantools.Timespan(6, 10),
    ])
left, right = timespan_inventory.split_at_offset(4)
print(format(left))
print(format(right))
</abjad>
\end{comment}

\begin{comment}
Timespan.split_at_offsets()
\end{comment}

\subsection{Timewise partitioning}

\begin{comment}
<abjad>
timespan_inventory = timespantools.TimespanInventory([
    timespantools.Timespan(0, 10),
    timespantools.Timespan(5, 15),
    timespantools.Timespan(15, 20),
    timespantools.Timespan(25, 30),
    ])
</abjad>
\end{comment}

\begin{comment}
<abjad>
for inventory in timespan_inventory.partition():
    print(format(inventory))

</abjad>
\end{comment}

\begin{comment}
<abjad>
for inventory in timespan_inventory.partition(include_tangent_timespans=True):
    print(format(inventory))

</abjad>
\end{comment}

\subsection{Other timespan inventory operations}

\begin{comment}
TimespanInventory.clip_timespan_durations
TimespanInventory.count_offsets()
TimespanInventory.explode()
TimespanInventory.round_offsets()
\end{comment}

\subsection{Optimized timespan inventories}

Consort provides its own timespan collection class -- the TimespanCollection.
This class stores timespans internally not as a list, but in a balanced
\emph{interval tree}\footnote{An interval tree is an augmented self-balancing
binary tree which stores both start offsets as well as stop offsets.}
datastructure which guarantees sorting and allows for highly optimized lookups
of timespans intersecting specific offsets. This class is used at crucial
points during Consort's interpretation stage simply for purposes of speed, and
should be considered an implementation detail. With work, its internal
datastructure will eventually be merged into Abjad's TimespanInventory.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Annotated timespans in \emph{Consort}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We need to discuss the products of timespan makers before we can discuss
timespan makers themselves.

\subsection{Payloaded timespans}

- layer

- voice name

\subsection{\emph{Performed} timespans}

\begin{comment}
<abjad>
performed_timespan = consort.PerformedTimespan(
    layer=1,
    minimum_duration=Duration(1, 8),
    music_specifier=consort.MusicSpecifier(),
    start_offset=Offset(1, 4),
    stop_offset=Offset(2, 1),
    voice_name='Violin 1 LH Voice',
    )
</abjad>
\end{comment}

- forbid fusing

- forbid splitting

- minimum duration

- (additionally, music specifier: minimum phrase duration)

- divisions

- music

- music specifier

\subsection{\emph{Silent} timespans}

\begin{comment}
<abjad>
silent_timespan = consort.SilentTimespan(
    layer=2,
    start_offset=Offset(0, 1),
    stop_offset=Offset(1, 4),
    voice_name='Violin 1 LH Voice',
    )
</abjad>
\end{comment}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Timespan makers}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

- timespan specifier

- independent vs dependent

- target timespans

- talea

- padding

\subsection{FloodedTimespanMaker}

\begin{comment}
<abjad>
flooded_timespan_maker = consort.FloodedTimespanMaker()
print(format(flooded_timespan_maker))
</abjad>
\end{comment}

\begin{comment}
<abjad>
music_specifiers = {'Violin Voice': 'violin music'}
target_timespan = timespantools.Timespan((1, 4), (11, 8))
timespan_inventory = flooded_timespan_maker(
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
print(format(timespan_inventory))
</abjad>
\end{comment}

Adding a second music specifier entry and a layer keyword generates another
collection of timespans.

\begin{comment}
<abjad>
music_specifiers = {
    'Violin Voice': 'violin music',
    'Cello Voice': 'cello music',
    }
timespan_inventory = flooded_timespan_maker(
    layer=3,
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
print(format(timespan_inventory))
</abjad>
\end{comment}

A new flooded timespan maker, configured with padding and a timespan specifier
which will further configure each generated timespan.

\begin{comment}
<abjad>
flooded_timespan_maker = consort.FloodedTimespanMaker(
    padding=Duration(1, 4),
    timespan_specifier=consort.TimespanSpecifier(
        minimum_duration=Duration(1, 8),
        ),
    )
timespan_inventory = flooded_timespan_maker(
    layer=5,
    music_specifiers=music_specifiers,
    target_timespan=target_timespan,
    )
print(format(timespan_inventory))
</abjad>
\end{comment}

\subsection{TaleaTimespanMaker}

\begin{comment}
<abjad>
timespan_maker = consort.TaleaTimespanMaker(
    initial_silence_talea=rhythmmakertools.Talea(
        counts=(0, 4),
        denominator=16,
        )
    )
</abjad>
\end{comment}

- taleas: playing, silence and initial silence

- groupings

- synchronization

- repeat and reflect

\subsection{DependentTimespanMaker}

\begin{comment}
<abjad>
dependent_timespan_maker = consort.DependentTimespanMaker(
    include_inner_starts=True,
    include_inner_stops=False,
    voice_names=(
        'Piano Upper Voice',
        'Piano Lower Voice',
        )
    )
</abjad>
\end{comment}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Rhythm makers}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

- divisions

\begin{comment}
<abjad>
divisions = [(3, 8), (4, 8), (3, 16), (4, 16), (5, 8), (2, 4)]
</abjad>
\end{comment}

- rhythm maker

\subsection{Rhythm maker configuration}

- specifiers: tie, duration spelling, beam

\subsection{Examples}

\subsubsection{NoteRhythmMaker}

\begin{comment}
<abjad>
note_rhythm_maker = rhythmmakertools.NoteRhythmMaker(
    )
show(note_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

\subsubsection{EvenDivisionsRhythmMaker}

\begin{comment}
<abjad>
even_division_rhythm_maker = rhythmmakertools.EvenDivisionRhythmMaker(
    denominators=[8, 16, 4],
    )
show(even_division_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

\subsubsection{IncisedRhythmMaker}

\begin{comment}
<abjad>
incised_rhythm_maker = rhythmmakertools.IncisedRhythmMaker(
    incise_specifier=rhythmmakertools.InciseSpecifier(
        prefix_counts=[0],
        suffix_talea=[-1],
        suffix_counts=[1],
        talea_denominator=16,
        ),
    )
show(incised_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

\subsubsection{TaleaRhythmMaker}

\begin{comment}
<abjad>
talea_rhythm_maker = rhythmmakertools.TaleaRhythmMaker(
    talea=rhythmmakertools.Talea(
        counts=[1, 2, 3, 4],
        denominator=16,
        ),
    )
show(talea_rhythm_maker, divisions=divisions)
</abjad>
\end{comment}

\subsection{\emph{Consort}'s composite rhythm maker}

\begin{comment}
<abjad>
composite_rhythm_maker = consort.CompositeRhythmMaker(
    default=note_rhythm_maker,
    last=incised_rhythm_maker,
    first=even_division_rhythm_maker,
    )
</abjad>
\end{comment}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Modeling meter}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Abjad models meter as a \emph{rhythm-tree} of nested, durated nodes which
outline a series of strongly and weakly accented offsets. The accent strength
of a particular offset found in a meter's rhythm-tree derives from the number
of nodes in that tree sharing that offset as a start or stop. The more nodes in
the rhythm-tree which share an offset, the greater the weight -- the
accentedness -- of that offset is taken to be. Abjad can construct the rhythm
tree for any meter from a numerator / denominator pair such as a rational
duration or time signature. Meter construction involves the progressive
division of the numerator of the input pair into groups of two and
threes\footnote{The factors 4 and 5 are also used in meter rhythm-tree
generation as they provide better typical results during meter rewriting.}, and
the decomposition of any other prime factors into groups of threes and twos.
Division by two always occurs before division by three, giving preference to
even metrical structures above odd or otherwise prime divisions. Constructing
rhythm-trees in this fashion gives results which generally align with common
practice expectations.

Consider the following 6/8 meter and its graph representation:

\begin{comment}
<abjad>
six_eight_meter = metertools.Meter((6, 8))
graph(six_eight_meter)
</abjad>
\end{comment}

\noindent The triangular and rectangular boxes indicate nodes in the
rhythm-tree itself. Rectangular boxes represent \enquote{beats} -- the leaves
of the rhythm-tree -- while triangular boxes indicate larger metrical
groupings. The ovals at the bottom of the graph indicate -- at their top -- the
start or stop offset of the nodes connected to them from above and -- at their
bottom -- the relative weight of their accent. The final oval on the right
indicates the offset and accent weight of the \enquote{next} downbeat.

The topmost triangle in the above graph represent the \enquote{highest}
metrical grouping in a 6/8 meter. Tracing the leftmost and rightmost arrows
down through the topmost node's children gives the offsets 0 and 3/4: the first
downbeat and next downbeat in a 6/8 meter. Offsets 0 and 3/4 also have the
strongest accent weights as they occur as either the start offset or stop
offset of nodes at three levels of hierarchy in the rhythm tree. At the second
level the 6/8 grouping divides into two 3/8 groupings, following common
practice expectations: metrical groupings tend to subdivide into groups of two
before they subdivide into groups of three\footnote{Consider a 12/8 meter.
Western musicians tend to subdivide twelve into either two groups of six or
four groups of three rather than into three groups of four.}. Both second-level
nodes share the offset of 3/8, which also occurs in the third level, giving 3/8
a weight of two. The third level contains the 1/8 duration beats, grouped by
their parents in the second level into two groups three 1/8 duration nodes. The
offsets 1/8, 1/4, 1/2 and 5/8 are not shared by any nodes except at the lowest
metrical level and therefore all receive an accent weight of one.

\subsection{Examples}

Consider the following examples of meters modeled in Abjad.

A 3/4 meter consists of a top-level 3/4 metrical grouping divided into three
1/4 duration beats:

\begin{comment}
<abjad>
three_four_meter = metertools.Meter((3, 4))
graph(three_four_meter)
</abjad>
\end{comment}

\noindent By default, a 7/8 meter subdivides its top-level metrical grouping
into 3/8+2/8+2/8 groupings:

\begin{comment}
<abjad>
seven_eight_meter = metertools.Meter((7, 8))
graph(seven_eight_meter)
</abjad>
\end{comment}

\noindent A 12/8 meter subdivides into four 3/8 duration groupings, each
containining three 1/8 duration beats:

\begin{comment}
<abjad>
twelve_eight_meter = metertools.Meter((12, 8))
graph(twelve_eight_meter)
</abjad>
\end{comment}

\subsection{Alternate meter representations}

Abjad permits alternate representations of meters with the same numerator and
denominator. The default interpretation of 4/4 generates a top-level rhythmic
grouping with a duration of 4/4 and four 1/4 beats as children\footnote{A
\enquote{flat} 4/4 metrical structure is useful for meter rewriting as it
allows the meter rewriting algorithm to ignore many common rhythmic idioms like
1/4+1/2+1/4 and 1/4+3/4.}.

\begin{comment}
<abjad>
four_four_meter = metertools.Meter((4, 4))
graph(four_four_meter)
</abjad>
\end{comment}

\noindent While meter objects are usually instantiated from numerator /
denominator pairs, with their rhythm-tree structure determined programmatically
from that input pair, they can also be instantiated from strings parseable as
rhythm-trees, or from RhythmTree objects themselves. All meters, because they
are implemented in terms of rhythm-trees, can be represented by a Lisp-like
rhythm-tree syntax:

\begin{comment}
<abjad>
print(four_four_meter.pretty_rtm_format)
</abjad>
\end{comment}

Instantiating meters from explicit rhythm tree syntax allows composers to
choose alternate representations of metrical structures. For example, a 4/4
meter which strongly emphasizes beat three is possible by subdividing the
top-level 4/4 metrical grouping into two 2/4 duration groupings, which are then
subdivided each into two 1/4 duration beats:

\begin{comment}
<abjad>
arbitrary_meter_1 = metertools.Meter('(4/4 ((2/4 (1/4 1/4)) (2/4 (1/4 1/4))))')
graph(arbitrary_meter_1)
</abjad>
\end{comment}

\noindent Unusual metrical structures are also possible, such as the following
4/4 meter which divides into two parts, with the first part dividing into two
again, and the second grouping of that divided into two again:

\begin{comment}
<abjad>
arbitrary_meter_2 = metertools.Meter('(4/4 ((2/4 (1/4 (1/4 (1/8 1/8)))) 1/2))')
graph(arbitrary_meter_2)
</abjad>
\end{comment}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Rewriting meters}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Notated rhythms can be expressed in multiple ways while maintaining the same
attack-point and duration structure. \emph{Meter rewriting} formalizes the
process of re-notating a rhythm according to the offset structure inherent to
some meter while maintaining the original attack-points and durations.

Consider the following rhythm:

\begin{comment}
<abjad>
parseable = "abj: | 2/4 c'2 ~ |"
parseable += "| 4/4 c'32 d'2.. ~ d'16 e'32 ~ |"
parseable += "| 2/4 e'2 |"
staff = Staff(parseable)
show(staff)
</abjad>
\end{comment}

The middle measure is notated in a perfectly valid manner. However, the
double-dotted D does not align with or break against any of the offsets of a
4/4 metrical structure: 0/4, 1/4, 2/4, 3/4 or 4/4.

\begin{comment}
<abjad>
four_four_meter = metertools.Meter((4, 4))
graph(four_four_meter)
</abjad>
\end{comment}

\begin{comment}
<abjad>
mutate(staff[1][:]).rewrite_meter(four_four_meter)
show(staff)
</abjad>
\end{comment}

\begin{comment}
<abjad>
two_two_meter = metertools.Meter((2, 2))
staff = Staff(parseable)
mutate(staff[1][:]).rewrite_meter(two_two_meter)
show(staff)
</abjad>
\end{comment}

\subsection{Dot count}

\begin{comment}
<abjad>
measure = Measure((3, 4), "c'32 d'8 e'8 fs'4...")
show(measure)
</abjad>
\end{comment}

\begin{comment}
<abjad>
mutate(measure[:]).rewrite_meter((3, 4))
show(measure)
</abjad>
\end{comment}

\begin{comment}
<abjad>
measure = Measure((3, 4), "c'32 d'8 e'8 fs'4...")
mutate(measure[:]).rewrite_meter((3, 4), maximum_dot_count=2)
show(measure)
</abjad>
\end{comment}

\begin{comment}
<abjad>
measure = Measure((3, 4), "c'32 d'8 e'8 fs'4...")
mutate(measure[:]).rewrite_meter((3, 4), maximum_dot_count=1)
show(measure)
</abjad>
\end{comment}

\begin{comment}
<abjad>
measure = Measure((3, 4), "c'32 d'8 e'8 fs'4...")
mutate(measure[:]).rewrite_meter((3, 4), maximum_dot_count=0)
show(measure)
</abjad>
\end{comment}

\subsection{Boundary depth}

\begin{comment}
<abjad>
nine_eight_meter = metertools.Meter((9, 8))
graph(nine_eight_meter)
</abjad>
\end{comment}

\begin{comment}
<abjad>
measure = Measure((9, 8), "c'2 d'2 e'8")
show(measure)
</abjad>
\end{comment}

\begin{comment}
<abjad>
mutate(measure[:]).rewrite_meter(nine_eight_meter)
show(measure)
</abjad>
\end{comment}

\begin{comment}
<abjad>
measure = Measure((9, 8), "c'2 d'2 e'8")
mutate(measure[:]).rewrite_meter(
    nine_eight_meter,
    boundary_depth=1,
    )
show(measure)
</abjad>
\end{comment}

\subsection{Example: disambiguating 3/4 \& 6/8}

\begin{comment}
<abjad>
staff = Staff(context_name='RhythmicStaff')
staff.extend("{ c'2 c'4 } { c'4. c'4. } { c'2 ~ c'8 c'8 }")
attach(TimeSignature((3, 4)), staff)
show(staff)
</abjad>
\end{comment}

\begin{comment}
<abjad>
for container in staff:
    mutate(container[:]).rewrite_meter((3, 4), boundary_depth=1)

show(staff)
</abjad>
\end{comment}

\begin{comment}
<abjad>
staff = Staff(context_name='RhythmicStaff')
staff.extend("{ c'2 c'4 } { c'4. c'4. } { c'2 ~ c'8 c'8 }")
attach(TimeSignature((6, 8)), staff)
for container in staff:
    mutate(container[:]).rewrite_meter((6, 8), boundary_depth=1)

show(staff)
</abjad>
\end{comment}

\subsection{Recursive meter rewriting}

\begin{comment}
<abjad>
parseable = "abj: | 4/4 c'16 ~ c'4 d'8. ~ "
parseable += "2/3 { d'8. ~ 3/5 { d'16 e'8 ~ e'16 f'16 ~ } } "
parseable += "f'4 |"
measure = parse(parseable)
show(measure)
</abjad>
\end{comment}

\begin{comment}
<abjad>
mutate(measure[:]).rewrite_meter(
    measure,
    boundary_depth=1,
    )
show(measure)
</abjad>
\end{comment}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Finding meters}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

How can we generate a series of meters?

A meter's weighted-offset pattern can be used as 1-dimensional kernel, or
convolution matrix, to determine how strongly an arbitrary collection of
offsets appears to express that meter.

Abjad's \texttt{metertools} provides a \texttt{MetricAccentKernel} class.

\subsection{Offset counters}

Before convolving a meter with a collection of offsets, those offsets need to
be extracted. The \texttt{MetricAccentKernel} class'
\texttt{count\_offsets\_in\_expr()} method collects offsets in its input
expression into an \emph{offset counter} -- a mapping of offsets to the number
of times those offsets appear. Offsets which appear multiple times in the input
expression will result in a higher count in the generated offset counter, and
will in turn have a greater influence during the meter convolution process.

Consider the following score example:

\begin{comment}
<abjad>
upper_staff = Staff("c'8 d'4. e'8 f'4.")
lower_staff = Staff(r'\clef bass c4 b,4 a,2')
piano_staff = scoretools.StaffGroup(
    [upper_staff, lower_staff],
    context_name='PianoStaff',
    )
show(piano_staff)
</abjad>
\end{comment}

\noindent The offsets found in all of the leaves of the score can be counted by
selecting the score's leaves and passing that selection to
\texttt{count\_offsets\_in\_expr()}.

\begin{comment}
<abjad>
leaves = piano_staff.select_leaves(allow_discontiguous_leaves=True)
piano_staff_counter = metertools.MetricAccentKernel.count_offsets_in_expr(
    leaves)
for offset, count in sorted(piano_staff_counter.items()):
    offset, count

</abjad>
\end{comment}

\noindent Note that the offset 1/2 shows a count of 4. This is because 1/2 acts
as both the start and stop offset for four separate leaves in the score.

Offset counters can also be generated from timespan inventories, allowing meter
convolution to be used without reference to any score objects at all:

\begin{comment}
<abjad>
timespans = timespantools.TimespanInventory([
    timespantools.Timespan(-1, 10),
    timespantools.Timespan(5, 15),
    timespantools.Timespan(15, 20),
    timespantools.Timespan(10, 15),
    ])
timespan_counter = metertools.MetricAccentKernel.count_offsets_in_expr(
    timespans)
for offset, count in sorted(timespan_counter.items()):
    offset, count

</abjad>
\end{comment}

\subsection{Generating metric accent kernels}

As demonstrated earlier, meters describe a sequence of offsets with varying
degrees of weight, or accentedness, attributed to each offset. Downbeats have a
stronger accent than upbeats, the half-way beat of a 6/8 measure is less strong
than the downbeat but stronger than any of the others, etc.

\begin{comment}
<abjad>
meter = metertools.Meter((4, 4))
kernel_44 = metertools.MetricAccentKernel.from_meter(meter, denominator=8)
for offset, weight in sorted(kernel_44.kernel.items()):
    print('{!s}\t{!s}'.format(offset, weight))

</abjad>
\end{comment}

\subsection{Evaluating metric accent kernels}

\noindent The 4/4 metric accent kernel can be called against an offset counter
-- as though it were a function -- to generate a response via a kind of simple
offset-wise convolution. The count at each offset in the input offset counter
is multiplied against the weight at the corresponding offset in the metric
accent kernel. If no corresponding offset exists in the kernel, the weight is
taken as 0. The weighted counts are then added together and returned.

\begin{comment}
<abjad>
response = kernel_44(piano_staff_counter)
float(response)
</abjad>
\end{comment}

\begin{comment}
<abjad>
total = Multiplier(0, 1)
for offset, count in sorted(piano_staff_counter.items()):
    weight = Multiplier(0, 1)
    if offset in kernel_44.kernel:
        weight = kernel_44.kernel[offset]
    weighted_count = weight * count
    total += weighted_count
    print(offset, count, weight, weighted_count, total)

</abjad>
\end{comment}

\noindent Now consider the metric accent kernels for 3/4, 7/8 and 5/4 meters:

\begin{comment}
<abjad>
kernel_34 = metertools.MetricAccentKernel.from_meter((3, 4), denominator=8)
kernel_78 = metertools.MetricAccentKernel.from_meter((7, 8), denominator=8)
kernel_54 = metertools.MetricAccentKernel.from_meter((5, 4), denominator=8)
</abjad>
\end{comment}

\noindent We can generate an response for each of these kernels against the
piano staff offset counter.

\begin{comment}
<abjad>
float(kernel_34(piano_staff_counter))
float(kernel_78(piano_staff_counter))
float(kernel_54(piano_staff_counter))
</abjad>
\end{comment}

\noindent Note that the previously recorded response for a 4/4 meter is still
higher than any of these.

\subsection{Meter fitting}

\begin{comment}
<abjad>
permitted_meters = [metertools.Meter(_) for _ in [(3, 4), (4, 4), (5, 4)]]
offsets = [(0, 4), (4, 4), (8, 4), (12, 4), (16, 4)]
for x in metertools.Meter.fit_meters_to_expr(offsets, permitted_meters):
    print(x.implied_time_signature)

</abjad>
\end{comment}

\begin{comment}
<abjad>
offsets = [(0, 4), (3, 4), (5, 4), (10, 4), (15, 4), (20, 4)]
for x in metertools.Meter.fit_meters_to_expr(offsets, permitted_meters):
    print(x.implied_time_signature)

</abjad>
\end{comment}

\begin{comment}
<abjad>
offsets = [(0, 4), (3, 4), (5, 4), (10, 4), (15, 4), (20, 4)]
for x in metertools.Meter.fit_meters_to_expr(
    offsets,
    permitted_meters,
    maximum_run_length=1,
    ):
    print(x.implied_time_signature)

</abjad>
\end{comment}